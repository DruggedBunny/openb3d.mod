!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	.\openb3d\src\project.cpp	47;"	d	file:
A	.\openb3d\src\project.cpp	71;"	d	file:
ACTIONS_H	.\openb3d\src\actions.h	2;"	d
ACTION_act	.\data.cpp	/^const int ACTION_act=			2;$/;"	v
ACTION_action_list	.\data.cpp	/^const int ACTION_action_list=	1;$/;"	v
ACTION_class	.\data.cpp	/^const int ACTION_class=			1;$/;"	v
ACT_COMPLETED	.\openb3d\src\actions.h	/^enum{ACT_COMPLETED,$/;"	e	enum:__anon1
ACT_FADETO	.\openb3d\src\actions.h	/^ACT_FADETO,$/;"	e	enum:__anon1
ACT_MOVEBY	.\openb3d\src\actions.h	/^ACT_MOVEBY,$/;"	e	enum:__anon1
ACT_MOVETO	.\openb3d\src\actions.h	/^ACT_MOVETO,$/;"	e	enum:__anon1
ACT_NEWTONIAN	.\openb3d\src\actions.h	/^ACT_NEWTONIAN$/;"	e	enum:__anon1
ACT_SCALETO	.\openb3d\src\actions.h	/^ACT_SCALETO,$/;"	e	enum:__anon1
ACT_TINTTO	.\openb3d\src\actions.h	/^ACT_TINTTO,$/;"	e	enum:__anon1
ACT_TRACK_BY_DISTANCE	.\openb3d\src\actions.h	/^ACT_TRACK_BY_DISTANCE,$/;"	e	enum:__anon1
ACT_TRACK_BY_POINT	.\openb3d\src\actions.h	/^ACT_TRACK_BY_POINT,$/;"	e	enum:__anon1
ACT_TURNBY	.\openb3d\src\actions.h	/^ACT_TURNBY,$/;"	e	enum:__anon1
ACT_TURNTO	.\openb3d\src\actions.h	/^ACT_TURNTO,$/;"	e	enum:__anon1
ACT_VECTOR	.\openb3d\src\actions.h	/^ACT_VECTOR,$/;"	e	enum:__anon1
ANIM	.\openb3d\src\model.cpp	/^const int ANIM=4;$/;"	v
ANIMATIONKEYS_class	.\data.cpp	/^const int ANIMATIONKEYS_class=	3;$/;"	v
ANIMATIONKEYS_flags	.\data.cpp	/^const int ANIMATIONKEYS_flags=	2;$/;"	v
ANIMATIONKEYS_frames	.\data.cpp	/^const int ANIMATIONKEYS_frames=	1;$/;"	v
ANIMATIONKEYS_px	.\data.cpp	/^const int ANIMATIONKEYS_px=		3;$/;"	v
ANIMATIONKEYS_py	.\data.cpp	/^const int ANIMATIONKEYS_py=		4;$/;"	v
ANIMATIONKEYS_pz	.\data.cpp	/^const int ANIMATIONKEYS_pz=		5;$/;"	v
ANIMATIONKEYS_qw	.\data.cpp	/^const int ANIMATIONKEYS_qw=		9;$/;"	v
ANIMATIONKEYS_qx	.\data.cpp	/^const int ANIMATIONKEYS_qx=		10;$/;"	v
ANIMATIONKEYS_qy	.\data.cpp	/^const int ANIMATIONKEYS_qy=		11;$/;"	v
ANIMATIONKEYS_qz	.\data.cpp	/^const int ANIMATIONKEYS_qz=		12;$/;"	v
ANIMATIONKEYS_sx	.\data.cpp	/^const int ANIMATIONKEYS_sx=		6;$/;"	v
ANIMATIONKEYS_sy	.\data.cpp	/^const int ANIMATIONKEYS_sy=		7;$/;"	v
ANIMATIONKEYS_sz	.\data.cpp	/^const int ANIMATIONKEYS_sz=		8;$/;"	v
ANIMATION_H	.\openb3d\src\animation.h	11;"	d
ANIMATION_KEYS_H	.\openb3d\src\animation_keys.h	2;"	d
ANIMATION_class	.\data.cpp	/^const int ANIMATION_class=		2;$/;"	v
ActFadeTo	.\openb3d\src\functions.cpp	/^Action* ActFadeTo(Entity* ent, float a, float rate){$/;"	f
ActMoveBy	.\openb3d\src\functions.cpp	/^Action* ActMoveBy(Entity* ent, float a, float b, float c, float rate){$/;"	f
ActMoveTo	.\openb3d\src\functions.cpp	/^Action* ActMoveTo(Entity* ent, float a, float b, float c, float rate){$/;"	f
ActNewtonian	.\openb3d\src\functions.cpp	/^Action* ActNewtonian(Entity* ent, float rate){$/;"	f
ActScaleTo	.\openb3d\src\functions.cpp	/^Action* ActScaleTo(Entity* ent, float a, float b, float c, float rate){$/;"	f
ActTintTo	.\openb3d\src\functions.cpp	/^Action* ActTintTo(Entity* ent, float a, float b, float c, float rate){$/;"	f
ActTrackByDistance	.\openb3d\src\functions.cpp	/^Action* ActTrackByDistance(Entity* ent, Entity* target, float a, float rate){$/;"	f
ActTrackByPoint	.\openb3d\src\functions.cpp	/^Action* ActTrackByPoint(Entity* ent, Entity* target, float a, float b, float c, float rate){$/;"	f
ActTurnBy	.\openb3d\src\functions.cpp	/^Action* ActTurnBy(Entity* ent, float a, float b, float c, float rate){$/;"	f
ActTurnTo	.\openb3d\src\functions.cpp	/^Action* ActTurnTo(Entity* ent, float a, float b, float c, float rate){$/;"	f
ActVector	.\openb3d\src\functions.cpp	/^Action* ActVector(Entity* ent, float a, float b, float c){$/;"	f
Action	.\openb3d\src\actions.h	/^class Action{$/;"	c
ActionInt	.\data.cpp	/^int* ActionInt( Action* obj,int varid ){$/;"	f
Activate	.\openb3d\src\material.cpp	/^void ProgramObject::Activate(){$/;"	f	class:ProgramObject
Activate	.\openb3d\src\material.h	/^	void Activate(){$/;"	f	class:MaterialPlugin
Active	.\openb3d\src\material.h	/^	int Active;$/;"	m	class:MaterialPlugin
Add	.\openb3d\src\x.cpp	/^		void Add(XLoader_TreeNode* element){$/;"	f	class:loadX::XLoader_TreeNode
Add3DVertex	.\openb3d\src\voxel.cpp	/^void Add3DVertex(Surface* surf, float x, float y, float z,float u,float v,float w){$/;"	f
AddAction	.\openb3d\src\actions.cpp	/^Action* Action::AddAction(Entity* ent, int action, Entity* t, float a, float b, float c, float rate){$/;"	f	class:Action
AddAction	.\openb3d\src\actions.h	/^	static Action* AddAction(Entity* ent, int action, Entity* t, float rate){$/;"	f	class:Action
AddAction	.\openb3d\src\actions.h	/^	static Action* AddAction(Entity* ent, int action, float a, float b, float c, float rate){$/;"	f	class:Action
AddAnimSeq	.\openb3d\src\entity.cpp	/^int Entity::AddAnimSeq(int length){$/;"	f	class:Entity
AddAnimSeq	.\openb3d\src\functions.cpp	/^int AddAnimSeq(Entity* ent,int length){$/;"	f
AddMesh	.\openb3d\src\functions.cpp	/^void AddMesh(Mesh* mesh1,Mesh* mesh2){$/;"	f
AddMesh	.\openb3d\src\mesh.cpp	/^void Mesh::AddMesh(Mesh* mesh2){$/;"	f	class:Mesh
AddParent	.\methods.cpp	/^void AddParent( Entity* obj,Entity &parent_ent ){$/;"	f
AddParent	.\openb3d\src\entity.cpp	/^void Entity::AddParent(Entity &parent_ent){$/;"	f	class:Entity
AddSampler2D	.\openb3d\src\material.cpp	/^Texture* Shader::AddSampler2D(string Name, int Slot, Texture* Tex){$/;"	f	class:Shader
AddSampler3D	.\openb3d\src\material.cpp	/^void Shader::AddSampler3D(string Name, int Slot, Texture* Tex){$/;"	f	class:Shader
AddShader	.\openb3d\src\material.cpp	/^void Shader::AddShader(string _vert, string _frag){$/;"	f	class:Shader
AddShaderFromString	.\openb3d\src\material.cpp	/^void Shader::AddShaderFromString(string _vert, string _frag){$/;"	f	class:Shader
AddTextureFilter	.\openb3d\src\texture.cpp	/^void Texture::AddTextureFilter(string text_match,int flags){$/;"	f	class:Texture
AddToOctree	.\openb3d\src\octree.cpp	/^void OcTreeChild::AddToOctree(Mesh* mesh1, int level, float X, float Y, float Z, float Near, float Far, int block){$/;"	f	class:OcTreeChild
AddTransformedSpriteToSurface	.\methods.cpp	/^void AddTransformedSpriteToSurface( Camera* obj,Sprite& sprite,Surface* surf ){$/;"	f
AddTransformedSpriteToSurface	.\openb3d\src\camera.cpp	/^void Camera::AddTransformedSpriteToSurface(Sprite& sprite,Surface* surf){$/;"	f	class:Camera
AddTriangle	.\openb3d\src\functions.cpp	/^int AddTriangle(Surface* surf,int v0,int v1,int v2){$/;"	f
AddTriangle	.\openb3d\src\surface.cpp	/^int Surface::AddTriangle(unsigned short v0,unsigned short v1,unsigned short v2){$/;"	f	class:Surface
AddVertex	.\openb3d\src\functions.cpp	/^int AddVertex(Surface* surf,float x, float y,float z,float u, float v,float w){$/;"	f
AddVertex	.\openb3d\src\surface.cpp	/^int Surface::AddVertex(float x,float y,float z,float u,float v,float w){$/;"	f	class:Surface
AlignToVector	.\methods.cpp	/^void AlignToVector( Entity* obj,float x,float y,float z,int axis,float rate ){$/;"	f
AlignToVector	.\openb3d\src\entity.cpp	/^void Entity::AlignToVector(float x,float y,float z, int axis=3, float rate=1){$/;"	f	class:Entity
Alpha	.\methods.cpp	/^int Alpha( Mesh* obj ){$/;"	f
Alpha	.\openb3d\src\mesh.cpp	/^int Mesh::Alpha(){$/;"	f	class:Mesh
AmbientLight	.\openb3d\src\functions.cpp	/^void AmbientLight(float r,float g,float b){$/;"	f
AmbientLight	.\openb3d\src\global.cpp	/^void Global::AmbientLight(float r,float g,float b){$/;"	f	class:Global
AmbientShader	.\openb3d\src\functions.cpp	/^void AmbientShader(Shader* material){$/;"	f
AnimLength	.\openb3d\src\entity.cpp	/^int Entity::AnimLength(){$/;"	f	class:Entity
AnimLength	.\openb3d\src\functions.cpp	/^int AnimLength(Entity* ent){$/;"	f
AnimSeq	.\openb3d\src\functions.cpp	/^int AnimSeq(Entity* ent){$/;"	f
AnimTime	.\openb3d\src\entity.cpp	/^float Entity::AnimTime(){$/;"	f	class:Entity
AnimTime	.\openb3d\src\functions.cpp	/^float AnimTime(Entity* ent){$/;"	f
Animate	.\openb3d\src\entity.cpp	/^void Entity::Animate(int mode,float speed,int seq,int trans){$/;"	f	class:Entity
Animate	.\openb3d\src\functions.cpp	/^void Animate(Entity* ent,int mode,float speed,int seq,int trans){$/;"	f
AnimateMesh	.\methods.cpp	/^void AnimateMesh( Mesh* ent1,float framef,int start_frame,int end_frame ){$/;"	f
AnimateMesh	.\openb3d\src\animation.cpp	/^void Animation::AnimateMesh(Mesh* ent1,float framef,int start_frame,int end_frame){$/;"	f	class:Animation
AnimateMesh2	.\methods.cpp	/^void AnimateMesh2( Mesh* ent1,float framef,int start_frame,int end_frame ){$/;"	f
AnimateMesh2	.\openb3d\src\animation.cpp	/^void Animation::AnimateMesh2(Mesh* ent1,float framef,int start_frame,int end_frame){$/;"	f	class:Animation
AnimateMesh3	.\methods.cpp	/^void AnimateMesh3(Mesh* ent1){$/;"	f
AnimateMesh3	.\openb3d\src\animation.cpp	/^void Animation::AnimateMesh3(Mesh* ent1){$/;"	f	class:Animation
Animating	.\openb3d\src\functions.cpp	/^int Animating(Entity* ent){$/;"	f
Animation	.\openb3d\src\animation.h	/^class Animation{$/;"	c
AnimationKeys	.\openb3d\src\animation_keys.h	/^	AnimationKeys(){$/;"	f	class:AnimationKeys
AnimationKeys	.\openb3d\src\animation_keys.h	/^class AnimationKeys{$/;"	c
AnimationKeysCopy	.\methods.cpp	/^AnimationKeys* AnimationKeysCopy( AnimationKeys* obj ){$/;"	f
AnimationKeysFloat	.\data.cpp	/^float* AnimationKeysFloat( AnimationKeys* obj,int varid ){$/;"	f
AnimationKeysInt	.\data.cpp	/^int* AnimationKeysInt( AnimationKeys* obj,int varid ){$/;"	f
AntiAlias	.\openb3d\src\functions.cpp	/^void AntiAlias(int samples){$/;"	f
AppendAction	.\openb3d\src\actions.cpp	/^void Action::AppendAction(Action* a){$/;"	f	class:Action
AppendAction	.\openb3d\src\functions.cpp	/^void AppendAction(Action* act1, Action* act2){$/;"	f
ArraysField	.\openb3d\src\isosurface.cpp	/^float ArraysField (float x, float y, float z){$/;"	f
Asc	.\openb3d\src\string_helper.cpp	/^int Asc(string s){$/;"	f
AttachFragShader	.\openb3d\src\material.cpp	/^int ProgramObject::AttachFragShader(ShaderObject* myShader){$/;"	f	class:ProgramObject
AttachVertShader	.\openb3d\src\material.cpp	/^int ProgramObject::AttachVertShader(ShaderObject* myShader){$/;"	f	class:ProgramObject
Attached	.\openb3d\src\shaderobject.h	/^	list<ProgramObject*> Attached;		\/\/ Shaders can be attached, or 'referenced by', more than 1 ProgramObject$/;"	m	class:ShaderObject
B	.\openb3d\src\project.cpp	48;"	d	file:
B	.\openb3d\src\project.cpp	72;"	d	file:
BANK_H	.\openb3d\src\bank.h	2;"	d
BBDebugScope_365	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^struct BBDebugScope_365{int kind; const char *name; BBDebugDecl decls[366]; };$/;"	s	file:
BBDebugScope_365	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^struct BBDebugScope_365{int kind; const char *name; BBDebugDecl decls[366]; };$/;"	s	file:
BLOB_class	.\data.cpp	/^const int BLOB_class=			23;$/;"	v
BONE	.\openb3d\src\model.cpp	/^const int BONE=8;$/;"	v
BONE_H	.\openb3d\src\bone.h	2;"	d
BONE_class	.\data.cpp	/^const int BONE_class=			4;$/;"	v
BONE_inv_mat	.\data.cpp	/^const int BONE_inv_mat=		16;$/;"	v
BONE_keys	.\data.cpp	/^const int BONE_keys=		14;$/;"	v
BONE_kqw	.\data.cpp	/^const int BONE_kqw=			21;$/;"	v
BONE_kqx	.\data.cpp	/^const int BONE_kqx=			22;$/;"	v
BONE_kqy	.\data.cpp	/^const int BONE_kqy=			23;$/;"	v
BONE_kqz	.\data.cpp	/^const int BONE_kqz=			24;$/;"	v
BONE_kx	.\data.cpp	/^const int BONE_kx=			18;$/;"	v
BONE_ky	.\data.cpp	/^const int BONE_ky=			19;$/;"	v
BONE_kz	.\data.cpp	/^const int BONE_kz=			20;$/;"	v
BONE_mat2	.\data.cpp	/^const int BONE_mat2=		15;$/;"	v
BONE_n_px	.\data.cpp	/^const int BONE_n_px=		1;$/;"	v
BONE_n_py	.\data.cpp	/^const int BONE_n_py=		2;$/;"	v
BONE_n_pz	.\data.cpp	/^const int BONE_n_pz=		3;$/;"	v
BONE_n_qw	.\data.cpp	/^const int BONE_n_qw=		10;$/;"	v
BONE_n_qx	.\data.cpp	/^const int BONE_n_qx=		11;$/;"	v
BONE_n_qy	.\data.cpp	/^const int BONE_n_qy=		12;$/;"	v
BONE_n_qz	.\data.cpp	/^const int BONE_n_qz=		13;$/;"	v
BONE_n_rx	.\data.cpp	/^const int BONE_n_rx=		7;$/;"	v
BONE_n_ry	.\data.cpp	/^const int BONE_n_ry=		8;$/;"	v
BONE_n_rz	.\data.cpp	/^const int BONE_n_rz=		9;$/;"	v
BONE_n_sx	.\data.cpp	/^const int BONE_n_sx=		4;$/;"	v
BONE_n_sy	.\data.cpp	/^const int BONE_n_sy=		5;$/;"	v
BONE_n_sz	.\data.cpp	/^const int BONE_n_sz=		6;$/;"	v
BONE_tform_mat	.\data.cpp	/^const int BONE_tform_mat=	17;$/;"	v
BOX_class	.\data.cpp	/^const int BOX_class=			18;$/;"	v
BRUS	.\openb3d\src\model.cpp	/^const int BRUS=2;$/;"	v
BRUSH_H	.\openb3d\src\brush.h	2;"	d
BRUSH_alpha	.\data.cpp	/^const int BRUSH_alpha=			6;$/;"	v
BRUSH_blend	.\data.cpp	/^const int BRUSH_blend=			8;$/;"	v
BRUSH_blue	.\data.cpp	/^const int BRUSH_blue=			5;$/;"	v
BRUSH_cache_frame	.\data.cpp	/^const int BRUSH_cache_frame=	10;$/;"	v
BRUSH_class	.\data.cpp	/^const int BRUSH_class=			5;$/;"	v
BRUSH_fx	.\data.cpp	/^const int BRUSH_fx=				9;$/;"	v
BRUSH_green	.\data.cpp	/^const int BRUSH_green=			4;$/;"	v
BRUSH_name	.\data.cpp	/^const int BRUSH_name=			2;$/;"	v
BRUSH_no_texs	.\data.cpp	/^const int BRUSH_no_texs=		1;$/;"	v
BRUSH_red	.\data.cpp	/^const int BRUSH_red=			3;$/;"	v
BRUSH_shine	.\data.cpp	/^const int BRUSH_shine=			7;$/;"	v
BRUSH_tex	.\data.cpp	/^const int BRUSH_tex=			11;$/;"	v
BackBufferToTex	.\openb3d\src\functions.cpp	/^void BackBufferToTex(Texture* tex,int frame){$/;"	f
BackBufferToTex	.\openb3d\src\texture.cpp	/^void Texture::BackBufferToTex(int frame){$/;"	f	class:Texture
Bank	.\openb3d\src\bank.h	/^	Bank(){};$/;"	f	class:Bank
Bank	.\openb3d\src\bank.h	/^class Bank{$/;"	c
BankSize	.\openb3d\src\bank.h	/^	int BankSize(){$/;"	f	class:Bank
Blob	.\openb3d\src\isosurface.h	/^	Blob(){};$/;"	f	class:Blob
Blob	.\openb3d\src\isosurface.h	/^class Blob : public Entity{$/;"	c
Bone	.\openb3d\src\bone.h	/^	Bone(){$/;"	f	class:Bone
Bone	.\openb3d\src\bone.h	/^class Bone : public Entity{$/;"	c
BoneAnimationKeys	.\data.cpp	/^AnimationKeys* BoneAnimationKeys( Bone* obj,int varid ){$/;"	f
BoneFloat	.\data.cpp	/^float* BoneFloat( Bone* obj,int varid ){$/;"	f
BoneMatrix	.\data.cpp	/^Matrix* BoneMatrix( Bone* obj,int varid ){$/;"	f
Box	.\openb3d\src\geom.h	/^	Box( const Line &l ):a(l.o),b(l.o){$/;"	f	class:Box
Box	.\openb3d\src\geom.h	/^	Box( const Vector &a,const Vector &b ):a(a),b(b){$/;"	f	class:Box
Box	.\openb3d\src\geom.h	/^	Box( const Vector &q ):a(q),b(q){$/;"	f	class:Box
Box	.\openb3d\src\geom.h	/^	Box():a( Vector(INFINITY,INFINITY,INFINITY) ),b( Vector(-INFINITY,-INFINITY,-INFINITY) ){$/;"	f	class:Box
Box	.\openb3d\src\geom.h	/^class Box{$/;"	c
BoxesOverlap	.\openb3d\src\csg.cpp	/^bool BoxesOverlap(float x0, float y0, float z0, float w0, float h0, float d0, float x2, float y2, float z2, float w2, float h2, float d2){$/;"	f	namespace:CSG
Brush	.\openb3d\src\brush.h	/^	Brush(){$/;"	f	class:Brush
Brush	.\openb3d\src\brush.h	/^class Brush{$/;"	c
BrushAlpha	.\openb3d\src\brush.cpp	/^void Brush::BrushAlpha(float a){$/;"	f	class:Brush
BrushAlpha	.\openb3d\src\functions.cpp	/^void BrushAlpha(Brush* brush, float a){$/;"	f
BrushBlend	.\openb3d\src\brush.cpp	/^void Brush::BrushBlend(int blend_no){$/;"	f	class:Brush
BrushBlend	.\openb3d\src\functions.cpp	/^void BrushBlend(Brush* brush,int blend){$/;"	f
BrushColor	.\openb3d\src\brush.cpp	/^void Brush::BrushColor(float r,float g,float b){$/;"	f	class:Brush
BrushColor	.\openb3d\src\functions.cpp	/^void BrushColor(Brush* brush,float r,float g,float b){$/;"	f
BrushCopy	.\methods.cpp	/^Brush* BrushCopy( Brush* obj ){$/;"	f
BrushFX	.\openb3d\src\brush.cpp	/^void Brush::BrushFX(int fx_no){$/;"	f	class:Brush
BrushFX	.\openb3d\src\functions.cpp	/^void BrushFX(Brush* brush,int fx){$/;"	f
BrushFloat	.\data.cpp	/^float* BrushFloat( Brush* obj,int varid ){$/;"	f
BrushGLBlendFunc	.\openb3d\src\functions.cpp	/^void BrushGLBlendFunc(Brush* brush, int sfactor, int dfactor){$/;"	f
BrushGLColor	.\openb3d\src\functions.cpp	/^void BrushGLColor(Brush* brush, float r, float g, float b, float a){$/;"	f
BrushInt	.\data.cpp	/^int* BrushInt( Brush* obj,int varid ){$/;"	f
BrushShininess	.\openb3d\src\brush.cpp	/^void Brush::BrushShininess(float s){$/;"	f	class:Brush
BrushShininess	.\openb3d\src\functions.cpp	/^void BrushShininess(Brush* brush,float s){$/;"	f
BrushString	.\data.cpp	/^const char* BrushString( Brush* obj,int varid ){$/;"	f
BrushTexture	.\openb3d\src\brush.cpp	/^void Brush::BrushTexture(Texture* texture, int frame, int index){$/;"	f	class:Brush
BrushTexture	.\openb3d\src\functions.cpp	/^void BrushTexture(Brush* brush,Texture* tex,int frame,int index){$/;"	f
BrushTextureArray	.\data.cpp	/^Texture* BrushTextureArray( Brush* obj,int varid,int index ){$/;"	f
BrushUInt	.\data.cpp	/^unsigned int* BrushUInt( Brush* obj,int varid ){$/;"	f
Brushs	.\openb3d\src\3ds.cpp	/^list<Brush*>   Brushs;$/;"	m	namespace:load3ds	file:
BufferToTex	.\openb3d\src\functions.cpp	/^void BufferToTex(Texture* tex,unsigned char* buffer, int frame){$/;"	f
BufferToTex	.\openb3d\src\texture.cpp	/^void Texture::BufferToTex(unsigned char* buffer, int frame){$/;"	f	class:Texture
BuildCubeGrid	.\openb3d\src\isosurface.cpp	/^void Fluid::BuildCubeGrid(float x, float y, float z, float l, float f1, float f2, float f3, float f4, float f5, float f6, float f7, float f8){$/;"	f	class:Fluid
BuildCubeGrid	.\openb3d\src\voxterrain.cpp	/^void VoxelTerrain::BuildCubeGrid(float x, float y, float z, float l, float f1, float f2, float f3, float f4, float f5, float f6, float f7, float f8){$/;"	f	class:VoxelTerrain
CAMERA_H	.\openb3d\src\camera.h	2;"	d
CAMERA_cam_list	.\data.cpp	/^const int CAMERA_cam_list=			1;$/;"	v
CAMERA_class	.\data.cpp	/^const int CAMERA_class=			6;$/;"	v
CAMERA_cls_b	.\data.cpp	/^const int CAMERA_cls_b=				9;$/;"	v
CAMERA_cls_color	.\data.cpp	/^const int CAMERA_cls_color=			10;$/;"	v
CAMERA_cls_g	.\data.cpp	/^const int CAMERA_cls_g=				8;$/;"	v
CAMERA_cls_r	.\data.cpp	/^const int CAMERA_cls_r=				7;$/;"	v
CAMERA_cls_zbuffer	.\data.cpp	/^const int CAMERA_cls_zbuffer=		11;$/;"	v
CAMERA_fog_b	.\data.cpp	/^const int CAMERA_fog_b=				19;$/;"	v
CAMERA_fog_g	.\data.cpp	/^const int CAMERA_fog_g=				18;$/;"	v
CAMERA_fog_mode	.\data.cpp	/^const int CAMERA_fog_mode=			16;$/;"	v
CAMERA_fog_r	.\data.cpp	/^const int CAMERA_fog_r=				17;$/;"	v
CAMERA_fog_range_far	.\data.cpp	/^const int CAMERA_fog_range_far=		21;$/;"	v
CAMERA_fog_range_near	.\data.cpp	/^const int CAMERA_fog_range_near=	20;$/;"	v
CAMERA_frustum	.\data.cpp	/^const int CAMERA_frustum=			29; \/\/ array [6][4]$/;"	v
CAMERA_mod_mat	.\data.cpp	/^const int CAMERA_mod_mat=			23; \/\/ array [16]$/;"	v
CAMERA_proj_mat	.\data.cpp	/^const int CAMERA_proj_mat=			24; \/\/ array [16]$/;"	v
CAMERA_proj_mode	.\data.cpp	/^const int CAMERA_proj_mode=			15;$/;"	v
CAMERA_project_enabled	.\data.cpp	/^const int CAMERA_project_enabled=	22;$/;"	v
CAMERA_projected_x	.\data.cpp	/^const int CAMERA_projected_x=		26;$/;"	v
CAMERA_projected_y	.\data.cpp	/^const int CAMERA_projected_y=		27;$/;"	v
CAMERA_projected_z	.\data.cpp	/^const int CAMERA_projected_z=		28;$/;"	v
CAMERA_range_far	.\data.cpp	/^const int CAMERA_range_far=			13;$/;"	v
CAMERA_range_near	.\data.cpp	/^const int CAMERA_range_near=		12;$/;"	v
CAMERA_render_list	.\data.cpp	/^const int CAMERA_render_list=		2;$/;"	v
CAMERA_vheight	.\data.cpp	/^const int CAMERA_vheight=			6;$/;"	v
CAMERA_viewport	.\data.cpp	/^const int CAMERA_viewport=			25; \/\/ array [4]$/;"	v
CAMERA_vwidth	.\data.cpp	/^const int CAMERA_vwidth=			5;$/;"	v
CAMERA_vx	.\data.cpp	/^const int CAMERA_vx=				3;$/;"	v
CAMERA_vy	.\data.cpp	/^const int CAMERA_vy=				4;$/;"	v
CAMERA_zoom	.\data.cpp	/^const int CAMERA_zoom=				14;$/;"	v
CASE	.\openb3d\src\stb_image.c	2508;"	d	file:
CASE	.\openb3d\src\stb_image.c	2521;"	d	file:
CASE	.\openb3d\src\stb_image.c	2524;"	d	file:
CASE	.\openb3d\src\stb_image.c	2537;"	d	file:
CASE	.\openb3d\src\stb_image.c	876;"	d	file:
CASE	.\openb3d\src\stb_image.c	894;"	d	file:
COLLISION2_H	.\openb3d\src\collision2.h	2;"	d
COLLISIONIMPACT_class	.\data.cpp	/^const int COLLISIONIMPACT_class=10;$/;"	v
COLLISIONIMPACT_ent	.\data.cpp	/^const int COLLISIONIMPACT_ent=	8;$/;"	v
COLLISIONIMPACT_nx	.\data.cpp	/^const int COLLISIONIMPACT_nx=	4;$/;"	v
COLLISIONIMPACT_ny	.\data.cpp	/^const int COLLISIONIMPACT_ny=	5;$/;"	v
COLLISIONIMPACT_nz	.\data.cpp	/^const int COLLISIONIMPACT_nz=	6;$/;"	v
COLLISIONIMPACT_surf	.\data.cpp	/^const int COLLISIONIMPACT_surf=	9;$/;"	v
COLLISIONIMPACT_time	.\data.cpp	/^const int COLLISIONIMPACT_time=	7;$/;"	v
COLLISIONIMPACT_tri	.\data.cpp	/^const int COLLISIONIMPACT_tri=	10;$/;"	v
COLLISIONIMPACT_x	.\data.cpp	/^const int COLLISIONIMPACT_x=	1;$/;"	v
COLLISIONIMPACT_y	.\data.cpp	/^const int COLLISIONIMPACT_y=	2;$/;"	v
COLLISIONIMPACT_z	.\data.cpp	/^const int COLLISIONIMPACT_z=	3;$/;"	v
COLLISIONINFO_class	.\data.cpp	/^const int COLLISIONINFO_class=	8;$/;"	v
COLLISIONPAIR_class	.\data.cpp	/^const int COLLISIONPAIR_class=	9; \/\/ collision2.h$/;"	v
COLLISIONPAIR_col_method	.\data.cpp	/^const int COLLISIONPAIR_col_method=	5;$/;"	v
COLLISIONPAIR_cp_list	.\data.cpp	/^const int COLLISIONPAIR_cp_list=	1;$/;"	v
COLLISIONPAIR_des_type	.\data.cpp	/^const int COLLISIONPAIR_des_type=	4;$/;"	v
COLLISIONPAIR_ent_lists	.\data.cpp	/^const int COLLISIONPAIR_ent_lists=	2;$/;"	v
COLLISIONPAIR_response	.\data.cpp	/^const int COLLISIONPAIR_response=	6;$/;"	v
COLLISIONPAIR_src_type	.\data.cpp	/^const int COLLISIONPAIR_src_type=	3;$/;"	v
COLLISION_EPSILON	.\openb3d\src\collision.h	/^const float COLLISION_EPSILON=.001f;$/;"	v
COLLISION_H	.\openb3d\src\collision.h	2;"	d
COLLISION_METHOD_BOX	.\openb3d\src\collision.h	/^	COLLISION_METHOD_BOX=3$/;"	e	enum:__anon2
COLLISION_METHOD_POLYGON	.\openb3d\src\collision.h	/^	COLLISION_METHOD_POLYGON=2,$/;"	e	enum:__anon2
COLLISION_METHOD_SPHERE	.\openb3d\src\collision.h	/^	COLLISION_METHOD_SPHERE=1,$/;"	e	enum:__anon2
COLLISION_RESPONSE_NONE	.\openb3d\src\collision.h	/^	COLLISION_RESPONSE_NONE=0,$/;"	e	enum:__anon3
COLLISION_RESPONSE_SLIDE	.\openb3d\src\collision.h	/^	COLLISION_RESPONSE_SLIDE=2,$/;"	e	enum:__anon3
COLLISION_RESPONSE_SLIDEXZ	.\openb3d\src\collision.h	/^	COLLISION_RESPONSE_SLIDEXZ=3,$/;"	e	enum:__anon3
COLLISION_RESPONSE_STOP	.\openb3d\src\collision.h	/^	COLLISION_RESPONSE_STOP=1,$/;"	e	enum:__anon3
COLLISION_class	.\data.cpp	/^const int COLLISION_class=		7; \/\/ collision.h$/;"	v
COMBO	.\openb3d\src\stb_image.c	875;"	d	file:
COMPUTE_INTERVALS	.\openb3d\src\collidetri.c	54;"	d	file:
CONSTRAINT_class	.\data.cpp	/^const int CONSTRAINT_class=		33; \/\/ physics.h$/;"	v
CROSS	.\openb3d\src\collidetri.c	27;"	d	file:
CSG	.\openb3d\src\csg.cpp	/^namespace CSG{$/;"	n	file:
CSG	.\openb3d\src\csg.h	/^namespace CSG{$/;"	n
CSG	.\openb3d\src\octree.cpp	/^namespace CSG{$/;"	n	file:
CSGTRIANGLE_class	.\data.cpp	/^const int CSGTRIANGLE_class=	11; \/\/ csg.h$/;"	v
CSGTriangle	.\openb3d\src\csg.h	/^class CSGTriangle{$/;"	c
CSGTriangle_list	.\openb3d\src\csg.cpp	/^list<CSGTriangle*> CSGTriangle::CSGTriangle_list;$/;"	m	class:CSGTriangle	file:
CSGTriangle_list	.\openb3d\src\csg.h	/^	static list<CSGTriangle*> CSGTriangle_list;$/;"	m	class:CSGTriangle
CSGTrisIntersect	.\openb3d\src\csg.cpp	/^bool CSGTrisIntersect(CSGTriangle* t1, CSGTriangle* t2){$/;"	f	namespace:CSG
CSG_H	.\openb3d\src\csg.h	2;"	d
C_AddSurface	.\openb3d\src\tree.cpp	/^void C_AddSurface(MeshInfo* mesh_info,int no_tris,int no_verts,short tris[],float verts[],int surface)$/;"	f
C_AddTriangle	.\openb3d\src\tree.cpp	/^void C_AddTriangle(MeshInfo* mesh_info, int index, short v0, short v1, short v2, int surface)$/;"	f
C_AddVertex	.\openb3d\src\tree.cpp	/^void C_AddVertex(MeshInfo* mesh_info, float x, float y, float z,int surface)$/;"	f
C_CollisionDetect	.\openb3d\src\collision.cpp	/^int C_CollisionDetect(CollisionInfo* ci,Collision* coll,Transform* dst_tform,MeshCollider* mesh_col,int method){$/;"	f
C_CollisionFinal	.\openb3d\src\collision.cpp	/^int C_CollisionFinal(CollisionInfo* ci)$/;"	f
C_CollisionNX	.\openb3d\src\collision.cpp	/^float C_CollisionNX()$/;"	f
C_CollisionNY	.\openb3d\src\collision.cpp	/^float C_CollisionNY()$/;"	f
C_CollisionNZ	.\openb3d\src\collision.cpp	/^float C_CollisionNZ()$/;"	f
C_CollisionPosX	.\openb3d\src\collision.cpp	/^float C_CollisionPosX()$/;"	f
C_CollisionPosY	.\openb3d\src\collision.cpp	/^float C_CollisionPosY()$/;"	f
C_CollisionPosZ	.\openb3d\src\collision.cpp	/^float C_CollisionPosZ()$/;"	f
C_CollisionResponse	.\openb3d\src\collision.cpp	/^int C_CollisionResponse(CollisionInfo* ci,Collision* coll,int response){$/;"	f
C_CollisionSurface	.\openb3d\src\collision.cpp	/^int C_CollisionSurface()$/;"	f
C_CollisionTime	.\openb3d\src\collision.cpp	/^float C_CollisionTime()$/;"	f
C_CollisionTriangle	.\openb3d\src\collision.cpp	/^int C_CollisionTriangle()$/;"	f
C_CollisionX	.\openb3d\src\collision.cpp	/^float C_CollisionX()$/;"	f
C_CollisionY	.\openb3d\src\collision.cpp	/^float C_CollisionY()$/;"	f
C_CollisionZ	.\openb3d\src\collision.cpp	/^float C_CollisionZ()$/;"	f
C_CreateColTree	.\openb3d\src\tree.cpp	/^MeshCollider* C_CreateColTree(MeshInfo* mesh_info)$/;"	f
C_CreateCollisionInfoObject	.\openb3d\src\collision.cpp	/^CollisionInfo* C_CreateCollisionInfoObject(Vector* dv,Vector* sv,Vector* radii)$/;"	f
C_CreateCollisionObject	.\openb3d\src\collision.cpp	/^Collision* C_CreateCollisionObject()$/;"	f
C_CreateLineObject	.\openb3d\src\collision.cpp	/^Line* C_CreateLineObject(float ox,float oy,float oz,float dx,float dy,float dz)$/;"	f
C_CreateMatrixObject	.\openb3d\src\collision.cpp	/^MMatrix* C_CreateMatrixObject(Vector* vec_i,Vector* vec_j,Vector* vec_k)$/;"	f
C_CreateTFormObject	.\openb3d\src\collision.cpp	/^Transform* C_CreateTFormObject(MMatrix* mat,Vector* vec_v)$/;"	f
C_CreateVecObject	.\openb3d\src\collision.cpp	/^Vector* C_CreateVecObject(float x,float y,float z)$/;"	f
C_DeleteColTree	.\openb3d\src\tree.cpp	/^void C_DeleteColTree(MeshCollider* mesh_col)$/;"	f
C_DeleteCollisionInfoObject	.\openb3d\src\collision.cpp	/^void C_DeleteCollisionInfoObject(CollisionInfo* ci)$/;"	f
C_DeleteCollisionObject	.\openb3d\src\collision.cpp	/^void C_DeleteCollisionObject(Collision* col)$/;"	f
C_DeleteLineObject	.\openb3d\src\collision.cpp	/^void C_DeleteLineObject(Line* line)$/;"	f
C_DeleteMatrixObject	.\openb3d\src\collision.cpp	/^void C_DeleteMatrixObject(MMatrix* mat)$/;"	f
C_DeleteMeshInfo	.\openb3d\src\tree.cpp	/^void C_DeleteMeshInfo(MeshInfo* mesh_info)$/;"	f
C_DeleteTFormObject	.\openb3d\src\collision.cpp	/^void C_DeleteTFormObject(Transform* tform)$/;"	f
C_DeleteVecObject	.\openb3d\src\collision.cpp	/^void C_DeleteVecObject(Vector* vec)$/;"	f
C_NewMeshInfo	.\openb3d\src\tree.cpp	/^MeshInfo* C_NewMeshInfo()$/;"	f
C_Pick	.\openb3d\src\collision.cpp	/^int C_Pick(CollisionInfo* ci,const Line* line,float radius,Collision* coll,Transform* dst_tform,MeshCollider* mesh_col,int pick_geom){$/;"	f
C_UpdateCollisionInfoObject	.\openb3d\src\collision.cpp	/^void C_UpdateCollisionInfoObject(CollisionInfo* ci,float dst_radius,float ax,float ay,float az,float bx,float by,float bz)$/;"	f
C_UpdateCollisionInfoObject2	.\openb3d\src\collision.cpp	/^void C_UpdateCollisionInfoObject2(CollisionInfo* ci,Vector* dv,Vector* sv,Vector* radii)$/;"	f
C_UpdateLineObject	.\openb3d\src\collision.cpp	/^void C_UpdateLineObject(Line* line,float ox,float oy,float oz,float dx,float dy,float dz)$/;"	f
C_UpdateMatrixObject	.\openb3d\src\collision.cpp	/^void C_UpdateMatrixObject(MMatrix* mat,Vector* vec_i,Vector* vec_j,Vector* vec_k)$/;"	f
C_UpdateTFormObject	.\openb3d\src\collision.cpp	/^void C_UpdateTFormObject(Transform* tform,MMatrix* mat,Vector* vec_v)$/;"	f
C_UpdateVecObject	.\openb3d\src\collision.cpp	/^void C_UpdateVecObject(Vector* vec,float x,float y,float z)$/;"	f
C_VecX	.\openb3d\src\collision.cpp	/^float C_VecX(Vector* vec)$/;"	f
C_VecY	.\openb3d\src\collision.cpp	/^float C_VecY(Vector* vec)$/;"	f
C_VecZ	.\openb3d\src\collision.cpp	/^float C_VecZ(Vector* vec)$/;"	f
Camera	.\openb3d\src\camera.h	/^	Camera(){$/;"	f	class:Camera
Camera	.\openb3d\src\camera.h	/^class Camera : public Entity{$/;"	c
CameraBool	.\data.cpp	/^bool* CameraBool( Camera* obj,int varid ){$/;"	f
CameraClsColor	.\openb3d\src\camera.cpp	/^void Camera::CameraClsColor(float r,float g,float b){$/;"	f	class:Camera
CameraClsColor	.\openb3d\src\functions.cpp	/^void CameraClsColor(Camera* cam, float r,float g,float b){$/;"	f
CameraClsMode	.\openb3d\src\camera.cpp	/^void Camera::CameraClsMode(int color,int zbuffer){$/;"	f	class:Camera
CameraClsMode	.\openb3d\src\functions.cpp	/^void CameraClsMode(Camera* cam,int cls_depth,int cls_zbuffer){$/;"	f
CameraFloat	.\data.cpp	/^float* CameraFloat( Camera* obj,int varid ){$/;"	f
CameraFogColor	.\openb3d\src\camera.cpp	/^void Camera::CameraFogColor(float r,float g,float b){$/;"	f	class:Camera
CameraFogColor	.\openb3d\src\functions.cpp	/^void CameraFogColor(Camera* cam,float r,float g,float b){$/;"	f
CameraFogMode	.\openb3d\src\camera.cpp	/^void Camera::CameraFogMode(int mode){$/;"	f	class:Camera
CameraFogMode	.\openb3d\src\functions.cpp	/^void CameraFogMode(Camera* cam,int mode){$/;"	f
CameraFogRange	.\openb3d\src\camera.cpp	/^void Camera::CameraFogRange(float Near,float Far){$/;"	f	class:Camera
CameraFogRange	.\openb3d\src\functions.cpp	/^void CameraFogRange(Camera* cam,float nnear,float nfar){$/;"	f
CameraInt	.\data.cpp	/^int* CameraInt( Camera* obj,int varid ){$/;"	f
CameraPick	.\openb3d\src\functions.cpp	/^Entity* CameraPick(Camera* cam,float x,float y){$/;"	f
CameraPick	.\openb3d\src\pick.cpp	/^Entity* Pick::CameraPick(Camera* cam,float vx,float vy){$/;"	f	class:Pick
CameraProjMode	.\openb3d\src\camera.cpp	/^void Camera::CameraProjMode(int mode){$/;"	f	class:Camera
CameraProjMode	.\openb3d\src\functions.cpp	/^void  CameraProjMode(Camera* cam,int mode){$/;"	f
CameraProject	.\openb3d\src\camera.cpp	/^void Camera::CameraProject(float x,float y,float z){$/;"	f	class:Camera
CameraProject	.\openb3d\src\functions.cpp	/^void CameraProject(Camera* cam,float x,float y,float z){$/;"	f
CameraRange	.\openb3d\src\camera.cpp	/^void Camera::CameraRange(float Near,float Far){$/;"	f	class:Camera
CameraRange	.\openb3d\src\functions.cpp	/^void  CameraRange(Camera* cam,float nnear,float nfar){$/;"	f
CameraRender	.\methods.cpp	/^void CameraRender( Camera* obj ){$/;"	f
CameraToTex	.\openb3d\src\functions.cpp	/^void CameraToTex(Texture* tex, Camera* cam, int frame){$/;"	f
CameraToTex	.\openb3d\src\texture.cpp	/^void Texture::CameraToTex(Camera* cam, int frame){$/;"	f	class:Texture
CameraUpdate	.\methods.cpp	/^void CameraUpdate( Camera* obj ){$/;"	f
CameraUpdateEntityRender	.\methods.cpp	/^void CameraUpdateEntityRender( Entity* ent,Entity* cam ){$/;"	f
CameraViewport	.\openb3d\src\camera.cpp	/^void Camera::CameraViewport(int x,int y,int w,int h){$/;"	f	class:Camera
CameraViewport	.\openb3d\src\functions.cpp	/^void  CameraViewport(Camera* cam,int x,int y,int width,int height){$/;"	f
CameraZoom	.\openb3d\src\camera.cpp	/^void Camera::CameraZoom(float zoom_val){$/;"	f	class:Camera
CameraZoom	.\openb3d\src\functions.cpp	/^void  CameraZoom(Camera* cam,float zoom){$/;"	f
Chr	.\openb3d\src\string_helper.cpp	/^string Chr(int asc){$/;"	f
ChunkID	.\openb3d\src\3ds.cpp	/^unsigned short ChunkID;$/;"	m	namespace:load3ds	file:
ChunkSize	.\openb3d\src\3ds.cpp	/^int            ChunkSize;$/;"	m	namespace:load3ds	file:
Clear	.\openb3d\src\sprite_batch.h	/^	static void Clear(){$/;"	f	class:SpriteBatch
ClearCollisions	.\openb3d\src\functions.cpp	/^void ClearCollisions(){$/;"	f
ClearCollisions	.\openb3d\src\global.cpp	/^void Global::ClearCollisions(){$/;"	f	class:Global
ClearSurface	.\openb3d\src\functions.cpp	/^void ClearSurface(Surface* surf,bool clear_verts,bool clear_tris){$/;"	f
ClearSurface	.\openb3d\src\surface.cpp	/^void Surface::ClearSurface(int clear_verts,int clear_tris){$/;"	f	class:Surface
ClearTextureFilters	.\openb3d\src\functions.cpp	/^void ClearTextureFilters(){$/;"	f
ClearTextureFilters	.\openb3d\src\texture.cpp	/^void Texture::ClearTextureFilters(){$/;"	f	class:Texture
ClearTouches	.\openb3d\src\touch.h	/^	static void ClearTouches(){$/;"	f	class:Touch
ClearWorld	.\openb3d\src\functions.cpp	/^void ClearWorld(bool entities,bool brushes,bool textures){$/;"	f
ClearWorld	.\openb3d\src\global.cpp	/^void Global::ClearWorld(int entities,int brushes,int textures){$/;"	f	class:Global
CloseFile	.\openb3d\src\file.cpp	/^void File::CloseFile(){$/;"	f	class:File
Coll_Child	.\openb3d\src\octree.cpp	/^void OcTreeChild::Coll_Child(){$/;"	f	class:OcTreeChild
CollapseAnimMesh	.\methods.cpp	/^Mesh* CollapseAnimMesh( Mesh* obj,Mesh* mesh ){$/;"	f
CollapseAnimMesh	.\openb3d\src\mesh.cpp	/^Mesh* Mesh::CollapseAnimMesh(Mesh* mesh){$/;"	f	class:Mesh
CollapseChildren	.\methods.cpp	/^Mesh* CollapseChildren( Mesh* obj,Entity* ent0,Mesh* mesh ){$/;"	f
CollapseChildren	.\openb3d\src\mesh.cpp	/^Mesh* Mesh::CollapseChildren(Entity* ent0,Mesh* mesh){$/;"	f	class:Mesh
Collision	.\openb3d\src\collision.h	/^	Collision():time(1){$/;"	f	struct:Collision
Collision	.\openb3d\src\collision.h	/^struct Collision{$/;"	s
CollisionEntity	.\openb3d\src\entity.cpp	/^Entity* Entity::CollisionEntity(int index){$/;"	f	class:Entity
CollisionEntity	.\openb3d\src\functions.cpp	/^Entity* CollisionEntity(Entity* ent,int index){$/;"	f
CollisionImpact	.\openb3d\src\collision2.h	/^	CollisionImpact(){$/;"	f	class:CollisionImpact
CollisionImpact	.\openb3d\src\collision2.h	/^class CollisionImpact{$/;"	c
CollisionInfo	.\openb3d\src\collision.h	/^struct CollisionInfo{$/;"	s
CollisionNX	.\openb3d\src\entity.cpp	/^float Entity::CollisionNX(int index){$/;"	f	class:Entity
CollisionNX	.\openb3d\src\functions.cpp	/^float CollisionNX(Entity* ent,int index){$/;"	f
CollisionNY	.\openb3d\src\entity.cpp	/^float Entity::CollisionNY(int index){$/;"	f	class:Entity
CollisionNY	.\openb3d\src\functions.cpp	/^float CollisionNY(Entity* ent,int index){$/;"	f
CollisionNZ	.\openb3d\src\entity.cpp	/^float Entity::CollisionNZ(int index){$/;"	f	class:Entity
CollisionNZ	.\openb3d\src\functions.cpp	/^float CollisionNZ(Entity* ent,int index){$/;"	f
CollisionPair	.\openb3d\src\collision2.h	/^	CollisionPair(){$/;"	f	class:CollisionPair
CollisionPair	.\openb3d\src\collision2.h	/^class CollisionPair{$/;"	c
CollisionSurface	.\openb3d\src\entity.cpp	/^Surface* Entity::CollisionSurface(int index){$/;"	f	class:Entity
CollisionSurface	.\openb3d\src\functions.cpp	/^Surface* CollisionSurface(Entity* ent,int index){$/;"	f
CollisionTime	.\openb3d\src\entity.cpp	/^float Entity::CollisionTime(int index){$/;"	f	class:Entity
CollisionTime	.\openb3d\src\functions.cpp	/^float CollisionTime(Entity* ent,int index){$/;"	f
CollisionTriangle	.\openb3d\src\entity.cpp	/^int Entity::CollisionTriangle(int index){$/;"	f	class:Entity
CollisionTriangle	.\openb3d\src\functions.cpp	/^int CollisionTriangle(Entity* ent,int index){$/;"	f
CollisionX	.\openb3d\src\entity.cpp	/^float Entity::CollisionX(int index){$/;"	f	class:Entity
CollisionX	.\openb3d\src\functions.cpp	/^float CollisionX(Entity* ent,int index){$/;"	f
CollisionY	.\openb3d\src\entity.cpp	/^float Entity::CollisionY(int index){$/;"	f	class:Entity
CollisionY	.\openb3d\src\functions.cpp	/^float CollisionY(Entity* ent,int index){$/;"	f
CollisionZ	.\openb3d\src\entity.cpp	/^float Entity::CollisionZ(int index){$/;"	f	class:Entity
CollisionZ	.\openb3d\src\functions.cpp	/^float CollisionZ(Entity* ent,int index){$/;"	f
Collisions	.\openb3d\src\functions.cpp	/^void Collisions(int src_no,int dest_no,int method_no,int response_no){$/;"	f
Collisions	.\openb3d\src\global.cpp	/^void Global::Collisions(int src_no,int dest_no,int method_no,int response_no){$/;"	f	class:Global
CompareBrushes	.\methods.cpp	/^int CompareBrushes( Brush* brush1,Brush* brush2 ){$/;"	f
CompareBrushes	.\openb3d\src\brush.cpp	/^int Brush::CompareBrushes(Brush* brush1,Brush* brush2){$/;"	f	class:Brush
CompareEntityOrder	.\openb3d\src\global.cpp	/^bool CompareEntityOrder(Entity* ent1,Entity* ent2){$/;"	f
Constraint	.\openb3d\src\physics.h	/^class Constraint{$/;"	c
Copy	.\openb3d\src\animation_keys.h	/^	AnimationKeys* Copy(){$/;"	f	class:AnimationKeys
Copy	.\openb3d\src\brush.cpp	/^Brush* Brush::Copy(){$/;"	f	class:Brush
Copy	.\openb3d\src\matrix.h	/^	Matrix* Copy(){$/;"	f	class:Matrix
Copy	.\openb3d\src\shadow.h	/^	Edge* Copy(){$/;"	f	class:Edge
Copy	.\openb3d\src\surface.cpp	/^Surface* Surface::Copy(){$/;"	f	class:Surface
Copy	.\openb3d\src\texture.cpp	/^Texture* Texture::Copy(){$/;"	f	class:Texture
CopyBank	.\openb3d\src\bank.h	/^	static void CopyBank(Bank* src_bank,int src_offset,Bank* des_bank,int des_offset,int count){$/;"	f	class:Bank
CopyBonesList	.\methods.cpp	/^void CopyBonesList( Entity* ent,vector<Bone*>& bones ){$/;"	f
CopyBonesList	.\openb3d\src\mesh.cpp	/^void Mesh::CopyBonesList(Entity* ent,vector<Bone*>& bones){$/;"	f	class:Mesh
CopyChild	.\openb3d\src\octree.cpp	/^OcTreeChild* OcTreeChild::CopyChild(){$/;"	f	class:OcTreeChild
CopyEntity	.\openb3d\src\bone.cpp	/^Bone* Bone::CopyEntity(Entity* parent_ent){$/;"	f	class:Bone
CopyEntity	.\openb3d\src\camera.cpp	/^Camera* Camera::CopyEntity(Entity* parent_ent){$/;"	f	class:Camera
CopyEntity	.\openb3d\src\functions.cpp	/^Entity* CopyEntity(Entity* ent,Entity* parent){$/;"	f
CopyEntity	.\openb3d\src\geosphere.cpp	/^Geosphere* Geosphere::CopyEntity(Entity* parent_ent){$/;"	f	class:Geosphere
CopyEntity	.\openb3d\src\isosurface.cpp	/^Blob* Blob::CopyEntity(Entity* parent_ent){$/;"	f	class:Blob
CopyEntity	.\openb3d\src\isosurface.cpp	/^FieldArray* FieldArray::CopyEntity(Entity* parent_ent){ return 0;}$/;"	f	class:FieldArray
CopyEntity	.\openb3d\src\light.cpp	/^Light* Light::CopyEntity(Entity* parent_ent){$/;"	f	class:Light
CopyEntity	.\openb3d\src\mesh.cpp	/^Mesh* Mesh::CopyEntity(Entity* parent_ent){$/;"	f	class:Mesh
CopyEntity	.\openb3d\src\octree.cpp	/^OcTree* OcTree::CopyEntity(Entity* parent_ent){$/;"	f	class:OcTree
CopyEntity	.\openb3d\src\particle.cpp	/^ParticleEmitter* ParticleEmitter::CopyEntity(Entity* parent_ent){$/;"	f	class:ParticleEmitter
CopyEntity	.\openb3d\src\pivot.cpp	/^Pivot* Pivot::CopyEntity(Entity* parent_ent){$/;"	f	class:Pivot
CopyEntity	.\openb3d\src\sprite.cpp	/^Sprite* Sprite::CopyEntity(Entity* parent_ent){$/;"	f	class:Sprite
CopyEntity	.\openb3d\src\terrain.cpp	/^Terrain* Terrain::CopyEntity(Entity* parent_ent){$/;"	f	class:Terrain
CopyMesh	.\openb3d\src\functions.cpp	/^Mesh* CopyMesh(Mesh* mesh,Entity* parent){$/;"	f
CopyMesh	.\openb3d\src\mesh.cpp	/^Mesh* Mesh::CopyMesh(Entity* parent_ent){$/;"	f	class:Mesh
CopyMeshAt	.\openb3d\src\csg.cpp	/^Mesh* CopyMeshAt(Mesh* mesh){$/;"	f	namespace:CSG
CopyPixels	.\openb3d\src\texture.cpp	/^void CopyPixels (unsigned char *src, unsigned int srcWidth, unsigned int srcHeight, unsigned int srcX, unsigned int srcY, unsigned char *dst, unsigned int dstWidth, unsigned int dstHeight, unsigned int bytesPerPixel) {$/;"	f
CountAllChildren	.\methods.cpp	/^int CountAllChildren( Entity* obj,int no_children ){$/;"	f
CountAllChildren	.\openb3d\src\entity.cpp	/^int Entity::CountAllChildren(int no_children){$/;"	f	class:Entity
CountAllTouches	.\openb3d\src\touch.h	/^	static int CountAllTouches(){ \/\/ includes dead touches$/;"	f	class:Touch
CountChildren	.\openb3d\src\entity.cpp	/^int Entity::CountChildren(){$/;"	f	class:Entity
CountChildren	.\openb3d\src\functions.cpp	/^int CountChildren(Entity* ent){$/;"	f
CountCollisions	.\openb3d\src\entity.cpp	/^int Entity::CountCollisions(){$/;"	f	class:Entity
CountCollisions	.\openb3d\src\functions.cpp	/^int CountCollisions(Entity* ent){$/;"	f
CountSurfaces	.\openb3d\src\functions.cpp	/^int CountSurfaces(Mesh* mesh){$/;"	f
CountSurfaces	.\openb3d\src\mesh.cpp	/^int Mesh::CountSurfaces(){$/;"	f	class:Mesh
CountTouches	.\openb3d\src\touch.h	/^	static int CountTouches(){$/;"	f	class:Touch
CountTriangles	.\openb3d\src\functions.cpp	/^int CountTriangles(Surface* surf){$/;"	f
CountTriangles	.\openb3d\src\surface.cpp	/^int Surface::CountTriangles(){$/;"	f	class:Surface
CountVertices	.\openb3d\src\functions.cpp	/^int CountVertices(Surface* surf){$/;"	f
CountVertices	.\openb3d\src\surface.cpp	/^int Surface::CountVertices(){$/;"	f	class:Surface
Create	.\openb3d\src\material.cpp	/^ProgramObject* ProgramObject::Create(string name){$/;"	f	class:ProgramObject
Create	.\openb3d\src\material.cpp	/^Sampler* Sampler::Create(string Name, int Slot, Texture* Tex){$/;"	f	class:Sampler
Create	.\openb3d\src\shadow.cpp	/^ShadowObject* ShadowObject::Create(Mesh* Parent, char Static){$/;"	f	class:ShadowObject
CreateBank	.\openb3d\src\bank.h	/^	static Bank* CreateBank(int size){$/;"	f	class:Bank
CreateBlob	.\openb3d\src\functions.cpp	/^Blob* CreateBlob(Fluid* fluid, float radius, Entity* parent_ent){$/;"	f
CreateBlob	.\openb3d\src\isosurface.cpp	/^Blob* Blob::CreateBlob(Fluid* fluid, float radius, Entity* parent_ent){$/;"	f	class:Blob
CreateBone	.\openb3d\src\functions.cpp	/^Bone* CreateBone(Mesh* mesh, Entity* parent_ent){$/;"	f
CreateBone	.\openb3d\src\mesh.cpp	/^Bone* Mesh::CreateBone(Entity* parent_ent){$/;"	f	class:Mesh
CreateBrush	.\openb3d\src\brush.cpp	/^Brush* Brush::CreateBrush(float r,float g,float b){$/;"	f	class:Brush
CreateBrush	.\openb3d\src\functions.cpp	/^Brush* CreateBrush(float r,float g,float b){$/;"	f
CreateCamera	.\openb3d\src\camera.cpp	/^Camera* Camera::CreateCamera(Entity* parent_ent){$/;"	f	class:Camera
CreateCamera	.\openb3d\src\functions.cpp	/^Camera* CreateCamera(Entity* parent){$/;"	f
CreateCone	.\openb3d\src\functions.cpp	/^Mesh* CreateCone(int segments,bool solid,Entity* parent){$/;"	f
CreateCone	.\openb3d\src\mesh.cpp	/^Mesh* Mesh::CreateCone(int segments,int solid,Entity* parent_ent){$/;"	f	class:Mesh
CreateConstraint	.\openb3d\src\functions.cpp	/^Constraint* CreateConstraint(Entity* p1, Entity* p2, float l){$/;"	f
CreateConstraint	.\openb3d\src\physics.cpp	/^Constraint* Constraint::CreateConstraint(Entity* p1, Entity* p2, float l){$/;"	f	class:Constraint
CreateCube	.\openb3d\src\functions.cpp	/^Mesh* CreateCube(Entity* parent){$/;"	f
CreateCube	.\openb3d\src\mesh.cpp	/^Mesh* Mesh::CreateCube(Entity* parent_ent){$/;"	f	class:Mesh
CreateCylinder	.\openb3d\src\functions.cpp	/^Mesh* CreateCylinder(int segments,bool solid,Entity* parent){$/;"	f
CreateCylinder	.\openb3d\src\mesh.cpp	/^Mesh* Mesh::CreateCylinder(int verticalsegments,int solid,Entity* parent_ent){$/;"	f	class:Mesh
CreateFluid	.\openb3d\src\functions.cpp	/^Fluid* CreateFluid(){$/;"	f
CreateFluid	.\openb3d\src\isosurface.cpp	/^Fluid* Fluid::CreateFluid(){$/;"	f	class:Fluid
CreateFragShader	.\openb3d\src\material.cpp	/^ShaderObject* ShaderObject::CreateFragShader(string shaderFileName){$/;"	f	class:ShaderObject
CreateFragShaderFromString	.\openb3d\src\material.cpp	/^ShaderObject* ShaderObject::CreateFragShaderFromString(string shadercode){$/;"	f	class:ShaderObject
CreateGeosphere	.\openb3d\src\functions.cpp	/^Terrain* CreateGeosphere(int size, Entity* parent){$/;"	f
CreateGeosphere	.\openb3d\src\geosphere.cpp	/^Geosphere* Geosphere::CreateGeosphere(int tsize, Entity* parent_ent){$/;"	f	class:Geosphere
CreateLight	.\openb3d\src\functions.cpp	/^Light* CreateLight(int light_type,Entity* parent){$/;"	f
CreateLight	.\openb3d\src\light.cpp	/^Light* Light::CreateLight(int l_type,Entity* parent_ent){$/;"	f	class:Light
CreateMesh	.\openb3d\src\functions.cpp	/^Mesh* CreateMesh(Entity* parent){$/;"	f
CreateMesh	.\openb3d\src\mesh.cpp	/^Mesh* Mesh::CreateMesh(Entity* parent_ent){$/;"	f	class:Mesh
CreateOcTree	.\openb3d\src\functions.cpp	/^OcTree* CreateOcTree(float w, float h, float d, Entity* parent_ent=0){$/;"	f
CreateOcTree	.\openb3d\src\octree.cpp	/^OcTree* OcTree::CreateOcTree(float w, float h, float d, Entity* parent_ent){$/;"	f	class:OcTree
CreateParticleEmitter	.\openb3d\src\functions.cpp	/^ParticleEmitter* CreateParticleEmitter(Entity* particle, Entity* parent_ent=0){$/;"	f
CreateParticleEmitter	.\openb3d\src\particle.cpp	/^ParticleEmitter* ParticleEmitter::CreateParticleEmitter(Entity* particle, Entity* parent_ent){$/;"	f	class:ParticleEmitter
CreatePivot	.\openb3d\src\functions.cpp	/^Pivot* CreatePivot(Entity* parent){$/;"	f
CreatePivot	.\openb3d\src\pivot.cpp	/^Pivot* Pivot::CreatePivot(Entity* parent_ent){$/;"	f	class:Pivot
CreatePlane	.\openb3d\src\functions.cpp	/^Mesh* CreatePlane(int divisions,Entity* parent){$/;"	f
CreatePlane	.\openb3d\src\mesh.cpp	/^Mesh* Mesh::CreatePlane(int divs, Entity* parent_ent){$/;"	f	class:Mesh
CreateQuad	.\openb3d\src\functions.cpp	/^Mesh* CreateQuad(Entity* parent){$/;"	f
CreateQuad	.\openb3d\src\mesh.cpp	/^Mesh* Mesh::CreateQuad(Entity* parent_ent){$/;"	f	class:Mesh
CreateRigidBody	.\openb3d\src\functions.cpp	/^RigidBody* CreateRigidBody(Entity* body, Entity* p1, Entity* p2, Entity* p3, Entity* p4){$/;"	f
CreateRigidBody	.\openb3d\src\physics.cpp	/^RigidBody* RigidBody::CreateRigidBody(Entity* body, Entity* p1, Entity* p2, Entity* p3, Entity* p4){$/;"	f	class:RigidBody
CreateShader	.\openb3d\src\functions.cpp	/^Shader* CreateShader(char* ShaderName, char* VshaderString, char* FshaderString){$/;"	f
CreateShaderMaterial	.\openb3d\src\material.cpp	/^Shader* Shader::CreateShaderMaterial(string Name){$/;"	f	class:Shader
CreateShadow	.\openb3d\src\functions.cpp	/^ShadowObject* CreateShadow(Mesh* parent, char Static){$/;"	f
CreateSphere	.\openb3d\src\functions.cpp	/^Mesh* CreateSphere(int segments,Entity* parent){$/;"	f
CreateSphere	.\openb3d\src\mesh.cpp	/^Mesh* Mesh::CreateSphere(int segments,Entity* parent_ent){$/;"	f	class:Mesh
CreateSprite	.\openb3d\src\functions.cpp	/^Sprite* CreateSprite(Entity* parent){$/;"	f
CreateSprite	.\openb3d\src\sprite.cpp	/^Sprite* Sprite::CreateSprite(Entity* parent_ent){$/;"	f	class:Sprite
CreateStencil	.\openb3d\src\functions.cpp	/^Stencil* CreateStencil(){$/;"	f
CreateStencil	.\openb3d\src\stencil.cpp	/^Stencil* Stencil::CreateStencil(){$/;"	f	class:Stencil
CreateSurface	.\openb3d\src\functions.cpp	/^Surface* CreateSurface(Mesh* mesh,Brush* brush){$/;"	f
CreateSurface	.\openb3d\src\mesh.cpp	/^Surface* Mesh::CreateSurface(Brush* bru){$/;"	f	class:Mesh
CreateTerrain	.\openb3d\src\functions.cpp	/^Terrain* CreateTerrain(int size, Entity* parent){$/;"	f
CreateTerrain	.\openb3d\src\terrain.cpp	/^Terrain* Terrain::CreateTerrain(int tsize, Entity* parent_ent){$/;"	f	class:Terrain
CreateTexture	.\openb3d\src\functions.cpp	/^Texture* CreateTexture(int width,int height,int flags,int frames){$/;"	f
CreateTexture	.\openb3d\src\texture.cpp	/^Texture* Texture::CreateTexture(int width,int height,int flags, int frames){$/;"	f	class:Texture
CreateVertShader	.\openb3d\src\material.cpp	/^ShaderObject* ShaderObject::CreateVertShader(string shaderFileName){$/;"	f	class:ShaderObject
CreateVertShaderFromString	.\openb3d\src\material.cpp	/^ShaderObject* ShaderObject::CreateVertShaderFromString(string shadercode){$/;"	f	class:ShaderObject
CreateVoxelSprite	.\openb3d\src\functions.cpp	/^VoxelSprite* CreateVoxelSprite(int slices, Entity* parent){$/;"	f
CreateVoxelSprite	.\openb3d\src\voxel.cpp	/^VoxelSprite* VoxelSprite::CreateVoxelSprite(int slices, Entity* parent_ent){$/;"	f	class:VoxelSprite
CreateVoxelTerrain	.\openb3d\src\voxterrain.cpp	/^VoxelTerrain* VoxelTerrain::CreateVoxelTerrain(int xsize, int ysize, int zsize, Entity* parent_ent){$/;"	f	class:VoxelTerrain
DEG_CIRCLE	.\openb3d\src\maths_helper.h	21;"	d
DEG_TO_RAD	.\openb3d\src\maths_helper.h	22;"	d
DLL_EXPORT	.\openb3d\src\functions.h	12;"	d
DLL_EXPORT	.\openb3d\src\functions.h	7;"	d
DLL_EXPORT	.\openb3d\src\functions.h	9;"	d
DNL	.\openb3d\src\stb_image.c	1617;"	d	file:
DOT	.\openb3d\src\collidetri.c	32;"	d	file:
DeActivate	.\openb3d\src\material.cpp	/^void ProgramObject::DeActivate(){$/;"	f	class:ProgramObject
DeActivate	.\openb3d\src\material.h	/^	void DeActivate(){$/;"	f	class:MaterialPlugin
DeleteFragShader	.\openb3d\src\material.cpp	/^void ShaderObject::DeleteFragShader(ShaderObject* fShader){$/;"	f	class:ShaderObject
DeleteVertShader	.\openb3d\src\material.cpp	/^void ShaderObject::DeleteVertShader(ShaderObject* vShader){$/;"	f	class:ShaderObject
DeltaPitch	.\openb3d\src\entity.cpp	/^float Entity::DeltaPitch(Entity* ent2){$/;"	f	class:Entity
DeltaPitch	.\openb3d\src\functions.cpp	/^float DeltaPitch(Entity* ent1,Entity* ent2){$/;"	f
DeltaYaw	.\openb3d\src\entity.cpp	/^float Entity::DeltaYaw(Entity* ent2){$/;"	f	class:Entity
DeltaYaw	.\openb3d\src\functions.cpp	/^float DeltaYaw(Entity* ent1,Entity* ent2){$/;"	f
DepthBufferToTex	.\openb3d\src\functions.cpp	/^void DepthBufferToTex( Texture* tex, Camera* cam=0 ){$/;"	f
DepthBufferToTex	.\openb3d\src\texture.cpp	/^void Texture::DepthBufferToTex(Camera* cam=0 ){$/;"	f	class:Texture
DetachFragShader	.\openb3d\src\material.cpp	/^void ProgramObject::DetachFragShader(ShaderObject* fShader){$/;"	f	class:ProgramObject
DetachVertShader	.\openb3d\src\material.cpp	/^void ProgramObject::DetachVertShader(ShaderObject* vShader){$/;"	f	class:ProgramObject
DrawTexture	.\openb3d\src\texture.cpp	/^void Texture::DrawTexture(int x,int y){$/;"	f	class:Texture
EDGE_AGAINST_TRI_EDGES	.\openb3d\src\collidetri.c	110;"	d	file:
EDGE_EDGE_TEST	.\openb3d\src\collidetri.c	90;"	d	file:
EDGE_class	.\data.cpp	/^const int EDGE_class=			45;$/;"	v
ENTITY_H	.\openb3d\src\entity.h	11;"	d
ENTITY_alpha_order	.\data.cpp	/^const int ENTITY_alpha_order=		21;$/;"	v
ENTITY_anim	.\data.cpp	/^const int ENTITY_anim=				27; \/\/ true if mesh contains anim data$/;"	v
ENTITY_anim_dir	.\data.cpp	/^const int ENTITY_anim_dir=			34; \/\/ 1=forward, -1=backward$/;"	v
ENTITY_anim_list	.\data.cpp	/^const int ENTITY_anim_list=			39;$/;"	v
ENTITY_anim_mode	.\data.cpp	/^const int ENTITY_anim_mode=			29;$/;"	v
ENTITY_anim_render	.\data.cpp	/^const int ENTITY_anim_render=		28; \/\/ true to render as anim mesh$/;"	v
ENTITY_anim_seq	.\data.cpp	/^const int ENTITY_anim_seq=			32;$/;"	v
ENTITY_anim_seqs_first	.\data.cpp	/^const int ENTITY_anim_seqs_first=	35;$/;"	v
ENTITY_anim_seqs_last	.\data.cpp	/^const int ENTITY_anim_seqs_last=	36;$/;"	v
ENTITY_anim_speed	.\data.cpp	/^const int ENTITY_anim_speed=		31;$/;"	v
ENTITY_anim_time	.\data.cpp	/^const int ENTITY_anim_time=			30;$/;"	v
ENTITY_anim_trans	.\data.cpp	/^const int ENTITY_anim_trans=		33;$/;"	v
ENTITY_anim_update	.\data.cpp	/^const int ENTITY_anim_update=		38;$/;"	v
ENTITY_animate_list	.\data.cpp	/^const int ENTITY_animate_list=		26;$/;"	v
ENTITY_box_d	.\data.cpp	/^const int ENTITY_box_d=				48;$/;"	v
ENTITY_box_h	.\data.cpp	/^const int ENTITY_box_h=				47;$/;"	v
ENTITY_box_w	.\data.cpp	/^const int ENTITY_box_w=				46;$/;"	v
ENTITY_box_x	.\data.cpp	/^const int ENTITY_box_x=				43;$/;"	v
ENTITY_box_y	.\data.cpp	/^const int ENTITY_box_y=				44;$/;"	v
ENTITY_box_z	.\data.cpp	/^const int ENTITY_box_z=				45;$/;"	v
ENTITY_brush	.\data.cpp	/^const int ENTITY_brush=				19;$/;"	v
ENTITY_child_list	.\data.cpp	/^const int ENTITY_child_list=		2;$/;"	v
ENTITY_class	.\data.cpp	/^const int ENTITY_class=			12;$/;"	v
ENTITY_class_name	.\data.cpp	/^const int ENTITY_class_name=		25;$/;"	v
ENTITY_collision	.\data.cpp	/^const int ENTITY_collision=			50;$/;"	v
ENTITY_collision_type	.\data.cpp	/^const int ENTITY_collision_type=	40;$/;"	v
ENTITY_cull_radius	.\data.cpp	/^const int ENTITY_cull_radius=		23;$/;"	v
ENTITY_dynamic	.\data.cpp	/^const int ENTITY_dynamic=			62;$/;"	v
ENTITY_dynamic_pitch	.\data.cpp	/^const int ENTITY_dynamic_pitch=		67;$/;"	v
ENTITY_dynamic_roll	.\data.cpp	/^const int ENTITY_dynamic_roll=		68;$/;"	v
ENTITY_dynamic_x	.\data.cpp	/^const int ENTITY_dynamic_x=			63;$/;"	v
ENTITY_dynamic_y	.\data.cpp	/^const int ENTITY_dynamic_y=			64;$/;"	v
ENTITY_dynamic_yaw	.\data.cpp	/^const int ENTITY_dynamic_yaw=		66;$/;"	v
ENTITY_dynamic_z	.\data.cpp	/^const int ENTITY_dynamic_z=			65;$/;"	v
ENTITY_entity_list	.\data.cpp	/^const int ENTITY_entity_list=		1;$/;"	v
ENTITY_hide	.\data.cpp	/^const int ENTITY_hide=				22;$/;"	v
ENTITY_mat	.\data.cpp	/^const int ENTITY_mat=				4;$/;"	v
ENTITY_name	.\data.cpp	/^const int ENTITY_name=				24;$/;"	v
ENTITY_new_no	.\data.cpp	/^const int ENTITY_new_no=			60;$/;"	v
ENTITY_new_x	.\data.cpp	/^const int ENTITY_new_x=				57;$/;"	v
ENTITY_new_y	.\data.cpp	/^const int ENTITY_new_y=				58;$/;"	v
ENTITY_new_z	.\data.cpp	/^const int ENTITY_new_z=				59;$/;"	v
ENTITY_no_collisions	.\data.cpp	/^const int ENTITY_no_collisions=		49;$/;"	v
ENTITY_no_seqs	.\data.cpp	/^const int ENTITY_no_seqs=			37;$/;"	v
ENTITY_obscurer	.\data.cpp	/^const int ENTITY_obscurer=			70;$/;"	v
ENTITY_old_mat	.\data.cpp	/^const int ENTITY_old_mat=			61;$/;"	v
ENTITY_old_pitch	.\data.cpp	/^const int ENTITY_old_pitch=			54;$/;"	v
ENTITY_old_roll	.\data.cpp	/^const int ENTITY_old_roll=			56;$/;"	v
ENTITY_old_x	.\data.cpp	/^const int ENTITY_old_x=				51;$/;"	v
ENTITY_old_y	.\data.cpp	/^const int ENTITY_old_y=				52;$/;"	v
ENTITY_old_yaw	.\data.cpp	/^const int ENTITY_old_yaw=			55;$/;"	v
ENTITY_old_z	.\data.cpp	/^const int ENTITY_old_z=				53;$/;"	v
ENTITY_order	.\data.cpp	/^const int ENTITY_order=				20;$/;"	v
ENTITY_parent	.\data.cpp	/^const int ENTITY_parent=			3;$/;"	v
ENTITY_pick_mode	.\data.cpp	/^const int ENTITY_pick_mode=			69;$/;"	v
ENTITY_px	.\data.cpp	/^const int ENTITY_px=				6;$/;"	v
ENTITY_py	.\data.cpp	/^const int ENTITY_py=				7;$/;"	v
ENTITY_pz	.\data.cpp	/^const int ENTITY_pz=				8;$/;"	v
ENTITY_qw	.\data.cpp	/^const int ENTITY_qw=				15;$/;"	v
ENTITY_qx	.\data.cpp	/^const int ENTITY_qx=				16;$/;"	v
ENTITY_qy	.\data.cpp	/^const int ENTITY_qy=				17;$/;"	v
ENTITY_qz	.\data.cpp	/^const int ENTITY_qz=				18;$/;"	v
ENTITY_radius_x	.\data.cpp	/^const int ENTITY_radius_x=			41;$/;"	v
ENTITY_radius_y	.\data.cpp	/^const int ENTITY_radius_y=			42;$/;"	v
ENTITY_rotmat	.\data.cpp	/^const int ENTITY_rotmat=			5;$/;"	v
ENTITY_rx	.\data.cpp	/^const int ENTITY_rx=				12;$/;"	v
ENTITY_ry	.\data.cpp	/^const int ENTITY_ry=				13;$/;"	v
ENTITY_rz	.\data.cpp	/^const int ENTITY_rz=				14;$/;"	v
ENTITY_sx	.\data.cpp	/^const int ENTITY_sx=				9;$/;"	v
ENTITY_sy	.\data.cpp	/^const int ENTITY_sy=				10;$/;"	v
ENTITY_sz	.\data.cpp	/^const int ENTITY_sz=				11;$/;"	v
ENTITY_tformed_x	.\data.cpp	/^const int ENTITY_tformed_x=			71;$/;"	v
ENTITY_tformed_y	.\data.cpp	/^const int ENTITY_tformed_y=			72;$/;"	v
ENTITY_tformed_z	.\data.cpp	/^const int ENTITY_tformed_z=			73;$/;"	v
EOI	.\openb3d\src\stb_image.c	1619;"	d	file:
EPSILON	.\openb3d\src\collidetri.c	23;"	d	file:
EPSILON	.\openb3d\src\geom.h	/^const float EPSILON=.000001f;		\/\/small value$/;"	v
EPSILON	.\openb3d\src\pick.h	/^	static const float EPSILON=0.0001;$/;"	m	class:Pick
Edge	.\openb3d\src\shadow.h	/^class Edge{$/;"	c
EmitterParticleFunction	.\openb3d\src\functions.cpp	/^void EmitterParticleFunction(ParticleEmitter* emit, void (*EmitterFunction)(Entity*, int)){$/;"	f
EmitterParticleFunction	.\openb3d\src\particle.cpp	/^void ParticleEmitter::EmitterParticleFunction(void (*EmitterFunction)(Entity*, int)){$/;"	f	class:ParticleEmitter
EmitterParticleLife	.\openb3d\src\functions.cpp	/^void EmitterParticleLife(ParticleEmitter* emit, int l){$/;"	f
EmitterParticleLife	.\openb3d\src\particle.cpp	/^void ParticleEmitter::EmitterParticleLife (int l){$/;"	f	class:ParticleEmitter
EmitterParticleSpeed	.\openb3d\src\functions.cpp	/^void EmitterParticleSpeed(ParticleEmitter* emit, float s){$/;"	f
EmitterParticleSpeed	.\openb3d\src\particle.cpp	/^void ParticleEmitter::EmitterParticleSpeed (float s){$/;"	f	class:ParticleEmitter
EmitterRate	.\openb3d\src\functions.cpp	/^void EmitterRate(ParticleEmitter* emit, float r){$/;"	f
EmitterRate	.\openb3d\src\particle.cpp	/^void ParticleEmitter::EmitterRate (float r){$/;"	f	class:ParticleEmitter
EmitterVariance	.\openb3d\src\functions.cpp	/^void EmitterVariance(ParticleEmitter* emit, float v){$/;"	f
EmitterVariance	.\openb3d\src\particle.cpp	/^void ParticleEmitter::EmitterVariance (float v){$/;"	f	class:ParticleEmitter
EmitterVector	.\openb3d\src\functions.cpp	/^void EmitterVector(ParticleEmitter* emit, float x, float y, float z){$/;"	f
EmitterVector	.\openb3d\src\particle.cpp	/^void ParticleEmitter::EmitterVector(float x, float y, float z){$/;"	f	class:ParticleEmitter
Entity	.\openb3d\src\entity.h	/^	Entity(){$/;"	f	class:Entity
Entity	.\openb3d\src\entity.h	/^class Entity{$/;"	c
EntityAlpha	.\openb3d\src\entity.cpp	/^void Entity::EntityAlpha(float a,int recursive){$/;"	f	class:Entity
EntityAlpha	.\openb3d\src\functions.cpp	/^void EntityAlpha(Entity* ent,float alpha){$/;"	f
EntityAutoFade	.\openb3d\src\functions.cpp	/^void EntityAutoFade(Entity* ent,float near,float far){$/;"	f
EntityBlend	.\openb3d\src\entity.cpp	/^void Entity::EntityBlend(int blend_no,int recursive){$/;"	f	class:Entity
EntityBlend	.\openb3d\src\functions.cpp	/^void EntityBlend(Entity* ent, int blend){$/;"	f
EntityBlue	.\openb3d\src\entity.cpp	/^void Entity::EntityBlue(float b,int recursive){$/;"	f	class:Entity
EntityBox	.\openb3d\src\entity.cpp	/^void Entity::EntityBox(float x,float y,float z,float w,float h,float d){$/;"	f	class:Entity
EntityBox	.\openb3d\src\functions.cpp	/^void EntityBox(Entity* ent,float x,float y,float z,float w,float h,float d){$/;"	f
EntityBrush	.\data.cpp	/^Brush* EntityBrush( Entity* obj,int varid ){$/;"	f
EntityClass	.\openb3d\src\entity.cpp	/^string Entity::EntityClass(){$/;"	f	class:Entity
EntityClass	.\openb3d\src\functions.cpp	/^const char* EntityClass(Entity* ent){$/;"	f
EntityCollided	.\openb3d\src\entity.cpp	/^Entity* Entity::EntityCollided(int type_no){$/;"	f	class:Entity
EntityCollided	.\openb3d\src\functions.cpp	/^Entity* EntityCollided(Entity* ent,int type_no){$/;"	f
EntityColor	.\openb3d\src\entity.cpp	/^void Entity::EntityColor(float r,float g,float b,float a,int recursive){$/;"	f	class:Entity
EntityColor	.\openb3d\src\entity.cpp	/^void Entity::EntityColor(float r,float g,float b,int recursive){$/;"	f	class:Entity
EntityColor	.\openb3d\src\functions.cpp	/^void EntityColor(Entity* ent,float red,float green,float blue){$/;"	f
EntityDistance	.\openb3d\src\entity.cpp	/^float Entity::EntityDistance(Entity* ent2){$/;"	f	class:Entity
EntityDistance	.\openb3d\src\functions.cpp	/^float EntityDistance(Entity* ent1,Entity* ent2){$/;"	f
EntityDistanceSquared	.\methods.cpp	/^float EntityDistanceSquared( Entity* obj,Entity* ent2 ){$/;"	f
EntityDistanceSquared	.\openb3d\src\entity.cpp	/^float Entity::EntityDistanceSquared(Entity* ent2){$/;"	f	class:Entity
EntityEntity	.\data.cpp	/^Entity* EntityEntity( Entity* obj,int varid ){$/;"	f
EntityFX	.\openb3d\src\entity.cpp	/^void Entity::EntityFX(int fx_no,int recursive){$/;"	f	class:Entity
EntityFX	.\openb3d\src\functions.cpp	/^void EntityFX(Entity* ent,int fx){$/;"	f
EntityFloat	.\data.cpp	/^float* EntityFloat( Entity* obj,int varid ){$/;"	f
EntityGreen	.\openb3d\src\entity.cpp	/^void Entity::EntityGreen(float g,int recursive){$/;"	f	class:Entity
EntityInFrustum	.\methods.cpp	/^float EntityInFrustum( Camera* obj,Entity* ent ){$/;"	f
EntityInFrustum	.\openb3d\src\camera.cpp	/^float Camera::EntityInFrustum(Entity* ent){$/;"	f	class:Camera
EntityInView	.\openb3d\src\camera.cpp	/^float Camera::EntityInView(Entity* ent){$/;"	f	class:Camera
EntityInView	.\openb3d\src\functions.cpp	/^int EntityInView(Entity* ent,Camera* cam){$/;"	f
EntityInt	.\data.cpp	/^int* EntityInt( Entity* obj,int varid ){$/;"	f
EntityIterListEntity	.\data.cpp	/^Entity* EntityIterListEntity( Entity* obj,int varid,int &id ){$/;"	f
EntityListPushBackEntity	.\data.cpp	/^void EntityListPushBackEntity( Entity* obj,int varid,Entity* ent ){$/;"	f
EntityListSize	.\data.cpp	/^int EntityListSize( Entity* obj,int varid ){$/;"	f
EntityMatrix	.\data.cpp	/^Matrix* EntityMatrix( Entity* obj,int varid ){$/;"	f
EntityName	.\openb3d\src\entity.cpp	/^string Entity::EntityName(){$/;"	f	class:Entity
EntityName	.\openb3d\src\functions.cpp	/^const char* EntityName(Entity* ent){$/;"	f
EntityOrder	.\openb3d\src\entity.cpp	/^void Entity::EntityOrder(int order_no,int recursive){$/;"	f	class:Entity
EntityOrder	.\openb3d\src\functions.cpp	/^void EntityOrder(Entity* ent,int order){$/;"	f
EntityParent	.\openb3d\src\entity.cpp	/^void Entity::EntityParent(Entity* parent_ent,int glob){$/;"	f	class:Entity
EntityParent	.\openb3d\src\functions.cpp	/^void EntityParent(Entity* ent,Entity* parent_ent,bool glob){$/;"	f
EntityPick	.\openb3d\src\functions.cpp	/^Entity* EntityPick(Entity* ent,float range){$/;"	f
EntityPick	.\openb3d\src\pick.cpp	/^Entity* Pick::EntityPick(Entity* ent,float range){$/;"	f	class:Pick
EntityPickMode	.\openb3d\src\entity.cpp	/^void Entity::EntityPickMode(int no,int obscure){$/;"	f	class:Entity
EntityPickMode	.\openb3d\src\functions.cpp	/^void EntityPickMode(Entity* ent,int pick_mode,bool obscurer){$/;"	f
EntityPitch	.\openb3d\src\entity.cpp	/^float Entity::EntityPitch(int global){$/;"	f	class:Entity
EntityPitch	.\openb3d\src\functions.cpp	/^float EntityPitch(Entity* ent,bool glob){$/;"	f
EntityRadius	.\openb3d\src\entity.cpp	/^void Entity::EntityRadius(float rx,float ry){$/;"	f	class:Entity
EntityRadius	.\openb3d\src\functions.cpp	/^void EntityRadius(Entity* ent,float radius_x,float radius_y){$/;"	f
EntityRed	.\openb3d\src\entity.cpp	/^void Entity::EntityRed(float r,int recursive){$/;"	f	class:Entity
EntityRoll	.\openb3d\src\entity.cpp	/^float Entity::EntityRoll(int global){$/;"	f	class:Entity
EntityRoll	.\openb3d\src\functions.cpp	/^float EntityRoll(Entity* ent,bool glob){$/;"	f
EntityScaleX	.\openb3d\src\entity.cpp	/^float Entity::EntityScaleX(int glob){$/;"	f	class:Entity
EntityScaleX	.\openb3d\src\functions.cpp	/^float EntityScaleX(Entity* ent,bool glob){$/;"	f
EntityScaleY	.\openb3d\src\entity.cpp	/^float Entity::EntityScaleY(int glob){$/;"	f	class:Entity
EntityScaleY	.\openb3d\src\functions.cpp	/^float EntityScaleY(Entity* ent,bool glob){$/;"	f
EntityScaleZ	.\openb3d\src\entity.cpp	/^float Entity::EntityScaleZ(int glob){$/;"	f	class:Entity
EntityScaleZ	.\openb3d\src\functions.cpp	/^float EntityScaleZ(Entity* ent,bool glob){$/;"	f
EntityShininess	.\openb3d\src\entity.cpp	/^void Entity::EntityShininess(float s,int recursive){$/;"	f	class:Entity
EntityShininess	.\openb3d\src\functions.cpp	/^void EntityShininess(Entity* ent,float shine){$/;"	f
EntityString	.\data.cpp	/^const char* EntityString( Entity* obj,int varid ){$/;"	f
EntityTexture	.\openb3d\src\entity.cpp	/^void Entity::EntityTexture(Texture* texture,int frame,int index,int recursive){$/;"	f	class:Entity
EntityTexture	.\openb3d\src\functions.cpp	/^void EntityTexture(Entity* ent,Texture* tex,int frame,int index){$/;"	f
EntityType	.\openb3d\src\entity.cpp	/^void Entity::EntityType(int type_no,int recursive){$/;"	f	class:Entity
EntityType	.\openb3d\src\functions.cpp	/^void EntityType(Entity* ent,int type_no,bool recursive){$/;"	f
EntityVisible	.\openb3d\src\functions.cpp	/^int EntityVisible(Entity* src_ent,Entity* dest_ent){$/;"	f
EntityVisible	.\openb3d\src\pick.cpp	/^int Pick::EntityVisible(Entity* src_ent,Entity* dest_ent){$/;"	f	class:Pick
EntityX	.\openb3d\src\entity.cpp	/^float Entity::EntityX(int global){$/;"	f	class:Entity
EntityX	.\openb3d\src\functions.cpp	/^float EntityX(Entity* ent,bool glob){$/;"	f
EntityY	.\openb3d\src\entity.cpp	/^float Entity::EntityY(int global){$/;"	f	class:Entity
EntityY	.\openb3d\src\functions.cpp	/^float EntityY(Entity* ent,bool glob){$/;"	f
EntityYaw	.\openb3d\src\entity.cpp	/^float Entity::EntityYaw(int global){$/;"	f	class:Entity
EntityYaw	.\openb3d\src\functions.cpp	/^float EntityYaw(Entity* ent,bool glob){$/;"	f
EntityZ	.\openb3d\src\entity.cpp	/^float Entity::EntityZ(int global){$/;"	f	class:Entity
EntityZ	.\openb3d\src\functions.cpp	/^float EntityZ(Entity* ent,bool glob){$/;"	f
Eof	.\openb3d\src\file.cpp	/^int File::Eof(){$/;"	f	class:File
EquirectangularToTOAST	.\openb3d\src\geosphere.cpp	/^void Geosphere::EquirectangularToTOAST (){$/;"	f	class:Geosphere
ExtractAnimSeq	.\openb3d\src\entity.cpp	/^int Entity::ExtractAnimSeq(int first_frame,int last_frame,int seq){$/;"	f	class:Entity
ExtractAnimSeq	.\openb3d\src\functions.cpp	/^int ExtractAnimSeq(Entity* ent,int first_frame,int last_frame,int seq){$/;"	f
ExtractFrustum	.\methods.cpp	/^void ExtractFrustum( Camera* obj ){$/;"	f
ExtractFrustum	.\openb3d\src\camera.cpp	/^void Camera::ExtractFrustum(){$/;"	f	class:Camera
EyePoint	.\openb3d\src\octree.cpp	/^static Camera* EyePoint;$/;"	v	file:
FAST_BITS	.\openb3d\src\stb_image.c	974;"	d	file:
FIELDARRAY_class	.\data.cpp	/^const int FIELDARRAY_class=		24;$/;"	v
FILE_H	.\openb3d\src\file.h	11;"	d
FLUID_class	.\data.cpp	/^const int FLUID_class=			22; \/\/ isosurface.h$/;"	v
F_avg	.\openb3d\src\stb_image.c	/^   F_none=0, F_sub=1, F_up=2, F_avg=3, F_paeth=4,$/;"	e	enum:__anon19	file:
F_avg_first	.\openb3d\src\stb_image.c	/^   F_avg_first, F_paeth_first$/;"	e	enum:__anon19	file:
F_none	.\openb3d\src\stb_image.c	/^   F_none=0, F_sub=1, F_up=2, F_avg=3, F_paeth=4,$/;"	e	enum:__anon19	file:
F_paeth	.\openb3d\src\stb_image.c	/^   F_none=0, F_sub=1, F_up=2, F_avg=3, F_paeth=4,$/;"	e	enum:__anon19	file:
F_paeth_first	.\openb3d\src\stb_image.c	/^   F_avg_first, F_paeth_first$/;"	e	enum:__anon19	file:
F_sub	.\openb3d\src\stb_image.c	/^   F_none=0, F_sub=1, F_up=2, F_avg=3, F_paeth=4,$/;"	e	enum:__anon19	file:
F_up	.\openb3d\src\stb_image.c	/^   F_none=0, F_sub=1, F_up=2, F_avg=3, F_paeth=4,$/;"	e	enum:__anon19	file:
FieldArray	.\openb3d\src\isosurface.h	/^	FieldArray(){};$/;"	f	class:FieldArray
FieldArray	.\openb3d\src\isosurface.h	/^class FieldArray : public Entity{$/;"	c
File	.\openb3d\src\file.h	/^	File(){};$/;"	f	class:File
File	.\openb3d\src\file.h	/^class File{$/;"	c
FilePos	.\openb3d\src\file.cpp	/^int File::FilePos(){$/;"	f	class:File
FilterFlags	.\methods.cpp	/^void FilterFlags( Texture* obj ){$/;"	f
FilterFlags	.\openb3d\src\texture.cpp	/^void Texture::FilterFlags(){$/;"	f	class:Texture
FindChild	.\openb3d\src\entity.cpp	/^Entity* Entity::FindChild(string child_name){$/;"	f	class:Entity
FindChild	.\openb3d\src\functions.cpp	/^Entity* FindChild(Entity* ent,char* child_name){$/;"	f
FindSurface	.\openb3d\src\functions.cpp	/^Surface* FindSurface(Mesh* mesh,Brush* brush){$/;"	f
FitMesh	.\openb3d\src\functions.cpp	/^void FitMesh(Mesh* mesh,float x,float y,float z,float width,float height,float depth,bool uniform){$/;"	f
FitMesh	.\openb3d\src\mesh.cpp	/^void Mesh::FitMesh(float x,float y,float z,float width,float height,float depth,int uniform){$/;"	f	class:Mesh
FlipMesh	.\openb3d\src\functions.cpp	/^void FlipMesh(Mesh* mesh){$/;"	f
FlipMesh	.\openb3d\src\mesh.cpp	/^void Mesh::FlipMesh(){$/;"	f	class:Mesh
Fluid	.\openb3d\src\isosurface.h	/^class Fluid : public Mesh{$/;"	c
FluidArray	.\openb3d\src\functions.cpp	/^void FluidArray(Fluid* fluid, float* Array, int w, int h, int d){$/;"	f
FluidArray	.\openb3d\src\isosurface.cpp	/^void Fluid::FluidArray(float* Array, int w, int h, int d){$/;"	f	class:Fluid
FluidFunction	.\openb3d\src\functions.cpp	/^void FluidFunction(Fluid* fluid, float (*FieldFunction)(float, float, float)){$/;"	f
FluidFunction	.\openb3d\src\isosurface.cpp	/^void Fluid::FluidFunction(float (*FieldFunction)(float, float, float)){$/;"	f	class:Fluid
FluidThreshold	.\openb3d\src\functions.cpp	/^void FluidThreshold(Fluid* fluid, float threshold){$/;"	f
FreeAction	.\openb3d\src\actions.cpp	/^void Action::FreeAction(){$/;"	f	class:Action
FreeAction	.\openb3d\src\functions.cpp	/^void FreeAction(Action* act){$/;"	f
FreeBank	.\openb3d\src\bank.h	/^	void FreeBank(){$/;"	f	class:Bank
FreeBrush	.\openb3d\src\brush.cpp	/^void Brush::FreeBrush(){$/;"	f	class:Brush
FreeBrush	.\openb3d\src\functions.cpp	/^void  FreeBrush(Brush* brush){$/;"	f
FreeChild	.\openb3d\src\octree.cpp	/^void OcTreeChild::FreeChild(){$/;"	f	class:OcTreeChild
FreeConstraint	.\openb3d\src\functions.cpp	/^void FreeConstraint(Constraint* con){$/;"	f
FreeConstraint	.\openb3d\src\physics.cpp	/^void Constraint::FreeConstraint(){$/;"	f	class:Constraint
FreeEntity	.\openb3d\src\bone.cpp	/^void Bone::FreeEntity(){$/;"	f	class:Bone
FreeEntity	.\openb3d\src\camera.cpp	/^void Camera::FreeEntity(){$/;"	f	class:Camera
FreeEntity	.\openb3d\src\entity.cpp	/^void Entity::FreeEntity(void){$/;"	f	class:Entity
FreeEntity	.\openb3d\src\functions.cpp	/^void FreeEntity(Entity* ent){$/;"	f
FreeEntity	.\openb3d\src\geosphere.cpp	/^void Geosphere::FreeEntity(){$/;"	f	class:Geosphere
FreeEntity	.\openb3d\src\isosurface.cpp	/^void Blob::FreeEntity(){$/;"	f	class:Blob
FreeEntity	.\openb3d\src\isosurface.cpp	/^void FieldArray::FreeEntity(){$/;"	f	class:FieldArray
FreeEntity	.\openb3d\src\isosurface.cpp	/^void Fluid::FreeEntity(){$/;"	f	class:Fluid
FreeEntity	.\openb3d\src\light.cpp	/^void Light::FreeEntity(){$/;"	f	class:Light
FreeEntity	.\openb3d\src\mesh.cpp	/^void Mesh::FreeEntity(){$/;"	f	class:Mesh
FreeEntity	.\openb3d\src\octree.cpp	/^void OcTree::FreeEntity(){$/;"	f	class:OcTree
FreeEntity	.\openb3d\src\particle.cpp	/^void ParticleEmitter::FreeEntity (){$/;"	f	class:ParticleEmitter
FreeEntity	.\openb3d\src\pivot.cpp	/^void Pivot::FreeEntity(){$/;"	f	class:Pivot
FreeEntity	.\openb3d\src\sprite.cpp	/^void Sprite::FreeEntity(){$/;"	f	class:Sprite
FreeEntity	.\openb3d\src\terrain.cpp	/^void Terrain::FreeEntity(){$/;"	f	class:Terrain
FreeRigidBody	.\openb3d\src\functions.cpp	/^void FreeRigidBody(RigidBody* body){$/;"	f
FreeRigidBody	.\openb3d\src\physics.cpp	/^void RigidBody::FreeRigidBody(){$/;"	f	class:RigidBody
FreeShader	.\openb3d\src\functions.cpp	/^void FreeShader(Shader *shader){$/;"	f
FreeShader	.\openb3d\src\material.cpp	/^void Shader::FreeShader(){$/;"	f	class:Shader
FreeShadow	.\openb3d\src\functions.cpp	/^void FreeShadow(ShadowObject* shad){$/;"	f
FreeShadow	.\openb3d\src\shadow.cpp	/^void ShadowObject::FreeShadow() {$/;"	f	class:ShadowObject
FreeStencil	.\openb3d\src\functions.cpp	/^void FreeStencil(Stencil *stencil){$/;"	f
FreeSurface	.\openb3d\src\functions.cpp	/^void FreeSurface(Surface* surf){$/;"	f
FreeTexture	.\openb3d\src\functions.cpp	/^void FreeTexture(Texture* tex){$/;"	f
FreeTexture	.\openb3d\src\texture.cpp	/^void Texture::FreeTexture(){$/;"	f	class:Texture
FreeVBO	.\methods.cpp	/^void FreeVBO( Surface* obj ){$/;"	f
FreeVBO	.\openb3d\src\surface.cpp	/^void Surface::FreeVBO(){$/;"	f	class:Surface
FromQuaternion	.\openb3d\src\matrix.h	/^	void FromQuaternion(float x,float y,float z, float w){$/;"	f	class:Matrix
FromToRotation	.\openb3d\src\matrix.h	/^	void FromToRotation(float ix, float iy, float iz, float jx, float jy, float jz){$/;"	f	class:Matrix
GEOM_H	.\openb3d\src\geom.h	2;"	d
GEOSPHERE_H	.\openb3d\src\geosphere.h	9;"	d
GEOSPHERE_class	.\data.cpp	/^const int GEOSPHERE_class=		20;$/;"	v
GLOBAL_H	.\openb3d\src\global.h	11;"	d
GLOBAL_Shadows_enabled	.\data.cpp	/^const int GLOBAL_Shadows_enabled=	12;$/;"	v
GLOBAL_alpha_enable	.\data.cpp	/^const int GLOBAL_alpha_enable=		17;$/;"	v
GLOBAL_ambient_blue	.\data.cpp	/^const int GLOBAL_ambient_blue=		8;$/;"	v
GLOBAL_ambient_green	.\data.cpp	/^const int GLOBAL_ambient_green=		7;$/;"	v
GLOBAL_ambient_red	.\data.cpp	/^const int GLOBAL_ambient_red=		6;$/;"	v
GLOBAL_ambient_shader	.\data.cpp	/^const int GLOBAL_ambient_shader=	9;$/;"	v
GLOBAL_anim_speed	.\data.cpp	/^const int GLOBAL_anim_speed=		13;$/;"	v
GLOBAL_blend_mode	.\data.cpp	/^const int GLOBAL_blend_mode=		18;$/;"	v
GLOBAL_camera_in_use	.\data.cpp	/^const int GLOBAL_camera_in_use=		16;$/;"	v
GLOBAL_class	.\data.cpp	/^const int GLOBAL_class=			21;$/;"	v
GLOBAL_depth	.\data.cpp	/^const int GLOBAL_depth=				4;$/;"	v
GLOBAL_fog_enabled	.\data.cpp	/^const int GLOBAL_fog_enabled=		14;$/;"	v
GLOBAL_fx1	.\data.cpp	/^const int GLOBAL_fx1=				19;$/;"	v
GLOBAL_fx2	.\data.cpp	/^const int GLOBAL_fx2=				20;$/;"	v
GLOBAL_height	.\data.cpp	/^const int GLOBAL_height=			2;$/;"	v
GLOBAL_mode	.\data.cpp	/^const int GLOBAL_mode=				3;$/;"	v
GLOBAL_rate	.\data.cpp	/^const int GLOBAL_rate=				5;$/;"	v
GLOBAL_root_ent	.\data.cpp	/^const int GLOBAL_root_ent=			15;$/;"	v
GLOBAL_vbo_enabled	.\data.cpp	/^const int GLOBAL_vbo_enabled=		10;$/;"	v
GLOBAL_vbo_min_tris	.\data.cpp	/^const int GLOBAL_vbo_min_tris=		11;$/;"	v
GLOBAL_width	.\data.cpp	/^const int GLOBAL_width=				1;$/;"	v
Geosphere	.\openb3d\src\geosphere.h	/^class Geosphere : public Terrain{$/;"	c
GeosphereHeight	.\openb3d\src\functions.cpp	/^void GeosphereHeight(Geosphere* geo, float h){$/;"	f
GetAttribLoc	.\openb3d\src\material.cpp	/^int ProgramObject::GetAttribLoc(string name){$/;"	f	class:ProgramObject
GetBounds	.\methods.cpp	/^void GetBounds( Mesh* obj ){$/;"	f
GetBounds	.\openb3d\src\mesh.cpp	/^void Mesh::GetBounds(){$/;"	f	class:Mesh
GetBrushTexture	.\openb3d\src\brush.cpp	/^Texture* Brush::GetBrushTexture(int index){$/;"	f	class:Brush
GetBrushTexture	.\openb3d\src\functions.cpp	/^Texture* GetBrushTexture(Brush* brush,int index){$/;"	f
GetChild	.\openb3d\src\entity.cpp	/^Entity* Entity::GetChild(int child_no){$/;"	f	class:Entity
GetChild	.\openb3d\src\functions.cpp	/^Entity* GetChild(Entity* ent,int child_no){$/;"	f
GetChildFromAll	.\methods.cpp	/^Entity* GetChildFromAll( Entity* obj,int child_no,int &no_children,Entity* ent ){$/;"	f
GetChildFromAll	.\openb3d\src\entity.cpp	/^Entity* Entity::GetChildFromAll(int child_no,int &no_children,Entity* ent){$/;"	f	class:Entity
GetEntityBrush	.\openb3d\src\entity.cpp	/^Brush* Entity::GetEntityBrush(){$/;"	f	class:Entity
GetEntityBrush	.\openb3d\src\functions.cpp	/^Brush* GetEntityBrush(Entity* ent){$/;"	f
GetEntityType	.\openb3d\src\entity.cpp	/^int Entity::GetEntityType(){$/;"	f	class:Entity
GetEntityType	.\openb3d\src\functions.cpp	/^int GetEntityType(Entity* ent){$/;"	f
GetInverse	.\openb3d\src\matrix.h	/^	void GetInverse(Matrix &mat){$/;"	f	class:Matrix
GetInverse2	.\openb3d\src\matrix.h	/^	void GetInverse2(Matrix &mat){$/;"	f	class:Matrix
GetMatElement	.\openb3d\src\functions.cpp	/^float GetMatElement(Entity* ent,int row,int col){$/;"	f
GetParent	.\openb3d\src\entity.cpp	/^Entity* Entity::GetParent(){$/;"	f	class:Entity
GetParentEntity	.\openb3d\src\functions.cpp	/^Entity* GetParentEntity(Entity* ent){$/;"	f
GetParticleBatch	.\openb3d\src\particle.h	/^	static ParticleBatch* GetParticleBatch(Texture* tex,int blend,int order){$/;"	f	class:ParticleBatch
GetPitch	.\openb3d\src\matrix.h	/^	float GetPitch(){$/;"	f	class:Matrix
GetRoll	.\openb3d\src\matrix.h	/^	float GetRoll(){$/;"	f	class:Matrix
GetSpriteBatchMesh	.\openb3d\src\sprite_batch.h	/^	Mesh* GetSpriteBatchMesh(){$/;"	f	class:SpriteBatch
GetSpriteBatchSurface	.\openb3d\src\sprite_batch.h	/^	static Surface* GetSpriteBatchSurface(Texture* tex,int blend,int order){$/;"	f	class:SpriteBatch
GetSurface	.\openb3d\src\functions.cpp	/^Surface* GetSurface(Mesh* mesh,int surf_no){$/;"	f
GetSurface	.\openb3d\src\mesh.cpp	/^Surface* Mesh::GetSurface(int surf_no_get){$/;"	f	class:Mesh
GetSurfaceBrush	.\openb3d\src\functions.cpp	/^Brush* GetSurfaceBrush(Surface* surf){$/;"	f
GetSurfaceBrush	.\openb3d\src\surface.cpp	/^Brush* Surface::GetSurfaceBrush(){$/;"	f	class:Surface
GetUniLoc	.\openb3d\src\material.cpp	/^int ProgramObject::GetUniLoc(string name){$/;"	f	class:ProgramObject
GetYaw	.\openb3d\src\matrix.h	/^	float GetYaw(){$/;"	f	class:Matrix
Global	.\openb3d\src\global.h	/^class Global{$/;"	c
Graphics	.\openb3d\src\global.cpp	/^void Global::Graphics(){$/;"	f	class:Global
Graphics3D	.\openb3d\src\functions.cpp	/^void Graphics3D(int width,int height,int depth,int mode,int rate){$/;"	f
HALFPI	.\openb3d\src\geom.h	/^const float HALFPI=PI*.5f;			\/\/90  degrees$/;"	v
HDR_BUFLEN	.\openb3d\src\stb_image.c	4207;"	d	file:
HandleSprite	.\openb3d\src\functions.cpp	/^void HandleSprite(Sprite* sprite,float h_x,float h_y){$/;"	f
HandleSprite	.\openb3d\src\sprite.cpp	/^void Sprite::HandleSprite(float h_x,float h_y){$/;"	f	class:Sprite
Hidden	.\methods.cpp	/^int Hidden( Entity* obj ){$/;"	f
Hidden	.\openb3d\src\entity.cpp	/^int Entity::Hidden(){$/;"	f	class:Entity
HideEntity	.\openb3d\src\entity.cpp	/^void Entity::HideEntity(){$/;"	f	class:Entity
HideEntity	.\openb3d\src\functions.cpp	/^void HideEntity(Entity* ent){$/;"	f
ID	.\openb3d\src\shadermat.h	/^	int ID;$/;"	m	class:Shader
IDCT_1D	.\openb3d\src\stb_image.c	1231;"	d	file:
ISECT	.\openb3d\src\collidetri.c	49;"	d	file:
Init	.\openb3d\src\shadow.cpp	/^void ShadowObject::Init(){$/;"	f	class:ShadowObject
InitShadow	.\methods.cpp	/^void InitShadow( ShadowObject* obj ){$/;"	f
InitShadow	.\openb3d\src\shadow.cpp	/^void ShadowObject::InitShadow(){$/;"	f	class:ShadowObject
Instr	.\openb3d\src\string_helper.cpp	/^int Instr(string s1,string s2,int offset){$/;"	f
InterpolateMatrix	.\openb3d\src\matrix.cpp	/^void InterpolateMatrix(Matrix &m, Matrix &a, float alpha){$/;"	f
KEYS	.\openb3d\src\model.cpp	/^const int KEYS=9;$/;"	v
LIGHT_H	.\openb3d\src\light.h	11;"	d
LIGHT_blue	.\data.cpp	/^const int LIGHT_blue=		11;$/;"	v
LIGHT_cast_shadow	.\data.cpp	/^const int LIGHT_cast_shadow=6;$/;"	v
LIGHT_class	.\data.cpp	/^const int LIGHT_class=			25;$/;"	v
LIGHT_gl_light	.\data.cpp	/^const int LIGHT_gl_light=	4;$/;"	v
LIGHT_green	.\data.cpp	/^const int LIGHT_green=		10;$/;"	v
LIGHT_inner_ang	.\data.cpp	/^const int LIGHT_inner_ang=	12;$/;"	v
LIGHT_light_list	.\data.cpp	/^const int LIGHT_light_list=	5;$/;"	v
LIGHT_light_no	.\data.cpp	/^const int LIGHT_light_no=	1;$/;"	v
LIGHT_light_type	.\data.cpp	/^const int LIGHT_light_type=	7;$/;"	v
LIGHT_max_lights	.\data.cpp	/^const int LIGHT_max_lights=	3;	$/;"	v
LIGHT_no_lights	.\data.cpp	/^const int LIGHT_no_lights=	2;$/;"	v
LIGHT_outer_ang	.\data.cpp	/^const int LIGHT_outer_ang=	13;$/;"	v
LIGHT_range	.\data.cpp	/^const int LIGHT_range=		8;$/;"	v
LIGHT_red	.\data.cpp	/^const int LIGHT_red=		9;$/;"	v
LINE_class	.\data.cpp	/^const int LINE_class=			14;$/;"	v
LOD	.\openb3d\src\voxel.h	/^	int LOD[16*3];$/;"	m	class:VoxelSprite
Left	.\openb3d\src\string_helper.cpp	/^string Left(string s,int length){$/;"	f
Len	.\openb3d\src\string_helper.cpp	/^int Len(string s){$/;"	f
Light	.\openb3d\src\light.h	/^	Light(){$/;"	f	class:Light
Light	.\openb3d\src\light.h	/^class Light : public Entity{$/;"	c
LightChar	.\data.cpp	/^char* LightChar( Light* obj,int varid ){$/;"	f
LightColor	.\openb3d\src\functions.cpp	/^void LightColor(Light* light,float red,float green,float blue){$/;"	f
LightColor	.\openb3d\src\light.cpp	/^void Light::LightColor(float r,float g,float b){$/;"	f	class:Light
LightConeAngles	.\openb3d\src\functions.cpp	/^void LightConeAngles(Light* light,float inner_ang,float outer_ang){$/;"	f
LightConeAngles	.\openb3d\src\light.cpp	/^void Light::LightConeAngles(float inner,float outer){$/;"	f	class:Light
LightFloat	.\data.cpp	/^float* LightFloat( Light* obj,int varid ){$/;"	f
LightRange	.\openb3d\src\functions.cpp	/^void LightRange(Light* light,float range){$/;"	f
LightRange	.\openb3d\src\light.cpp	/^void Light::LightRange(float light_range){$/;"	f	class:Light
LightUpdate	.\methods.cpp	/^void LightUpdate( Light* obj ){$/;"	f
Line	.\openb3d\src\geom.h	/^	Line( const Vector &o,const Vector &d ):o(o),d(d){$/;"	f	class:Line
Line	.\openb3d\src\geom.h	/^	Line(){$/;"	f	class:Line
Line	.\openb3d\src\geom.h	/^class Line{$/;"	c
LinePick	.\openb3d\src\functions.cpp	/^Entity* LinePick(float x,float y,float z,float dx,float dy,float dz,float radius){$/;"	f
LinePick	.\openb3d\src\pick.cpp	/^Entity* Pick::LinePick(float x,float y,float z,float dx,float dy,float dz,float radius){$/;"	f	class:Pick
Load3ds	.\openb3d\src\3ds.cpp	/^Mesh* Load3ds(string URL, Entity* parent_ent){$/;"	f	namespace:load3ds
LoadAnimB3D	.\openb3d\src\model.cpp	/^Mesh* LoadAnimB3D(string f_name,Entity* parent_ent_ext){$/;"	f
LoadAnimMesh	.\openb3d\src\functions.cpp	/^Mesh* LoadAnimMesh(char* file,Entity* parent){$/;"	f
LoadAnimMesh	.\openb3d\src\mesh.cpp	/^Mesh* Mesh::LoadAnimMesh(string filename,Entity* parent_ent){$/;"	f	class:Mesh
LoadAnimSeq	.\openb3d\src\entity.cpp	/^int Entity::LoadAnimSeq(string filename){$/;"	f	class:Entity
LoadAnimSeq	.\openb3d\src\functions.cpp	/^int LoadAnimSeq(Entity* ent, char* file){$/;"	f
LoadAnimTexture	.\openb3d\src\functions.cpp	/^Texture* LoadAnimTexture(char* file,int flags,int frame_width,int frame_height,int first_frame,int frame_count){$/;"	f
LoadAnimTexture	.\openb3d\src\texture.cpp	/^Texture* Texture::LoadAnimTexture(string filename,int flags, int frame_width,int frame_height,int first_frame,int frame_count){$/;"	f	class:Texture
LoadBrush	.\openb3d\src\brush.cpp	/^Brush* Brush::LoadBrush(string file,int flags,float u_scale,float v_scale){$/;"	f	class:Brush
LoadBrush	.\openb3d\src\functions.cpp	/^Brush* LoadBrush(char *file,int flags,float u_scale,float v_scale){$/;"	f
LoadGeosphere	.\openb3d\src\functions.cpp	/^Terrain* LoadGeosphere(char* file,Entity* parent){$/;"	f
LoadGeosphere	.\openb3d\src\geosphere.cpp	/^Geosphere* Geosphere::LoadGeosphere(string filename,Entity* parent_ent){$/;"	f	class:Geosphere
LoadIdentity	.\openb3d\src\matrix.h	/^	void LoadIdentity(){$/;"	f	class:Matrix
LoadMD2	.\openb3d\src\md2.cpp	/^Mesh* LoadMD2(string filename,Entity* parent_ent){$/;"	f	namespace:loadMD2
LoadMap	.\openb3d\src\3ds.cpp	/^void LoadMap(){$/;"	f	namespace:load3ds
LoadMaterial	.\openb3d\src\functions.cpp	/^Material* LoadMaterial(char* filename,int flags, int frame_width,int frame_height,int first_frame,int frame_count){$/;"	f
LoadMaterial	.\openb3d\src\material.cpp	/^Material* Material::LoadMaterial(string filename,int flags, int frame_width,int frame_height,int first_frame,int frame_count){$/;"	f	class:Material
LoadMesh	.\openb3d\src\functions.cpp	/^Mesh* LoadMesh(char* file,Entity* parent){$/;"	f
LoadMesh	.\openb3d\src\mesh.cpp	/^Mesh* Mesh::LoadMesh(string filename,Entity* parent_ent){$/;"	f	class:Mesh
LoadShader	.\openb3d\src\functions.cpp	/^Shader* LoadShader(char* ShaderName, char* VshaderFileName, char* FshaderFileName){$/;"	f
LoadSprite	.\openb3d\src\functions.cpp	/^Sprite* LoadSprite(char* tex_file,int tex_flag,Entity* parent){$/;"	f
LoadSprite	.\openb3d\src\sprite.cpp	/^Sprite* Sprite::LoadSprite(string tex_file,int tex_flag,Entity* parent_ent){$/;"	f	class:Sprite
LoadTerrain	.\openb3d\src\functions.cpp	/^Terrain* LoadTerrain(char* file,Entity* parent){$/;"	f
LoadTerrain	.\openb3d\src\terrain.cpp	/^Terrain* Terrain::LoadTerrain(string filename,Entity* parent_ent){$/;"	f	class:Terrain
LoadTexture	.\openb3d\src\functions.cpp	/^Texture* LoadTexture(char* file,int flags){$/;"	f
LoadTexture	.\openb3d\src\texture.cpp	/^Texture* Texture::LoadTexture(string filename,int flags){$/;"	f	class:Texture
LoadX	.\openb3d\src\x.cpp	/^Mesh* LoadX(string URL, Entity* parent_ent){$/;"	f	namespace:loadX
Lower	.\openb3d\src\string_helper.cpp	/^string Lower(string s){$/;"	f
M	.\openb3d\src\project.cpp	22;"	d	file:
M	.\openb3d\src\project.cpp	31;"	d	file:
M3D_3DS_3DEDITOR	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_3DEDITOR       = 0x3D3D;$/;"	m	namespace:load3ds	file:
M3D_3DS_BrushAMBIENT	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_BrushAMBIENT   = 0xA010;$/;"	m	namespace:load3ds	file:
M3D_3DS_BrushBLOCK	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_BrushBLOCK     = 0xAFFF;$/;"	m	namespace:load3ds	file:
M3D_3DS_BrushDIFFUSE	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_BrushDIFFUSE   = 0xA020;$/;"	m	namespace:load3ds	file:
M3D_3DS_BrushNAME	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_BrushNAME      = 0xA000;$/;"	m	namespace:load3ds	file:
M3D_3DS_BrushSHININESS	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_BrushSHININESS = 0xA040;$/;"	m	namespace:load3ds	file:
M3D_3DS_BrushSPECULAR	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_BrushSPECULAR  = 0xA030;$/;"	m	namespace:load3ds	file:
M3D_3DS_FACELIST	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_FACELIST       = 0x4120;$/;"	m	namespace:load3ds	file:
M3D_3DS_FACEMATLIST	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_FACEMATLIST    = 0x4130;$/;"	m	namespace:load3ds	file:
M3D_3DS_MAIN	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_MAIN           = 0x4D4D;$/;"	m	namespace:load3ds	file:
M3D_3DS_MAPFILENAME	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_MAPFILENAME    = 0xA300;$/;"	m	namespace:load3ds	file:
M3D_3DS_MAPROTATION	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_MAPROTATION    = 0xA35C;$/;"	m	namespace:load3ds	file:
M3D_3DS_MAPUOFFSET	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_MAPUOFFSET     = 0xA358;$/;"	m	namespace:load3ds	file:
M3D_3DS_MAPUSCALE	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_MAPUSCALE      = 0xA356;$/;"	m	namespace:load3ds	file:
M3D_3DS_MAPVOFFSET	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_MAPVOFFSET     = 0xA35A;$/;"	m	namespace:load3ds	file:
M3D_3DS_MAPVSCALE	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_MAPVSCALE      = 0xA354;$/;"	m	namespace:load3ds	file:
M3D_3DS_OBJECTBLOCK	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_OBJECTBLOCK    = 0x4000;$/;"	m	namespace:load3ds	file:
M3D_3DS_PERCENTF	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_PERCENTF       = 0x0031;$/;"	m	namespace:load3ds	file:
M3D_3DS_PERCENTI	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_PERCENTI       = 0x0030;$/;"	m	namespace:load3ds	file:
M3D_3DS_RGB3B	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_RGB3B          = 0x0011;$/;"	m	namespace:load3ds	file:
M3D_3DS_RGB3F	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_RGB3F          = 0x0010;$/;"	m	namespace:load3ds	file:
M3D_3DS_RGBGAMMA3B	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_RGBGAMMA3B     = 0x0012;$/;"	m	namespace:load3ds	file:
M3D_3DS_RGBGAMMA3F	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_RGBGAMMA3F     = 0x0013;$/;"	m	namespace:load3ds	file:
M3D_3DS_TEXCOORDS	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_TEXCOORDS      = 0x4140;$/;"	m	namespace:load3ds	file:
M3D_3DS_TEXTUREMAP1	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_TEXTUREMAP1    = 0xA200;$/;"	m	namespace:load3ds	file:
M3D_3DS_TEXTUREMAP2	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_TEXTUREMAP2    = 0xA33A;$/;"	m	namespace:load3ds	file:
M3D_3DS_TRIMESH	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_TRIMESH        = 0x4100;$/;"	m	namespace:load3ds	file:
M3D_3DS_VERTEXLIST	.\openb3d\src\3ds.cpp	/^const int M3D_3DS_VERTEXLIST     = 0x4110;$/;"	m	namespace:load3ds	file:
MARKER_none	.\openb3d\src\stb_image.c	1345;"	d	file:
MAT	.\openb3d\src\project.cpp	253;"	d	file:
MAT	.\openb3d\src\project.cpp	88;"	d	file:
MATERIALPLUGIN_class	.\data.cpp	/^const int MATERIALPLUGIN_class=	26; \/\/ material.h$/;"	v
MATERIAL_H	.\openb3d\src\material.h	2;"	d
MATERIAL_class	.\data.cpp	/^const int MATERIAL_class=		40;$/;"	v
MATHS_HELPER_H	.\openb3d\src\maths_helper.h	2;"	d
MATRIX_H	.\openb3d\src\matrix.h	16;"	d
MATRIX_class	.\data.cpp	/^const int MATRIX_class=			27;$/;"	v
MATRIX_grid	.\data.cpp	/^const int MATRIX_grid=	1;$/;"	v
MAX_COLL_TRIS	.\openb3d\src\tree.cpp	/^static const unsigned int MAX_COLL_TRIS=16;$/;"	v	file:
MAX_HITS	.\openb3d\src\collision.cpp	/^const int MAX_HITS=10;$/;"	v
MAX_TYPES	.\openb3d\src\collision2.h	/^const int MAX_TYPES=100;$/;"	v
MESH	.\openb3d\src\model.cpp	/^const int MESH=5;$/;"	v
MESHCOLLIDER_H	.\openb3d\src\tree.h	2;"	d
MESHCOLLIDER_class	.\data.cpp	/^const int MESHCOLLIDER_class=	56; \/\/ tree.h$/;"	v
MESHINFO_class	.\data.cpp	/^const int MESHINFO_class=		57;$/;"	v
MESH_H	.\openb3d\src\mesh.h	11;"	d
MESH_anim_surf_list	.\data.cpp	/^const int MESH_anim_surf_list=	3;$/;"	v
MESH_bones	.\data.cpp	/^const int MESH_bones=			4;$/;"	v
MESH_c_col_tree	.\data.cpp	/^const int MESH_c_col_tree=		6;$/;"	v
MESH_class	.\data.cpp	/^const int MESH_class=			28;$/;"	v
MESH_mat_sp	.\data.cpp	/^const int MESH_mat_sp=			5;$/;"	v
MESH_max_x	.\data.cpp	/^const int MESH_max_x=			12;$/;"	v
MESH_max_y	.\data.cpp	/^const int MESH_max_y=			13;$/;"	v
MESH_max_z	.\data.cpp	/^const int MESH_max_z=			14;$/;"	v
MESH_min_x	.\data.cpp	/^const int MESH_min_x=			9;$/;"	v
MESH_min_y	.\data.cpp	/^const int MESH_min_y=			10;$/;"	v
MESH_min_z	.\data.cpp	/^const int MESH_min_z=			11;$/;"	v
MESH_no_surfs	.\data.cpp	/^const int MESH_no_surfs=		1;$/;"	v
MESH_reset_bounds	.\data.cpp	/^const int MESH_reset_bounds=	8;$/;"	v
MESH_reset_col_tree	.\data.cpp	/^const int MESH_reset_col_tree=	7;$/;"	v
MESH_surf_list	.\data.cpp	/^const int MESH_surf_list=		2;$/;"	v
METABALL_H	.\openb3d\src\isosurface.h	2;"	d
MMATRIX_class	.\data.cpp	/^const int MMATRIX_class=		17;$/;"	v
MMatrix	.\openb3d\src\geom.h	/^	MMatrix( const Quat &q ){$/;"	f	class:MMatrix
MMatrix	.\openb3d\src\geom.h	/^	MMatrix( const Vector &i,const Vector &j,const Vector &k ):i(i),j(j),k(k){$/;"	f	class:MMatrix
MMatrix	.\openb3d\src\geom.h	/^	MMatrix( float angle,const Vector &axis ){$/;"	f	class:MMatrix
MMatrix	.\openb3d\src\geom.h	/^	MMatrix():i(Vector(1,0,0)),j(Vector(0,1,0)),k(Vector(0,0,1)){$/;"	f	class:MMatrix
MMatrix	.\openb3d\src\geom.h	/^class MMatrix{$/;"	c
MMatrixPitch	.\openb3d\src\geom.h	/^inline float MMatrixPitch( const MMatrix &m ){$/;"	f
MMatrixQuat	.\openb3d\src\geom.h	/^inline Quat MMatrixQuat( const MMatrix &p ){$/;"	f
MMatrixRoll	.\openb3d\src\geom.h	/^inline float MMatrixRoll( const MMatrix &m ){$/;"	f
MMatrixYaw	.\openb3d\src\geom.h	/^inline float MMatrixYaw( const MMatrix &m ){$/;"	f
MODEL_H	.\openb3d\src\model.h	11;"	d
MQ_GetInvMatrix	.\methods.cpp	/^void MQ_GetInvMatrix( Entity* obj,Matrix &mat0 ){$/;"	f
MQ_GetInvMatrix	.\openb3d\src\entity.cpp	/^void Entity::MQ_GetInvMatrix(Matrix &mat0){$/;"	f	class:Entity
MQ_GetMatrix	.\methods.cpp	/^void MQ_GetMatrix( Entity* obj,Matrix &mat3 ){$/;"	f
MQ_GetMatrix	.\openb3d\src\entity.cpp	/^void Entity::MQ_GetMatrix(Matrix &mat3){$/;"	f	class:Entity
MQ_GetScaleXYZ	.\methods.cpp	/^void MQ_GetScaleXYZ( Entity* obj,float &width,float &height,float &depth ){$/;"	f
MQ_GetScaleXYZ	.\openb3d\src\entity.cpp	/^void Entity::MQ_GetScaleXYZ(float &width, float &height, float &depth){$/;"	f	class:Entity
MQ_SetMatrix	.\methods.cpp	/^void MQ_SetMatrix( Entity* obj,Matrix &inputMatrix ){$/;"	f
MQ_SetMatrix	.\openb3d\src\entity.cpp	/^void Entity::MQ_SetMatrix( Matrix &inputMatrix ){$/;"	f	class:Entity
MQ_Turn	.\methods.cpp	/^void MQ_Turn( Entity* obj,float ang,float vx,float vy,float vz,int glob ){$/;"	f
MQ_Turn	.\openb3d\src\entity.cpp	/^void Entity::MQ_Turn( float ang, float vx, float vy, float vz, int glob ){$/;"	f	class:Entity
MQ_Update	.\methods.cpp	/^void MQ_Update( Entity* obj ){$/;"	f
MQ_Update	.\openb3d\src\entity.cpp	/^void Entity::MQ_Update(){$/;"	f	class:Entity
M_PI	.\openb3d\src\maths_helper.h	18;"	d
Magnitude	.\openb3d\src\matrix.cpp	/^float Magnitude( float x, float y, float z ){$/;"	f
MakeTriangle	.\openb3d\src\csg.cpp	/^CSGTriangle* MakeTriangle(Mesh* mesh, Surface* surf, float x0, float y0, float z0, float u0, float v0, float x1, float y1, float z1, float u1, float v1, float x2, float y2, float z2, float u2, float v2, int loop, CSGTriangle* org){$/;"	f	namespace:CSG
MarchingCube	.\openb3d\src\isosurface.cpp	/^void Fluid::MarchingCube(float x, float y, float z, float x1, float y1, float z1, float F[8]){$/;"	f	class:Fluid
MarchingCube	.\openb3d\src\voxterrain.cpp	/^void VoxelTerrain::MarchingCube(float x, float y, float z, float x1, float y1, float z1, float F[8]){$/;"	f	class:VoxelTerrain
Mat	.\openb3d\src\octree.cpp	/^static Matrix* Mat;$/;"	v	file:
Material	.\openb3d\src\shadermat.h	/^class Material : public Texture{$/;"	c
MaterialPlugin	.\openb3d\src\material.h	/^class MaterialPlugin{$/;"	c
Matrix	.\openb3d\src\matrix.h	/^	Matrix(){$/;"	f	class:Matrix
Matrix	.\openb3d\src\matrix.h	/^class Matrix{$/;"	c
MatrixCopy	.\methods.cpp	/^Matrix* MatrixCopy( Matrix* obj ){$/;"	f
MatrixFloat	.\data.cpp	/^float* MatrixFloat( Matrix* obj,int varid ){$/;"	f
MatrixFromQuaternion	.\methods.cpp	/^void MatrixFromQuaternion( Matrix* obj,float x,float y,float z,float w ){$/;"	f
MatrixFromToRotation	.\methods.cpp	/^void MatrixFromToRotation( Matrix* obj,float ix,float iy,float iz,float jx,float jy,float jz ){$/;"	f
MatrixGetInverse	.\methods.cpp	/^void MatrixGetInverse( Matrix* obj,Matrix &mat ){$/;"	f
MatrixGetInverse2	.\methods.cpp	/^void MatrixGetInverse2( Matrix* obj,Matrix &mat ){$/;"	f
MatrixGetPitch	.\methods.cpp	/^float MatrixGetPitch( Matrix* obj ){$/;"	f
MatrixGetRoll	.\methods.cpp	/^float MatrixGetRoll( Matrix* obj ){$/;"	f
MatrixGetYaw	.\methods.cpp	/^float MatrixGetYaw( Matrix* obj ){$/;"	f
MatrixInterpolateMatrix	.\methods.cpp	/^void MatrixInterpolateMatrix( Matrix &m,Matrix &a,float alpha ){$/;"	f
MatrixLoadIdentity	.\methods.cpp	/^void MatrixLoadIdentity( Matrix* obj ){$/;"	f
MatrixMultiply	.\methods.cpp	/^void MatrixMultiply( Matrix* obj,Matrix &mat ){$/;"	f
MatrixMultiply2	.\methods.cpp	/^void MatrixMultiply2( Matrix* obj,Matrix &mat ){$/;"	f
MatrixOverwrite	.\methods.cpp	/^void MatrixOverwrite( Matrix* obj,Matrix &mat ){$/;"	f
MatrixQuaternion_FromAngleAxis	.\methods.cpp	/^void MatrixQuaternion_FromAngleAxis( float angle,float ax,float ay,float az,float &rx,float &ry,float &rz,float &rw ){$/;"	f
MatrixQuaternion_MultiplyQuat	.\methods.cpp	/^void MatrixQuaternion_MultiplyQuat( float x1,float y1,float z1,float w1,float x2,float y2,float z2,float w2,float &rx,float &ry,float &rz,float &rw ){$/;"	f
MatrixRotate	.\methods.cpp	/^void MatrixRotate( Matrix* obj,float rx,float ry,float rz ){$/;"	f
MatrixRotatePitch	.\methods.cpp	/^void MatrixRotatePitch( Matrix* obj,float ang ){$/;"	f
MatrixRotateRoll	.\methods.cpp	/^void MatrixRotateRoll( Matrix* obj,float ang ){$/;"	f
MatrixRotateYaw	.\methods.cpp	/^void MatrixRotateYaw( Matrix* obj,float ang ){$/;"	f
MatrixScale	.\methods.cpp	/^void MatrixScale( Matrix* obj,float x,float y,float z ){$/;"	f
MatrixSetTranslate	.\methods.cpp	/^void MatrixSetTranslate( Matrix* obj,float x,float y,float z ){$/;"	f
MatrixToQuat	.\methods.cpp	/^void MatrixToQuat( Matrix* obj,float &qx,float &qy,float &qz,float &qw ){$/;"	f
MatrixTransformVec	.\methods.cpp	/^void MatrixTransformVec( Matrix* obj,float &rx,float &ry,float &rz,int addTranslation=0 ){$/;"	f
MatrixTranslate	.\methods.cpp	/^void MatrixTranslate( Matrix* obj,float x,float y,float z ){$/;"	f
MatrixTranspose	.\methods.cpp	/^void MatrixTranspose( Matrix* obj ){$/;"	f
Mesh	.\openb3d\src\mesh.h	/^	Mesh(){$/;"	f	class:Mesh
Mesh	.\openb3d\src\mesh.h	/^class Mesh : public Entity{$/;"	c
MeshAlpha	.\methods.cpp	/^void MeshAlpha( Mesh* obj,float a ){$/;"	f
MeshAlpha	.\openb3d\src\mesh.cpp	/^void Mesh::MeshAlpha(float a){$/;"	f	class:Mesh
MeshBlue	.\methods.cpp	/^void MeshBlue( Mesh* obj,float b ){$/;"	f
MeshBlue	.\openb3d\src\mesh.cpp	/^void Mesh::MeshBlue(float b){$/;"	f	class:Mesh
MeshCSG	.\openb3d\src\csg.cpp	/^Mesh* MeshCSG(Mesh* m1, Mesh* m2, int method){$/;"	f	namespace:CSG
MeshCSG	.\openb3d\src\functions.cpp	/^Mesh* MeshCSG(Mesh* m1, Mesh* m2, int method = 1){$/;"	f
MeshCSG	.\openb3d\src\mesh.cpp	/^Mesh* Mesh::MeshCSG(Mesh* mesh2, int method){$/;"	f	class:Mesh
MeshCollider	.\openb3d\src\tree.cpp	/^MeshCollider::MeshCollider( const vector<Vertex> &verts,const vector<Triangle> &tris ):$/;"	f	class:MeshCollider
MeshCollider	.\openb3d\src\tree.h	/^	MeshCollider(){$/;"	f	class:MeshCollider
MeshCollider	.\openb3d\src\tree.h	/^class MeshCollider{$/;"	c
MeshColor	.\methods.cpp	/^void MeshColor( Mesh* obj,float r,float g,float b,float a ){$/;"	f
MeshColor	.\openb3d\src\mesh.cpp	/^void Mesh::MeshColor(float r,float g,float b){$/;"	f	class:Mesh
MeshColor	.\openb3d\src\mesh.cpp	/^void Mesh::MeshColor(float r,float g,float b,float a){$/;"	f	class:Mesh
MeshCullRadius	.\openb3d\src\functions.cpp	/^void MeshCullRadius(Entity* ent, float radius){$/;"	f
MeshDepth	.\openb3d\src\functions.cpp	/^float MeshDepth(Mesh* mesh){$/;"	f
MeshDepth	.\openb3d\src\mesh.cpp	/^float Mesh::MeshDepth(){$/;"	f	class:Mesh
MeshFloat	.\data.cpp	/^float* MeshFloat( Mesh* obj,int varid ){$/;"	f
MeshGreen	.\methods.cpp	/^void MeshGreen( Mesh* obj,float g ){$/;"	f
MeshGreen	.\openb3d\src\mesh.cpp	/^void Mesh::MeshGreen(float g){$/;"	f	class:Mesh
MeshHeight	.\openb3d\src\functions.cpp	/^float MeshHeight(Mesh* mesh){$/;"	f
MeshHeight	.\openb3d\src\mesh.cpp	/^float Mesh::MeshHeight(){$/;"	f	class:Mesh
MeshInfo	.\openb3d\src\tree.h	/^	MeshInfo(){};$/;"	f	class:MeshInfo
MeshInfo	.\openb3d\src\tree.h	/^class MeshInfo{$/;"	c
MeshInt	.\data.cpp	/^int* MeshInt( Mesh* obj,int varid ){$/;"	f
MeshIterListSurface	.\data.cpp	/^Surface* MeshIterListSurface( Mesh* obj,int varid,int &id ){$/;"	f
MeshIterVectorBone	.\data.cpp	/^Bone* MeshIterVectorBone( Mesh* obj,int varid,int &id ){$/;"	f
MeshListPushBackBone	.\data.cpp	/^void MeshListPushBackBone( Mesh* obj,int varid,Bone* bone ){$/;"	f
MeshListPushBackSurface	.\data.cpp	/^void MeshListPushBackSurface( Mesh* obj,int varid,Surface* surf ){$/;"	f
MeshListSize	.\data.cpp	/^int MeshListSize( Mesh* obj,int varid ){$/;"	f
MeshMatrix	.\data.cpp	/^Matrix* MeshMatrix( Mesh* obj,int varid ){$/;"	f
MeshRed	.\methods.cpp	/^void MeshRed( Mesh* obj,float r ){$/;"	f
MeshRed	.\openb3d\src\mesh.cpp	/^void Mesh::MeshRed(float r){$/;"	f	class:Mesh
MeshRender	.\methods.cpp	/^void MeshRender( Mesh* obj ){$/;"	f
MeshVectorBone	.\data.cpp	/^vector<Bone*>* MeshVectorBone( Mesh* obj,int varid ){$/;"	f
MeshWidth	.\openb3d\src\functions.cpp	/^float MeshWidth(Mesh* mesh){$/;"	f
MeshWidth	.\openb3d\src\mesh.cpp	/^float Mesh::MeshWidth(){$/;"	f	class:Mesh
Mesh_info	.\openb3d\src\octree.cpp	/^static MeshInfo* Mesh_info;$/;"	v	file:
MeshesIntersect	.\openb3d\src\functions.cpp	/^int MeshesIntersect(Mesh* mesh1,Mesh* mesh2){$/;"	f
MeshesIntersect	.\openb3d\src\mesh.cpp	/^int Mesh::MeshesIntersect(Mesh* mesh2){$/;"	f	class:Mesh
MetaballsField	.\openb3d\src\isosurface.cpp	/^float MetaballsField (float x, float y, float z){$/;"	f
Mid	.\openb3d\src\string_helper.cpp	/^string Mid(string s,int offset,int characters){$/;"	f
MiddlePoint	.\openb3d\src\isosurface.cpp	/^float Fluid::MiddlePoint (float A, float B, float C, float D){$/;"	f	class:Fluid
MiddlePoint	.\openb3d\src\voxterrain.cpp	/^float VoxelTerrain::MiddlePoint (float A, float B, float C, float D){$/;"	f	class:VoxelTerrain
ModifyGeosphere	.\openb3d\src\functions.cpp	/^void ModifyGeosphere(Geosphere* geo, int x, int z, float new_height){$/;"	f
ModifyGeosphere	.\openb3d\src\geosphere.cpp	/^void Geosphere::ModifyGeosphere (int x, int y, float new_height){$/;"	f	class:Geosphere
ModifyTerrain	.\openb3d\src\functions.cpp	/^void ModifyTerrain(Terrain* terr, int x, int z, float new_height){$/;"	f
ModifyTerrain	.\openb3d\src\terrain.cpp	/^void Terrain::ModifyTerrain (int x, int z, float new_height){$/;"	f	class:Terrain
MoveEntity	.\openb3d\src\entity.cpp	/^void Entity::MoveEntity(float mx,float my,float mz){$/;"	f	class:Entity
MoveEntity	.\openb3d\src\functions.cpp	/^void MoveEntity(Entity* ent,float x,float y,float z){$/;"	f
MovedTris	.\openb3d\src\3ds.cpp	/^list<int>      MovedTris;$/;"	m	namespace:load3ds	file:
MovedTris	.\openb3d\src\x.cpp	/^list<int>      MovedTris;$/;"	m	namespace:loadX	file:
Multiply	.\openb3d\src\matrix.h	/^	void Multiply(Matrix &mat){$/;"	f	class:Matrix
Multiply2	.\openb3d\src\matrix.h	/^	void Multiply2(Matrix &mat){$/;"	f	class:Matrix
NODE	.\openb3d\src\model.cpp	/^const int NODE=3;$/;"	v
NULL	.\openb3d\src\tree.cpp	4;"	d	file:
Name	.\openb3d\src\shadermat.h	/^	string Name;$/;"	m	class:Sampler
NameEntity	.\openb3d\src\entity.cpp	/^void Entity::NameEntity(string e_name){$/;"	f	class:Entity
NameEntity	.\openb3d\src\functions.cpp	/^void NameEntity(Entity* ent,char* name){$/;"	f
New3ds	.\openb3d\src\3ds.cpp	/^void New3ds(){$/;"	f	namespace:load3ds
NewTag	.\openb3d\src\model.cpp	/^int NewTag(string tag){$/;"	f
Node	.\openb3d\src\tree.h	/^		Node():left(0),right(0){}$/;"	f	struct:MeshCollider::Node
Node	.\openb3d\src\tree.h	/^	struct Node{$/;"	s	class:MeshCollider
NormalsMap	.\openb3d\src\geosphere.h	/^	float* NormalsMap;$/;"	m	class:Geosphere
NormalsMap	.\openb3d\src\terrain.h	/^	float* NormalsMap;$/;"	m	class:Terrain
OCTREECHILD_class	.\data.cpp	/^const int OCTREECHILD_class=	30;$/;"	v
OCTREE_H	.\openb3d\src\octree.h	2;"	d
OCTREE_class	.\data.cpp	/^const int OCTREE_class=			29; \/\/ octree.h$/;"	v
OPENB3D_OPENB3DLIB_OPENB3DLIB_BMX_DEBUG_WIN32_X64_H	.\.bmx\openb3dlib.bmx.debug.win32.x64.h	2;"	d
OPENB3D_OPENB3DLIB_OPENB3DLIB_BMX_DEBUG_WIN32_X86_H	.\.bmx\openb3dlib.bmx.debug.win32.x86.h	2;"	d
OPENB3D_OPENB3DLIB_OPENB3DLIB_BMX_RELEASE_WIN32_X64_H	.\.bmx\openb3dlib.bmx.release.win32.x64.h	2;"	d
OPENB3D_OPENB3DLIB_OPENB3DLIB_BMX_RELEASE_WIN32_X86_H	.\.bmx\openb3dlib.bmx.release.win32.x86.h	2;"	d
OPENB3D_OPENB3DLIB_SOURCE_BMX_DEBUG_WIN32_X64_H	.\.bmx\source.bmx.debug.win32.x64.h	2;"	d
OPENB3D_OPENB3DLIB_SOURCE_BMX_DEBUG_WIN32_X86_H	.\.bmx\source.bmx.debug.win32.x86.h	2;"	d
OPENB3D_OPENB3DLIB_SOURCE_BMX_RELEASE_WIN32_X64_H	.\.bmx\source.bmx.release.win32.x64.h	2;"	d
OPENB3D_OPENB3DLIB_SOURCE_BMX_RELEASE_WIN32_X86_H	.\.bmx\source.bmx.release.win32.x86.h	2;"	d
OcTree	.\openb3d\src\octree.h	/^class OcTree : public Terrain{$/;"	c
OcTreeChild	.\openb3d\src\octree.h	/^class OcTreeChild{$/;"	c
OctreeBlock	.\openb3d\src\functions.cpp	/^void OctreeBlock(OcTree* octree, Mesh* mesh, int level, float X, float Y, float Z, float Near=0.0, float Far=1000.0){$/;"	f
OctreeBlock	.\openb3d\src\octree.cpp	/^void OcTree::OctreeBlock(Mesh* mesh, int level, float X, float Y, float Z, float Near, float Far){$/;"	f	class:OcTree
OctreeMesh	.\openb3d\src\functions.cpp	/^void OctreeMesh(OcTree* octree, Mesh* mesh, int level, float X, float Y, float Z, float Near=0.0, float Far=1000.0){$/;"	f
OctreeMesh	.\openb3d\src\octree.cpp	/^void OcTree::OctreeMesh(Mesh* mesh, int level, float X, float Y, float Z, float Near, float Far){$/;"	f	class:OcTree
Overwrite	.\openb3d\src\matrix.h	/^	void Overwrite(Matrix &mat){$/;"	f	class:Matrix
P1	.\openb3d\src\physics.h	/^	Entity* P1;$/;"	m	class:Constraint
P2	.\openb3d\src\physics.h	/^	Entity* P2;$/;"	m	class:Constraint
PARTICLEBATCH_class	.\data.cpp	/^const int PARTICLEBATCH_class=	31; \/\/ particle.h$/;"	v
PARTICLEEMITTER_class	.\data.cpp	/^const int PARTICLEEMITTER_class=32;$/;"	v
PARTICLE_H	.\openb3d\src\particle.h	2;"	d
PHYSICS_H	.\openb3d\src\physics.h	2;"	d
PI	.\openb3d\src\geom.h	/^const float PI=3.14159265359f;		\/\/180 degrees$/;"	v
PICK_H	.\openb3d\src\pick.h	11;"	d
PICK_class	.\data.cpp	/^const int PICK_class=			35;$/;"	v
PICK_ent_list	.\data.cpp	/^const int PICK_ent_list=		1;$/;"	v
PICK_picked_ent	.\data.cpp	/^const int PICK_picked_ent=		9;$/;"	v
PICK_picked_nx	.\data.cpp	/^const int PICK_picked_nx=		5;$/;"	v
PICK_picked_ny	.\data.cpp	/^const int PICK_picked_ny=		6;$/;"	v
PICK_picked_nz	.\data.cpp	/^const int PICK_picked_nz=		7;$/;"	v
PICK_picked_surface	.\data.cpp	/^const int PICK_picked_surface=	10;$/;"	v
PICK_picked_time	.\data.cpp	/^const int PICK_picked_time=		8;$/;"	v
PICK_picked_triangle	.\data.cpp	/^const int PICK_picked_triangle=	11;$/;"	v
PICK_picked_x	.\data.cpp	/^const int PICK_picked_x=		2;$/;"	v
PICK_picked_y	.\data.cpp	/^const int PICK_picked_y=		3;$/;"	v
PICK_picked_z	.\data.cpp	/^const int PICK_picked_z=		4;$/;"	v
PIVOT_H	.\openb3d\src\pivot.h	11;"	d
PIVOT_class	.\data.cpp	/^const int PIVOT_class=			36;$/;"	v
PLANE_class	.\data.cpp	/^const int PLANE_class=			15;$/;"	v
PNG_TYPE	.\openb3d\src\stb_image.c	2418;"	d	file:
POINT_IN_TRI	.\openb3d\src\collidetri.c	123;"	d	file:
PROGRAMOBJECT_class	.\data.cpp	/^const int PROGRAMOBJECT_class=	43;$/;"	v
PROJECT_H	.\openb3d\src\project.h	22;"	d
PaintEntity	.\openb3d\src\entity.cpp	/^void Entity::PaintEntity(Brush& bru,int recursive){$/;"	f	class:Entity
PaintEntity	.\openb3d\src\functions.cpp	/^void PaintEntity(Entity* ent,Brush* brush){$/;"	f
PaintMesh	.\openb3d\src\functions.cpp	/^void PaintMesh(Mesh* mesh,Brush* brush){$/;"	f
PaintMesh	.\openb3d\src\mesh.cpp	/^void Mesh::PaintMesh(Brush* bru){$/;"	f	class:Mesh
PaintSurface	.\openb3d\src\functions.cpp	/^void PaintSurface(Surface* surf,Brush* brush){$/;"	f
PaintSurface	.\openb3d\src\surface.cpp	/^void Surface::PaintSurface(Brush* bru){$/;"	f	class:Surface
Parameters	.\openb3d\src\shadermat.h	/^	vector<ShaderData> Parameters;$/;"	m	class:Shader
Parent	.\openb3d\src\shadow.h	/^	Mesh* Parent;$/;"	m	class:ShadowObject
ParticleBatch	.\openb3d\src\particle.h	/^	ParticleBatch(){$/;"	f	class:ParticleBatch
ParticleBatch	.\openb3d\src\particle.h	/^class ParticleBatch: public Mesh{$/;"	c
ParticleColor	.\openb3d\src\functions.cpp	/^void ParticleColor(Sprite* sprite, float r, float g, float b, float a){$/;"	f
ParticleData	.\openb3d\src\particle.h	/^	struct ParticleData{$/;"	s	class:ParticleEmitter
ParticleEmitter	.\openb3d\src\particle.h	/^	ParticleEmitter(){$/;"	f	class:ParticleEmitter
ParticleEmitter	.\openb3d\src\particle.h	/^class ParticleEmitter: public Entity{$/;"	c
ParticleTrail	.\openb3d\src\functions.cpp	/^void ParticleTrail(Sprite* sprite,int length){$/;"	f
ParticleVector	.\openb3d\src\functions.cpp	/^void ParticleVector(Sprite* sprite, float x, float y, float z){$/;"	f
PeekByte	.\openb3d\src\bank.h	/^	char PeekByte(int offset){$/;"	f	class:Bank
PeekFloat	.\openb3d\src\bank.h	/^	float PeekFloat(int offset){$/;"	f	class:Bank
PeekInt	.\openb3d\src\bank.h	/^	int PeekInt(int offset){$/;"	f	class:Bank
PeekShort	.\openb3d\src\bank.h	/^	short PeekShort(int offset){$/;"	f	class:Bank
Pick	.\openb3d\src\pick.h	/^	Pick(){};$/;"	f	class:Pick
Pick	.\openb3d\src\pick.h	/^class Pick{$/;"	c
PickMain	.\methods.cpp	/^Entity* PickMain( float ax,float ay,float az,float bx,float by,float bz,float radius ){$/;"	f
PickMain	.\openb3d\src\pick.cpp	/^Entity* Pick::PickMain(float ax,float ay,float az,float bx,float by,float bz,float radius){$/;"	f	class:Pick
PickedEntity	.\openb3d\src\functions.cpp	/^Entity* PickedEntity(){$/;"	f
PickedEntity	.\openb3d\src\pick.cpp	/^Entity* Pick::PickedEntity(){$/;"	f	class:Pick
PickedNX	.\openb3d\src\functions.cpp	/^float PickedNX(){$/;"	f
PickedNX	.\openb3d\src\pick.cpp	/^float Pick::PickedNX(){$/;"	f	class:Pick
PickedNY	.\openb3d\src\functions.cpp	/^float PickedNY(){$/;"	f
PickedNY	.\openb3d\src\pick.cpp	/^float Pick::PickedNY(){$/;"	f	class:Pick
PickedNZ	.\openb3d\src\functions.cpp	/^float PickedNZ(){$/;"	f
PickedNZ	.\openb3d\src\pick.cpp	/^float Pick::PickedNZ(){$/;"	f	class:Pick
PickedSurface	.\openb3d\src\functions.cpp	/^Surface* PickedSurface(){$/;"	f
PickedSurface	.\openb3d\src\pick.cpp	/^Surface* Pick::PickedSurface(){$/;"	f	class:Pick
PickedTime	.\openb3d\src\functions.cpp	/^float PickedTime(){$/;"	f
PickedTime	.\openb3d\src\pick.cpp	/^float Pick::PickedTime(){$/;"	f	class:Pick
PickedTriangle	.\openb3d\src\functions.cpp	/^int PickedTriangle(){$/;"	f
PickedTriangle	.\openb3d\src\pick.cpp	/^int Pick::PickedTriangle(){$/;"	f	class:Pick
PickedX	.\openb3d\src\functions.cpp	/^float PickedX(){$/;"	f
PickedX	.\openb3d\src\pick.cpp	/^float Pick::PickedX(){$/;"	f	class:Pick
PickedY	.\openb3d\src\functions.cpp	/^float PickedY(){$/;"	f
PickedY	.\openb3d\src\pick.cpp	/^float Pick::PickedY(){$/;"	f	class:Pick
PickedZ	.\openb3d\src\functions.cpp	/^float PickedZ(){$/;"	f
PickedZ	.\openb3d\src\pick.cpp	/^float Pick::PickedZ(){$/;"	f	class:Pick
Pivot	.\openb3d\src\pivot.h	/^	Pivot(){};$/;"	f	class:Pivot
Pivot	.\openb3d\src\pivot.h	/^class Pivot : public Entity{$/;"	c
Plane	.\openb3d\src\geom.h	/^	Plane( const Vector &n,float d ):n(n),d(d){$/;"	f	class:Plane
Plane	.\openb3d\src\geom.h	/^	Plane( const Vector &p,const Vector &n ):n(n),d(-n.dot(p)){$/;"	f	class:Plane
Plane	.\openb3d\src\geom.h	/^	Plane( const Vector &v0,const Vector &v1,const Vector &v2 ){$/;"	f	class:Plane
Plane	.\openb3d\src\geom.h	/^	Plane():d(0){$/;"	f	class:Plane
Plane	.\openb3d\src\geom.h	/^class Plane{$/;"	c
PointDistanceToLine	.\openb3d\src\csg.cpp	/^float PointDistanceToLine(float ax, float ay, float az, float bx, float by, float bz, float px, float py, float pz){$/;"	f	namespace:CSG
PointEntity	.\openb3d\src\entity.cpp	/^void Entity::PointEntity(Entity* target_ent,float roll){$/;"	f	class:Entity
PointEntity	.\openb3d\src\functions.cpp	/^void PointEntity(Entity* ent,Entity* target_ent,float roll){$/;"	f
Points	.\openb3d\src\physics.h	/^	Entity* Points[4];$/;"	m	class:RigidBody
PokeByte	.\openb3d\src\bank.h	/^	void PokeByte(int offset,char c){$/;"	f	class:Bank
PokeFloat	.\openb3d\src\bank.h	/^	void PokeFloat(int offset,float f){$/;"	f	class:Bank
PokeInt	.\openb3d\src\bank.h	/^	void PokeInt(int offset,int i){$/;"	f	class:Bank
PokeShort	.\openb3d\src\bank.h	/^	void PokeShort(int offset,short s){$/;"	f	class:Bank
PositionEntities	.\openb3d\src\collision2.cpp	/^int PositionEntities(int update_old,int add_to_new){$/;"	f
PositionEntity	.\openb3d\src\entity.cpp	/^void Entity::PositionEntity(float x,float y,float z,int global){$/;"	f	class:Entity
PositionEntity	.\openb3d\src\functions.cpp	/^void PositionEntity(Entity* ent,float x,float y,float z,bool glob){$/;"	f
PositionMesh	.\openb3d\src\functions.cpp	/^void PositionMesh(Mesh* mesh,float px,float py,float pz){$/;"	f
PositionMesh	.\openb3d\src\mesh.cpp	/^void Mesh::PositionMesh(float px,float py,float pz){$/;"	f	class:Mesh
PositionTexture	.\openb3d\src\functions.cpp	/^void PositionTexture(Texture* tex,float u_pos,float v_pos){$/;"	f
PositionTexture	.\openb3d\src\texture.cpp	/^void Texture::PositionTexture(float u_p,float v_p){$/;"	f	class:Texture
Program	.\openb3d\src\shaderobject.h	/^	int Program;		\/\/ The ProgramObject$/;"	m	class:ProgramObject
ProgramAttriBegin	.\openb3d\src\material.cpp	/^void Shader::ProgramAttriBegin(){$/;"	f	class:Shader
ProgramAttriEnd	.\openb3d\src\material.cpp	/^void Shader::ProgramAttriEnd(){$/;"	f	class:Shader
ProgramObject	.\openb3d\src\shaderobject.h	/^class ProgramObject{$/;"	c
ProgramObjectList	.\openb3d\src\material.cpp	/^list<ProgramObject*> ProgramObject::ProgramObjectList;$/;"	m	class:ProgramObject	file:
ProgramObjectList	.\openb3d\src\shaderobject.h	/^	static list<ProgramObject*> ProgramObjectList;$/;"	m	class:ProgramObject
ProjectedX	.\openb3d\src\camera.cpp	/^float Camera::ProjectedX(){$/;"	f	class:Camera
ProjectedX	.\openb3d\src\functions.cpp	/^float ProjectedX(){$/;"	f
ProjectedY	.\openb3d\src\camera.cpp	/^float Camera::ProjectedY(){$/;"	f	class:Camera
ProjectedY	.\openb3d\src\functions.cpp	/^float ProjectedY(){$/;"	f
ProjectedZ	.\openb3d\src\camera.cpp	/^float Camera::ProjectedZ(){$/;"	f	class:Camera
ProjectedZ	.\openb3d\src\functions.cpp	/^float ProjectedZ(){$/;"	f
QUARTERPI	.\openb3d\src\geom.h	/^const float QUARTERPI=PI*.25f;		\/\/45  degrees$/;"	v
QUATERNION_H	.\openb3d\src\quaternion.h	11;"	d
QUATERNION_class	.\data.cpp	/^const int QUATERNION_class=		37;$/;"	v
QUAT_class	.\data.cpp	/^const int QUAT_class=			16;$/;"	v
Quat	.\openb3d\src\geom.h	/^	Quat( float w,const Vector &v ):w(w),v(v){$/;"	f	struct:Quat
Quat	.\openb3d\src\geom.h	/^	Quat():w(1){$/;"	f	struct:Quat
Quat	.\openb3d\src\geom.h	/^struct Quat{$/;"	s
QuatToEuler	.\openb3d\src\quaternion.cpp	/^void QuatToEuler(float w,float x,float y,float z,float &pitch,float &yaw,float &roll){$/;"	f
QuatToMat	.\openb3d\src\quaternion.cpp	/^void QuatToMat(float w,float x,float y,float z,Matrix& mat){$/;"	f
Quaternion	.\openb3d\src\quaternion.h	/^class Quaternion{$/;"	c
Quaternion_FromAngleAxis	.\openb3d\src\matrix.cpp	/^void Quaternion_FromAngleAxis( float angle, float ax, float ay, float az, float &rx, float &ry, float &rz, float &rw){$/;"	f
Quaternion_MultiplyQuat	.\openb3d\src\matrix.cpp	/^void Quaternion_MultiplyQuat( float x1, float y1, float z1, float w1, float x2, float y2, float z2, float w2, float &rx, float &ry, float &rz, float &rw ){$/;"	f
QuickCheck	.\openb3d\src\collision2.cpp	/^int QuickCheck(Entity& ent,Entity& ent2){$/;"	f
RAD_TO_DEG	.\openb3d\src\maths_helper.h	23;"	d
RESTART	.\openb3d\src\stb_image.c	1362;"	d	file:
RIGIDBODY_class	.\data.cpp	/^const int RIGIDBODY_class=		34;$/;"	v
ROAM_LMAX	.\openb3d\src\terrain.h	/^const int ROAM_LMAX = 20; 		\/\/<-----------terrain detail here	$/;"	v
Ray	.\openb3d\src\geosphere.cpp	/^static Line Ray;$/;"	v	file:
Ray	.\openb3d\src\octree.cpp	/^static Line Ray;$/;"	v	file:
Ray	.\openb3d\src\terrain.cpp	/^static Line Ray;$/;"	v	file:
Ray_Intersect_Mesh_Max	.\openb3d\src\csg.cpp	/^float Ray_Intersect_Mesh_Max(Mesh* mesh, float Px, float Py, float Pz, float Dx, float Dy, float Dz, bool Extend_To_Infinity=true, bool Cull_Backfaces=false, bool Flip_Mesh=false, bool Method=1){$/;"	f	namespace:CSG
Ray_Intersect_Triangle	.\openb3d\src\csg.cpp	/^bool Ray_Intersect_Triangle(float Px, float  Py, float  Pz, float  Dx, float  Dy, float Dz, float V0x, float V0y, float V0z,$/;"	f	namespace:CSG
ReadBrushBlock	.\openb3d\src\3ds.cpp	/^void ReadBrushBlock(){$/;"	f	namespace:load3ds
ReadByte	.\openb3d\src\file.cpp	/^char File::ReadByte(){$/;"	f	class:File
ReadCString	.\openb3d\src\3ds.cpp	/^string ReadCString(){$/;"	f	namespace:load3ds
ReadChunk	.\openb3d\src\3ds.cpp	/^void ReadChunk(){$/;"	f	namespace:load3ds
ReadFaceList	.\openb3d\src\3ds.cpp	/^void ReadFaceList(){$/;"	f	namespace:load3ds
ReadFaceMatList	.\openb3d\src\3ds.cpp	/^void ReadFaceMatList(){$/;"	f	namespace:load3ds
ReadFile	.\openb3d\src\file.cpp	/^File* File::ReadFile(string filename){$/;"	f	class:File
ReadFloat	.\openb3d\src\file.cpp	/^float File::ReadFloat(){$/;"	f	class:File
ReadInt	.\openb3d\src\file.cpp	/^int File::ReadInt(){$/;"	f	class:File
ReadLine	.\openb3d\src\file.cpp	/^string File::ReadLine(){$/;"	f	class:File
ReadLong	.\openb3d\src\file.cpp	/^long File::ReadLong(){$/;"	f	class:File
ReadMap	.\openb3d\src\3ds.cpp	/^void ReadMap(int Layer){$/;"	f	namespace:load3ds
ReadPercent	.\openb3d\src\3ds.cpp	/^unsigned char ReadPercent(int Format){$/;"	f	namespace:load3ds
ReadRGB	.\openb3d\src\3ds.cpp	/^void ReadRGB(int Format, unsigned char &Red, unsigned char &Green, unsigned char &Blue){$/;"	f	namespace:load3ds
ReadResourceFile	.\openb3d\src\file.cpp	/^File* File::ReadResourceFile(string filename){$/;"	f	class:File
ReadShort	.\openb3d\src\file.cpp	/^short File::ReadShort(){$/;"	f	class:File
ReadString	.\openb3d\src\file.cpp	/^string File::ReadString(){$/;"	f	class:File
ReadTag	.\openb3d\src\model.cpp	/^string ReadTag(File* file){$/;"	f
ReadTexCoords	.\openb3d\src\3ds.cpp	/^void ReadTexCoords(){$/;"	f	namespace:load3ds
ReadTriMesh	.\openb3d\src\3ds.cpp	/^void ReadTriMesh(){$/;"	f	namespace:load3ds
ReadVertexList	.\openb3d\src\3ds.cpp	/^void ReadVertexList(){$/;"	f	namespace:load3ds
RebuildMesh	.\openb3d\src\csg.cpp	/^void RebuildMesh(Mesh* mesh, Mesh* mesh2, int invert = false, int keepshared = false){$/;"	f	namespace:CSG
RecreateGeoROAM	.\openb3d\src\geosphere.cpp	/^void Geosphere::RecreateGeoROAM(){$/;"	f	class:Geosphere
RecreateOctree	.\openb3d\src\voxterrain.cpp	/^void VoxelTerrain::RecreateOctree(){$/;"	f	class:VoxelTerrain
RecreateROAM	.\methods.cpp	/^void RecreateROAM( Terrain* obj ){$/;"	f
RecreateROAM	.\openb3d\src\terrain.cpp	/^void Terrain::RecreateROAM(){$/;"	f	class:Terrain
RefreshTypeMap	.\openb3d\src\material.cpp	/^void ProgramObject::RefreshTypeMap(){$/;"	f	class:ProgramObject
RemoveShadowfromMesh	.\methods.cpp	/^void RemoveShadowfromMesh( ShadowObject* obj,Mesh* M ){$/;"	f
RemoveShadowfromMesh	.\openb3d\src\shadow.cpp	/^void ShadowObject::RemoveShadowfromMesh(Mesh* M) {$/;"	f	class:ShadowObject
RemoveTri	.\methods.cpp	/^void RemoveTri( Surface* obj,int tri ){$/;"	f
RemoveTri	.\openb3d\src\surface.cpp	/^void Surface::RemoveTri(int tri){$/;"	f	class:Surface
Render	.\openb3d\src\camera.cpp	/^void Camera::Render(){$/;"	f	class:Camera
Render	.\openb3d\src\entity.h	/^	virtual void Render() {};$/;"	f	class:Entity
Render	.\openb3d\src\isosurface.cpp	/^void Fluid::Render(){$/;"	f	class:Fluid
Render	.\openb3d\src\mesh.cpp	/^void Mesh::Render(){$/;"	f	class:Mesh
Render	.\openb3d\src\particle.cpp	/^void ParticleBatch::Render(){$/;"	f	class:ParticleBatch
Render	.\openb3d\src\shadow.h	/^	char Render;$/;"	m	class:ShadowObject
Render	.\openb3d\src\voxel.cpp	/^void VoxelSprite::Render(){$/;"	f	class:VoxelSprite
RenderChild	.\openb3d\src\octree.cpp	/^void OcTreeChild::RenderChild(){$/;"	f	class:OcTreeChild
RenderListAdd	.\methods.cpp	/^void RenderListAdd( Camera* obj,Mesh* mesh ){$/;"	f
RenderListAdd	.\openb3d\src\camera.cpp	/^void Camera::RenderListAdd(Mesh* mesh){$/;"	f	class:Camera
RenderVolume	.\methods.cpp	/^void RenderVolume(){$/;"	f
RenderVolume	.\openb3d\src\shadow.cpp	/^void ShadowObject::RenderVolume(){$/;"	f	class:ShadowObject
RenderWorld	.\openb3d\src\functions.cpp	/^void RenderWorld(){$/;"	f
RenderWorld	.\openb3d\src\global.cpp	/^void Global::RenderWorld(){$/;"	f	class:Global
RenderedVolumes	.\openb3d\src\shadow.h	/^	static int RenderedVolumes;$/;"	m	class:ShadowObject
Rendered_Blocks	.\openb3d\src\octree.h	/^	list<Mesh*> Rendered_Blocks;$/;"	m	class:OcTree
Rendered_Meshes	.\openb3d\src\octree.h	/^	list<Mesh*> Rendered_Meshes;$/;"	m	class:OcTree
RepeatMesh	.\openb3d\src\functions.cpp	/^Mesh* RepeatMesh(Mesh* mesh,Entity* parent){$/;"	f
RepeatMesh	.\openb3d\src\mesh.cpp	/^Mesh* Mesh::RepeatMesh(Entity* parent_ent){$/;"	f	class:Mesh
Replace	.\openb3d\src\string_helper.cpp	/^string Replace(string s,string find_s,string replace_s){$/;"	f
ResetBuffers	.\openb3d\src\isosurface.cpp	/^void Fluid::ResetBuffers(){$/;"	f	class:Fluid
ResetEntity	.\openb3d\src\entity.cpp	/^void Entity::ResetEntity(){$/;"	f	class:Entity
ResetEntity	.\openb3d\src\functions.cpp	/^void ResetEntity(Entity* ent){$/;"	f
ResetShadow	.\openb3d\src\functions.cpp	/^void ResetShadow(ShadowObject* shad){$/;"	f
ResizeBank	.\openb3d\src\bank.h	/^	void ResizeBank(int size){$/;"	f	class:Bank
ResourceFilePath	.\openb3d\src\file.cpp	/^string File::ResourceFilePath(string filename){$/;"	f	class:File
Right	.\openb3d\src\string_helper.cpp	/^string Right(string s,unsigned int length){$/;"	f
RigidBody	.\openb3d\src\physics.h	/^class RigidBody{$/;"	c
Rotate	.\openb3d\src\matrix.h	/^	void Rotate(float rx,float ry,float rz){$/;"	f	class:Matrix
RotateEntity	.\openb3d\src\entity.cpp	/^void Entity::RotateEntity(float x,float y,float z,int global){$/;"	f	class:Entity
RotateEntity	.\openb3d\src\functions.cpp	/^void RotateEntity(Entity* ent,float x,float y,float z,bool glob){$/;"	f
RotateMesh	.\openb3d\src\functions.cpp	/^void RotateMesh(Mesh* mesh,float pitch,float yaw,float roll){$/;"	f
RotateMesh	.\openb3d\src\mesh.cpp	/^void Mesh::RotateMesh(float pitch,float yaw,float roll){$/;"	f	class:Mesh
RotatePitch	.\openb3d\src\matrix.h	/^	void RotatePitch(float ang){$/;"	f	class:Matrix
RotateRoll	.\openb3d\src\matrix.h	/^	void RotateRoll(float ang){$/;"	f	class:Matrix
RotateSprite	.\openb3d\src\functions.cpp	/^void RotateSprite(Sprite* sprite,float ang){$/;"	f
RotateSprite	.\openb3d\src\sprite.cpp	/^void Sprite::RotateSprite(float ang){$/;"	f	class:Sprite
RotateTexture	.\openb3d\src\functions.cpp	/^void RotateTexture(Texture* tex,float ang){$/;"	f
RotateTexture	.\openb3d\src\texture.cpp	/^void Texture::RotateTexture(float ang){$/;"	f	class:Texture
RotateYaw	.\openb3d\src\matrix.h	/^	void RotateYaw(float ang){$/;"	f	class:Matrix
SAMPLER_class	.\data.cpp	/^const int SAMPLER_class=		39;$/;"	v
SCAN_header	.\openb3d\src\stb_image.c	/^   SCAN_header$/;"	e	enum:__anon10	file:
SCAN_load	.\openb3d\src\stb_image.c	/^   SCAN_load=0,$/;"	e	enum:__anon10	file:
SCAN_type	.\openb3d\src\stb_image.c	/^   SCAN_type,$/;"	e	enum:__anon10	file:
SHADERDATA_class	.\data.cpp	/^const int SHADERDATA_class=		38; \/\/ shadermat.h$/;"	v
SHADEROBJECT_class	.\data.cpp	/^const int SHADEROBJECT_class=	42; \/\/ shaderobject.h$/;"	v
SHADER_MAT_H	.\openb3d\src\shadermat.h	2;"	d
SHADER_class	.\data.cpp	/^const int SHADER_class=			41;$/;"	v
SHADOWOBJECT_Parent	.\data.cpp	/^const int SHADOWOBJECT_Parent=			2;$/;"	v
SHADOWOBJECT_Render	.\data.cpp	/^const int SHADOWOBJECT_Render=			6;$/;"	v
SHADOWOBJECT_ShadowAlpha	.\data.cpp	/^const int SHADOWOBJECT_ShadowAlpha=		19;$/;"	v
SHADOWOBJECT_ShadowBlue	.\data.cpp	/^const int SHADOWOBJECT_ShadowBlue=		18;$/;"	v
SHADOWOBJECT_ShadowGreen	.\data.cpp	/^const int SHADOWOBJECT_ShadowGreen=		17;$/;"	v
SHADOWOBJECT_ShadowMesh	.\data.cpp	/^const int SHADOWOBJECT_ShadowMesh=		4;$/;"	v
SHADOWOBJECT_ShadowRed	.\data.cpp	/^const int SHADOWOBJECT_ShadowRed=		16;$/;"	v
SHADOWOBJECT_ShadowVolume	.\data.cpp	/^const int SHADOWOBJECT_ShadowVolume=	5;$/;"	v
SHADOWOBJECT_Static	.\data.cpp	/^const int SHADOWOBJECT_Static=			7;$/;"	v
SHADOWOBJECT_VCreated	.\data.cpp	/^const int SHADOWOBJECT_VCreated=		8;$/;"	v
SHADOWOBJECT_VolumeLength	.\data.cpp	/^const int SHADOWOBJECT_VolumeLength=	9;$/;"	v
SHADOWOBJECT_class	.\data.cpp	/^const int SHADOWOBJECT_class=	46;$/;"	v
SHADOWOBJECT_cnt_tris	.\data.cpp	/^const int SHADOWOBJECT_cnt_tris=		3;$/;"	v
SHADOWOBJECT_light_x	.\data.cpp	/^const int SHADOWOBJECT_light_x=			12;$/;"	v
SHADOWOBJECT_light_y	.\data.cpp	/^const int SHADOWOBJECT_light_y=			13;$/;"	v
SHADOWOBJECT_light_z	.\data.cpp	/^const int SHADOWOBJECT_light_z=			14;$/;"	v
SHADOWOBJECT_midStencilVal	.\data.cpp	/^const int SHADOWOBJECT_midStencilVal=	15;$/;"	v
SHADOWOBJECT_parallel	.\data.cpp	/^const int SHADOWOBJECT_parallel=		11;$/;"	v
SHADOWOBJECT_shadow_list	.\data.cpp	/^const int SHADOWOBJECT_shadow_list=		1;$/;"	v
SHADOWOBJECT_top_caps	.\data.cpp	/^const int SHADOWOBJECT_top_caps=		10;$/;"	v
SHADOWTRIANGLE_class	.\data.cpp	/^const int SHADOWTRIANGLE_class=	44; \/\/ shadow.h$/;"	v
SHADOW_H	.\openb3d\src\shadow.h	9;"	d
SOF	.\openb3d\src\stb_image.c	1620;"	d	file:
SOI	.\openb3d\src\stb_image.c	1618;"	d	file:
SORT	.\openb3d\src\collidetri.c	40;"	d	file:
SOS	.\openb3d\src\stb_image.c	1621;"	d	file:
SPRITEBATCH_class	.\data.cpp	/^const int SPRITEBATCH_class=	48;$/;"	v
SPRITE_BATCH_H	.\openb3d\src\sprite_batch.h	11;"	d
SPRITE_H	.\openb3d\src\sprite.h	11;"	d
SPRITE_angle	.\data.cpp	/^const int SPRITE_angle=			1;$/;"	v
SPRITE_class	.\data.cpp	/^const int SPRITE_class=			47;$/;"	v
SPRITE_handle_x	.\data.cpp	/^const int SPRITE_handle_x=		4;$/;"	v
SPRITE_handle_y	.\data.cpp	/^const int SPRITE_handle_y=		5; $/;"	v
SPRITE_render_mode	.\data.cpp	/^const int SPRITE_render_mode=	7;$/;"	v
SPRITE_scale_x	.\data.cpp	/^const int SPRITE_scale_x=		2;$/;"	v
SPRITE_scale_y	.\data.cpp	/^const int SPRITE_scale_y=		3;$/;"	v
SPRITE_view_mode	.\data.cpp	/^const int SPRITE_view_mode=		6;$/;"	v
STBI_HAS_LROTL	.\openb3d\src\stb_image.c	391;"	d	file:
STBI_INCLUDE_STB_IMAGE_H	.\openb3d\src\stb_image.c	68;"	d	file:
STBI_INCLUDE_STB_IMAGE_H	.\openb3d\src\stb_image.h	2;"	d
STBI_NOTUSED	.\openb3d\src\stb_image.c	385;"	d	file:
STBI_NOTUSED	.\openb3d\src\stb_image.c	387;"	d	file:
STBI_VERSION	.\openb3d\src\stb_image.c	200;"	d	file:
STBI_VERSION	.\openb3d\src\stb_image.h	133;"	d
STBI_default	.\openb3d\src\stb_image.c	/^   STBI_default = 0, \/\/ only used for req_comp$/;"	e	enum:__anon7	file:
STBI_default	.\openb3d\src\stb_image.h	/^   STBI_default = 0, \/\/ only used for req_comp$/;"	e	enum:__anon21
STBI_grey	.\openb3d\src\stb_image.c	/^   STBI_grey       = 1,$/;"	e	enum:__anon7	file:
STBI_grey	.\openb3d\src\stb_image.h	/^   STBI_grey       = 1,$/;"	e	enum:__anon21
STBI_grey_alpha	.\openb3d\src\stb_image.c	/^   STBI_grey_alpha = 2,$/;"	e	enum:__anon7	file:
STBI_grey_alpha	.\openb3d\src\stb_image.h	/^   STBI_grey_alpha = 2,$/;"	e	enum:__anon21
STBI_rgb	.\openb3d\src\stb_image.c	/^   STBI_rgb        = 3,$/;"	e	enum:__anon7	file:
STBI_rgb	.\openb3d\src\stb_image.h	/^   STBI_rgb        = 3,$/;"	e	enum:__anon21
STBI_rgb_alpha	.\openb3d\src\stb_image.c	/^   STBI_rgb_alpha  = 4$/;"	e	enum:__anon7	file:
STBI_rgb_alpha	.\openb3d\src\stb_image.h	/^   STBI_rgb_alpha  = 4$/;"	e	enum:__anon21
STENCIL_H	.\openb3d\src\stencil.h	9;"	d
STENCIL_class	.\data.cpp	/^const int STENCIL_class=		49;$/;"	v
STRING_HELPER_H	.\openb3d\src\string_helper.h	11;"	d
SUB	.\openb3d\src\collidetri.c	34;"	d	file:
SURFACE_H	.\openb3d\src\surface.h	11;"	d
SURFACE_ShaderMat	.\data.cpp	/^const int SURFACE_ShaderMat=		18;$/;"	v
SURFACE_alpha_enable	.\data.cpp	/^const int SURFACE_alpha_enable=		26;	$/;"	v
SURFACE_brush	.\data.cpp	/^const int SURFACE_brush=			17;$/;"	v
SURFACE_class	.\data.cpp	/^const int SURFACE_class=		50;$/;"	v
SURFACE_no_tris	.\data.cpp	/^const int SURFACE_no_tris=			2;$/;"	v
SURFACE_no_verts	.\data.cpp	/^const int SURFACE_no_verts=			1;$/;"	v
SURFACE_reset_vbo	.\data.cpp	/^const int SURFACE_reset_vbo=		25;$/;"	v
SURFACE_tri_array_size	.\data.cpp	/^const int SURFACE_tri_array_size=	21;$/;"	v
SURFACE_tris	.\data.cpp	/^const int SURFACE_tris=				8;$/;"	v
SURFACE_vbo_enabled	.\data.cpp	/^const int SURFACE_vbo_enabled=		24;$/;"	v
SURFACE_vbo_id	.\data.cpp	/^const int SURFACE_vbo_id=			19;$/;"	v
SURFACE_vert_array_size	.\data.cpp	/^const int SURFACE_vert_array_size=	20;$/;"	v
SURFACE_vert_bone1_no	.\data.cpp	/^const int SURFACE_vert_bone1_no=	9;$/;"	v
SURFACE_vert_bone2_no	.\data.cpp	/^const int SURFACE_vert_bone2_no=	10;$/;"	v
SURFACE_vert_bone3_no	.\data.cpp	/^const int SURFACE_vert_bone3_no=	11;$/;"	v
SURFACE_vert_bone4_no	.\data.cpp	/^const int SURFACE_vert_bone4_no=	12;$/;"	v
SURFACE_vert_col	.\data.cpp	/^const int SURFACE_vert_col=			7;$/;"	v
SURFACE_vert_coords	.\data.cpp	/^const int SURFACE_vert_coords=		3;$/;"	v
SURFACE_vert_norm	.\data.cpp	/^const int SURFACE_vert_norm=		4;$/;"	v
SURFACE_vert_tex_coords0	.\data.cpp	/^const int SURFACE_vert_tex_coords0=	5;$/;"	v
SURFACE_vert_tex_coords1	.\data.cpp	/^const int SURFACE_vert_tex_coords1=	6;$/;"	v
SURFACE_vert_weight1	.\data.cpp	/^const int SURFACE_vert_weight1=		13;$/;"	v
SURFACE_vert_weight2	.\data.cpp	/^const int SURFACE_vert_weight2=		14;$/;"	v
SURFACE_vert_weight3	.\data.cpp	/^const int SURFACE_vert_weight3=		15;$/;"	v
SURFACE_vert_weight4	.\data.cpp	/^const int SURFACE_vert_weight4=		16;$/;"	v
SURFACE_vmax	.\data.cpp	/^const int SURFACE_vmax=				23;$/;"	v
SURFACE_vmin	.\data.cpp	/^const int SURFACE_vmin=				22;$/;"	v
SWAP_ROWS	.\openb3d\src\project.cpp	254;"	d	file:
SWAP_ROWS	.\openb3d\src\project.cpp	87;"	d	file:
Sampler	.\openb3d\src\shadermat.h	/^class Sampler{$/;"	c
ScalarField	.\openb3d\src\isosurface.h	/^	float (*ScalarField)(float x, float y, float z);$/;"	m	class:Fluid
Scale	.\openb3d\src\matrix.h	/^	void Scale(float x,float y,float z){$/;"	f	class:Matrix
ScaleEntity	.\openb3d\src\entity.cpp	/^void Entity::ScaleEntity(float x,float y,float z,int glob){$/;"	f	class:Entity
ScaleEntity	.\openb3d\src\functions.cpp	/^void ScaleEntity(Entity* ent,float x,float y,float z,bool glob){$/;"	f
ScaleMesh	.\openb3d\src\functions.cpp	/^void ScaleMesh(Mesh* mesh,float sx,float sy,float sz){$/;"	f
ScaleMesh	.\openb3d\src\mesh.cpp	/^void Mesh::ScaleMesh(float sx,float sy,float sz){$/;"	f	class:Mesh
ScaleSprite	.\openb3d\src\functions.cpp	/^void ScaleSprite(Sprite* sprite,float s_x,float s_y){$/;"	f
ScaleSprite	.\openb3d\src\sprite.cpp	/^void Sprite::ScaleSprite(float s_x,float s_y){$/;"	f	class:Sprite
ScaleTexture	.\openb3d\src\functions.cpp	/^void ScaleTexture(Texture* tex,float u_scale,float v_scale){$/;"	f
ScaleTexture	.\openb3d\src\texture.cpp	/^void Texture::ScaleTexture(float u_s,float v_s){$/;"	f	class:Texture
ScanObject	.\openb3d\src\csg.cpp	/^void ScanObject(Mesh* mesh){$/;"	f	namespace:CSG
SeekFile	.\openb3d\src\file.cpp	/^void File::SeekFile(int pos){$/;"	f	class:File
SetAnimKey	.\openb3d\src\entity.cpp	/^void Entity::SetAnimKey(float frame, int pos_key, int rot_key, int scale_key){$/;"	f	class:Entity
SetAnimKey	.\openb3d\src\functions.cpp	/^void SetAnimKey(Entity* ent, float frame, int pos_key=true, int rot_key=true, int scale_key=true){$/;"	f
SetAnimTime	.\openb3d\src\entity.cpp	/^void Entity::SetAnimTime(float time,int seq){$/;"	f	class:Entity
SetAnimTime	.\openb3d\src\functions.cpp	/^void SetAnimTime(Entity* ent,float time,int seq){$/;"	f
SetCubeFace	.\openb3d\src\functions.cpp	/^void SetCubeFace(Texture* tex,int face){$/;"	f
SetCubeMode	.\openb3d\src\functions.cpp	/^void SetCubeMode(Texture* tex,int mode){$/;"	f
SetFloat	.\openb3d\src\functions.cpp	/^void SetFloat(Shader* material, char* name, float v1){$/;"	f
SetFloat	.\openb3d\src\material.cpp	/^void Shader::SetFloat(string name, float v1){$/;"	f	class:Shader
SetFloat2	.\openb3d\src\functions.cpp	/^void SetFloat2(Shader* material, char* name, float v1, float v2){$/;"	f
SetFloat2	.\openb3d\src\material.cpp	/^void Shader::SetFloat2(string name, float v1, float v2){$/;"	f	class:Shader
SetFloat3	.\openb3d\src\functions.cpp	/^void SetFloat3(Shader* material, char* name, float v1, float v2, float v3){$/;"	f
SetFloat3	.\openb3d\src\material.cpp	/^void Shader::SetFloat3(string name, float v1, float v2, float v3){$/;"	f	class:Shader
SetFloat4	.\openb3d\src\functions.cpp	/^void SetFloat4(Shader* material, char* name, float v1, float v2, float v3, float v4){$/;"	f
SetFloat4	.\openb3d\src\material.cpp	/^void Shader::SetFloat4(string name, float v1, float v2, float v3, float v4){$/;"	f	class:Shader
SetInteger	.\openb3d\src\functions.cpp	/^void SetInteger(Shader* material, char* name, int v1){$/;"	f
SetInteger	.\openb3d\src\material.cpp	/^void Shader::SetInteger(string name, int v1){$/;"	f	class:Shader
SetInteger2	.\openb3d\src\functions.cpp	/^void SetInteger2(Shader* material, char* name, int v1, int v2){$/;"	f
SetInteger2	.\openb3d\src\material.cpp	/^void Shader::SetInteger2(string name, int v1, int v2){$/;"	f	class:Shader
SetInteger3	.\openb3d\src\functions.cpp	/^void SetInteger3(Shader* material, char* name, int v1, int v2, int v3){$/;"	f
SetInteger3	.\openb3d\src\material.cpp	/^void Shader::SetInteger3(string name, int v1, int v2, int v3){$/;"	f	class:Shader
SetInteger4	.\openb3d\src\functions.cpp	/^void SetInteger4(Shader* material, char* name, int v1, int v2, int v3, int v4){$/;"	f
SetInteger4	.\openb3d\src\material.cpp	/^void Shader::SetInteger4(string name, int v1, int v2, int v3, int v4){$/;"	f	class:Shader
SetMatrix2F	.\openb3d\src\material.cpp	/^void ProgramObject::SetMatrix2F(string name, float* m){$/;"	f	class:ProgramObject
SetMatrix3F	.\openb3d\src\material.cpp	/^void ProgramObject::SetMatrix3F(string name, float* m){$/;"	f	class:ProgramObject
SetMatrix4F	.\openb3d\src\material.cpp	/^void ProgramObject::SetMatrix4F(string name, float* m){$/;"	f	class:ProgramObject
SetParameter1D	.\openb3d\src\material.cpp	/^void ProgramObject::SetParameter1D(string name, double v1){$/;"	f	class:ProgramObject
SetParameter1F	.\openb3d\src\material.cpp	/^void ProgramObject::SetParameter1F(string name, float v){$/;"	f	class:ProgramObject
SetParameter1I	.\openb3d\src\material.cpp	/^void ProgramObject::SetParameter1I(string name, int v1){$/;"	f	class:ProgramObject
SetParameter1S	.\openb3d\src\material.cpp	/^void ProgramObject::SetParameter1S(string name, float v1){$/;"	f	class:ProgramObject
SetParameter2D	.\openb3d\src\material.cpp	/^void ProgramObject::SetParameter2D(string name, double v1, double v2){$/;"	f	class:ProgramObject
SetParameter2F	.\openb3d\src\material.cpp	/^void ProgramObject::SetParameter2F(string name, float v1, float v2){$/;"	f	class:ProgramObject
SetParameter2I	.\openb3d\src\material.cpp	/^void ProgramObject::SetParameter2I(string name, int v1, int v2){$/;"	f	class:ProgramObject
SetParameter2S	.\openb3d\src\material.cpp	/^void ProgramObject::SetParameter2S(string name, float v1, float v2) {$/;"	f	class:ProgramObject
SetParameter3D	.\openb3d\src\material.cpp	/^void ProgramObject::SetParameter3D(string name, double v1, double v2, double v3){$/;"	f	class:ProgramObject
SetParameter3F	.\openb3d\src\material.cpp	/^void ProgramObject::SetParameter3F(string name, float v1, float v2, float v3){$/;"	f	class:ProgramObject
SetParameter3I	.\openb3d\src\material.cpp	/^void ProgramObject::SetParameter3I(string name, int v1, int v2, int v3){$/;"	f	class:ProgramObject
SetParameter3S	.\openb3d\src\material.cpp	/^void ProgramObject::SetParameter3S(string name, float v1, float v2, float v3){$/;"	f	class:ProgramObject
SetParameter4D	.\openb3d\src\material.cpp	/^void ProgramObject::SetParameter4D(string name, double v1, double v2, double v3, double v4){$/;"	f	class:ProgramObject
SetParameter4F	.\openb3d\src\material.cpp	/^void ProgramObject::SetParameter4F(string name, float v1, float v2, float v3, float v4){$/;"	f	class:ProgramObject
SetParameter4I	.\openb3d\src\material.cpp	/^void ProgramObject::SetParameter4I(string name, int v1, int v2, int v3, int v4){$/;"	f	class:ProgramObject
SetParameter4S	.\openb3d\src\material.cpp	/^void ProgramObject::SetParameter4S(string name, float v1, float v2, float v3, float v4){$/;"	f	class:ProgramObject
SetParameterArray	.\openb3d\src\material.cpp	/^void ProgramObject::SetParameterArray(string name, Surface* surf, int vbo){$/;"	f	class:ProgramObject
SetParameterArray	.\openb3d\src\material.cpp	/^void ProgramObject::SetParameterArray(string name, vector<float>* verticesPtr, int vbo){$/;"	f	class:ProgramObject
SetShadowColor	.\methods.cpp	/^void SetShadowColor( int R,int G,int B,int A ){$/;"	f
SetShadowColor	.\openb3d\src\shadow.cpp	/^void ShadowObject::SetShadowColor(int R, int G, int B, int A){$/;"	f	class:ShadowObject
SetTilt	.\openb3d\src\tilt.h	/^	static void SetTilt(float tilt_x,float tilt_y,float tilt_z){$/;"	f	class:Tilt
SetTranslate	.\openb3d\src\matrix.h	/^	void SetTranslate(float x, float y, float z ){$/;"	f	class:Matrix
SetVector1F	.\openb3d\src\material.cpp	/^void ProgramObject::SetVector1F(string name, float* v1){$/;"	f	class:ProgramObject
SetVector1I	.\openb3d\src\material.cpp	/^void ProgramObject::SetVector1I(string name, int* v1){$/;"	f	class:ProgramObject
SetVector2F	.\openb3d\src\material.cpp	/^void ProgramObject::SetVector2F(string name, float* v1){$/;"	f	class:ProgramObject
SetVector2I	.\openb3d\src\material.cpp	/^void ProgramObject::SetVector2I(string name, int* v1){$/;"	f	class:ProgramObject
SetVector3F	.\openb3d\src\material.cpp	/^void ProgramObject::SetVector3F(string name, float* v1){$/;"	f	class:ProgramObject
SetVector3I	.\openb3d\src\material.cpp	/^void ProgramObject::SetVector3I(string name, int* v1){$/;"	f	class:ProgramObject
SetVector4F	.\openb3d\src\material.cpp	/^void ProgramObject::SetVector4F(string name, float* v1){$/;"	f	class:ProgramObject
SetVector4I	.\openb3d\src\material.cpp	/^void ProgramObject::SetVector4I(string name, int* v1){$/;"	f	class:ProgramObject
ShadeEntity	.\openb3d\src\functions.cpp	/^void ShadeEntity(Entity* ent, Shader* material){$/;"	f
ShadeMesh	.\openb3d\src\functions.cpp	/^void ShadeMesh(Mesh* mesh, Shader* material){$/;"	f
ShadeSurface	.\openb3d\src\functions.cpp	/^void ShadeSurface(Surface* surf, Shader* material){$/;"	f
Shader	.\openb3d\src\shadermat.h	/^class Shader {\/\/: public MaterialPlugin{$/;"	c
ShaderData	.\openb3d\src\shadermat.h	/^class ShaderData{$/;"	c
ShaderIDCount	.\openb3d\src\material.cpp	/^int Shader::ShaderIDCount;$/;"	m	class:Shader	file:
ShaderIDCount	.\openb3d\src\shadermat.h	/^	static int ShaderIDCount;$/;"	m	class:Shader
ShaderMat	.\openb3d\src\surface.h	/^	Shader* ShaderMat;$/;"	m	class:Surface
ShaderMat	.\openb3d\src\terrain.h	/^	Shader* ShaderMat;$/;"	m	class:Terrain
ShaderMaterial	.\openb3d\src\functions.cpp	/^void ShaderMaterial(Shader* material, Material* tex, char* name, int index){$/;"	f
ShaderObj	.\openb3d\src\shaderobject.h	/^	int ShaderObj;$/;"	m	class:ShaderObject
ShaderObject	.\openb3d\src\shaderobject.h	/^class ShaderObject{$/;"	c
ShaderObjectList	.\openb3d\src\material.cpp	/^list<ShaderObject*> ShaderObject::ShaderObjectList;$/;"	m	class:ShaderObject	file:
ShaderObjectList	.\openb3d\src\shaderobject.h	/^	static list<ShaderObject*> ShaderObjectList;$/;"	m	class:ShaderObject
ShaderTexture	.\openb3d\src\functions.cpp	/^Texture* ShaderTexture(Shader* material, Texture* tex, char* name, int index){$/;"	f
ShaderType	.\openb3d\src\shaderobject.h	/^	int ShaderType;				\/\/ 1 = Vert, 2 = Frag$/;"	m	class:ShaderObject
Shader_Tex	.\openb3d\src\shadermat.h	/^	Sampler* Shader_Tex[255];$/;"	m	class:Shader
ShadowAlpha	.\openb3d\src\shadow.cpp	/^float ShadowObject::ShadowAlpha =.5;$/;"	m	class:ShadowObject	file:
ShadowAlpha	.\openb3d\src\shadow.h	/^	static float ShadowAlpha;$/;"	m	class:ShadowObject
ShadowBlue	.\openb3d\src\shadow.cpp	/^float ShadowObject::ShadowBlue  =0;$/;"	m	class:ShadowObject	file:
ShadowBlue	.\openb3d\src\shadow.h	/^	static float ShadowBlue;$/;"	m	class:ShadowObject
ShadowCap	.\openb3d\src\shadow.h	/^	Surface* ShadowCap;$/;"	m	class:ShadowObject
ShadowGreen	.\openb3d\src\shadow.cpp	/^float ShadowObject::ShadowGreen =0;$/;"	m	class:ShadowObject	file:
ShadowGreen	.\openb3d\src\shadow.h	/^	static float ShadowGreen;$/;"	m	class:ShadowObject
ShadowInit	.\methods.cpp	/^void ShadowInit(){$/;"	f
ShadowInit	.\openb3d\src\shadow.cpp	/^void ShadowObject::ShadowInit(){$/;"	f	class:ShadowObject
ShadowMesh	.\openb3d\src\shadow.h	/^	Mesh*  ShadowMesh;$/;"	m	class:ShadowObject
ShadowObject	.\openb3d\src\shadow.h	/^class ShadowObject{$/;"	c
ShadowObjectChar	.\data.cpp	/^char* ShadowObjectChar( ShadowObject* obj,int varid ){$/;"	f
ShadowObjectInit	.\methods.cpp	/^void ShadowObjectInit( ShadowObject* obj ){$/;"	f
ShadowObjectInt	.\data.cpp	/^int* ShadowObjectInt( ShadowObject* obj,int varid ){$/;"	f
ShadowObjectMesh	.\data.cpp	/^Mesh* ShadowObjectMesh( ShadowObject* obj,int varid ){$/;"	f
ShadowObjectSurface	.\data.cpp	/^Surface* ShadowObjectSurface( ShadowObject* obj,int varid ){$/;"	f
ShadowObjectUpdate	.\methods.cpp	/^void ShadowObjectUpdate( Camera* Cam ){$/;"	f
ShadowRed	.\openb3d\src\shadow.cpp	/^float ShadowObject::ShadowRed   =0;$/;"	m	class:ShadowObject	file:
ShadowRed	.\openb3d\src\shadow.h	/^	static float ShadowRed;$/;"	m	class:ShadowObject
ShadowRenderWorldZFail	.\methods.cpp	/^void ShadowRenderWorldZFail(){$/;"	f
ShadowRenderWorldZFail	.\openb3d\src\shadow.cpp	/^void ShadowObject::ShadowRenderWorldZFail(){$/;"	f	class:ShadowObject
ShadowTriangle	.\openb3d\src\shadow.h	/^class ShadowTriangle{$/;"	c
ShadowVolume	.\openb3d\src\shadow.h	/^	Surface* ShadowVolume;$/;"	m	class:ShadowObject
Shadows_enabled	.\openb3d\src\global.cpp	/^int Global::Shadows_enabled=false;$/;"	m	class:Global	file:
Shadows_enabled	.\openb3d\src\global.h	/^	static int Shadows_enabled;$/;"	m	class:Global
ShowEntity	.\openb3d\src\entity.cpp	/^void Entity::ShowEntity(){$/;"	f	class:Entity
ShowEntity	.\openb3d\src\functions.cpp	/^void ShowEntity(Entity* ent){$/;"	f
SkinMesh	.\openb3d\src\functions.cpp	/^void SkinMesh(Mesh* mesh, int surf_no_get, int vid, int bone1, float weight1=1.0, int bone2=0, float weight2=0, int bone3=0, float weight3=0, int bone4=0, float weight4=0){$/;"	f
SkinMesh	.\openb3d\src\mesh.cpp	/^void Mesh::SkinMesh(int surf_no_get, int vid, int bone1, float weight1, int bone2, float weight2, int bone3, float weight3, int bone4, float weight4){$/;"	f	class:Mesh
SkipChunk	.\openb3d\src\3ds.cpp	/^void SkipChunk(){$/;"	f	namespace:load3ds
Slerp	.\openb3d\src\quaternion.cpp	/^void Slerp(float Ax,float Ay,float Az,float Aw,float Bx,float By,float Bz,float Bw,float& Cx,float& Cy,float& Cz,float& Cw,float t){$/;"	f
Slot	.\openb3d\src\shadermat.h	/^	int Slot;$/;"	m	class:Sampler
Split	.\openb3d\src\string_helper.cpp	/^string Split(string s,string splitter,int count){$/;"	f
SplitTriangle	.\openb3d\src\csg.cpp	/^int SplitTriangle(CSGTriangle* t1, CSGTriangle* t2, int dosplit = 0, int loop = 1){$/;"	f	namespace:CSG
SplitTriangles	.\openb3d\src\csg.cpp	/^void SplitTriangles(Mesh* obj1){$/;"	f	namespace:CSG
Sprite	.\openb3d\src\sprite.h	/^	Sprite(){$/;"	f	class:Sprite
Sprite	.\openb3d\src\sprite.h	/^class Sprite : public Mesh{$/;"	c
SpriteBatch	.\openb3d\src\sprite_batch.h	/^	SpriteBatch(){$/;"	f	class:SpriteBatch
SpriteBatch	.\openb3d\src\sprite_batch.h	/^class SpriteBatch{$/;"	c
SpriteFloat	.\data.cpp	/^float* SpriteFloat( Sprite* obj,int varid ){$/;"	f
SpriteInt	.\data.cpp	/^int* SpriteInt( Sprite* obj,int varid ){$/;"	f
SpriteRenderMode	.\openb3d\src\functions.cpp	/^void SpriteRenderMode(Sprite* sprite,int mode){$/;"	f
SpriteRenderMode	.\openb3d\src\sprite.cpp	/^void Sprite::SpriteRenderMode(int mode){$/;"	f	class:Sprite
SpriteTexCoords	.\methods.cpp	/^void SpriteTexCoords( Sprite* obj,int cell_x,int cell_y,int cell_w,int cell_h,int tex_w,int tex_h,int uv_set ){$/;"	f
SpriteTexCoords	.\openb3d\src\sprite.cpp	/^void Sprite::SpriteTexCoords(int cell_x,int cell_y,int cell_w,int cell_h,int tex_w,int tex_h,int uv_set){$/;"	f	class:Sprite
SpriteVertexColor	.\methods.cpp	/^void SpriteVertexColor( Sprite* obj,int v,float r,float g,float b ){$/;"	f
SpriteVertexColor	.\openb3d\src\sprite.cpp	/^void Sprite::SpriteVertexColor(int v,float r,float g,float b){$/;"	f	class:Sprite
SpriteViewMode	.\openb3d\src\functions.cpp	/^void SpriteViewMode(Sprite* sprite,int mode){$/;"	f
SpriteViewMode	.\openb3d\src\sprite.cpp	/^void Sprite::SpriteViewMode(int mode){$/;"	f	class:Sprite
Static	.\openb3d\src\shadow.h	/^	char Static;$/;"	m	class:ShadowObject
StaticCamera	.\data.cpp	/^Camera* StaticCamera( int classid,int varid ){$/;"	f
StaticChar	.\data.cpp	/^char* StaticChar( int classid,int varid ){$/;"	f
StaticEntity	.\data.cpp	/^Entity* StaticEntity( int classid,int varid ){$/;"	f
StaticFloat	.\data.cpp	/^float* StaticFloat( int classid,int varid ){$/;"	f
StaticInt	.\data.cpp	/^int* StaticInt( int classid,int varid ){$/;"	f
StaticIterListAction	.\data.cpp	/^Action* StaticIterListAction( int classid,int varid,int &id ){$/;"	f
StaticIterListCamera	.\data.cpp	/^Camera* StaticIterListCamera( int classid,int varid,int &id ){$/;"	f
StaticIterListEntity	.\data.cpp	/^Entity* StaticIterListEntity( int classid,int varid,int &id ){$/;"	f
StaticIterListShadowObject	.\data.cpp	/^ShadowObject* StaticIterListShadowObject( int classid,int varid,int &id ){$/;"	f
StaticIterListTerrain	.\data.cpp	/^Terrain* StaticIterListTerrain( int classid,int varid,int &id ){$/;"	f
StaticIterListTexture	.\data.cpp	/^Texture* StaticIterListTexture( int classid,int varid,int &id ){$/;"	f
StaticIterVectorLight	.\data.cpp	/^Light* StaticIterVectorLight( int classid,int varid,int &id ){$/;"	f
StaticListSize	.\data.cpp	/^int StaticListSize( int classid,int varid ){$/;"	f
StaticPivot	.\data.cpp	/^Pivot* StaticPivot( int classid,int varid ){$/;"	f
StaticSurface	.\data.cpp	/^Surface* StaticSurface( int classid,int varid ){$/;"	f
Stencil	.\openb3d\src\stencil.h	/^	Stencil(){$/;"	f	class:Stencil
Stencil	.\openb3d\src\stencil.h	/^class Stencil{$/;"	c
StencilAlpha	.\openb3d\src\functions.cpp	/^void StencilAlpha(Stencil* stencil, float a){$/;"	f
StencilAlpha	.\openb3d\src\stencil.cpp	/^void Stencil::StencilAlpha(float a){$/;"	f	class:Stencil
StencilClsColor	.\openb3d\src\functions.cpp	/^void StencilClsColor(Stencil* stencil, float r,float g,float b){$/;"	f
StencilClsColor	.\openb3d\src\stencil.cpp	/^void Stencil::StencilClsColor(float r,float g,float b){$/;"	f	class:Stencil
StencilClsMode	.\openb3d\src\functions.cpp	/^void StencilClsMode(Stencil* stencil,int cls_depth,int cls_zbuffer){$/;"	f
StencilClsMode	.\openb3d\src\stencil.cpp	/^void Stencil::StencilClsMode(int color,int zbuffer){$/;"	f	class:Stencil
StencilMesh	.\openb3d\src\functions.cpp	/^void StencilMesh(Stencil* stencil, Mesh* mesh, int mode=1){$/;"	f
StencilMesh	.\openb3d\src\stencil.cpp	/^void Stencil::StencilMesh(Mesh* mesh, int mode){$/;"	f	class:Stencil
StencilMesh_list	.\openb3d\src\stencil.h	/^	list<Mesh*> StencilMesh_list;$/;"	m	class:Stencil
StencilMode	.\openb3d\src\functions.cpp	/^void StencilMode(Stencil* stencil, int m, int o=1){$/;"	f
StencilMode	.\openb3d\src\stencil.cpp	/^void Stencil::StencilMode(int m, int o){$/;"	f	class:Stencil
StencilMode_list	.\openb3d\src\stencil.h	/^	list<int> StencilMode_list;$/;"	m	class:Stencil
Stream	.\openb3d\src\3ds.cpp	/^File*          Stream;$/;"	m	namespace:load3ds	file:
Stream	.\openb3d\src\x.cpp	/^File*  Stream;$/;"	m	namespace:loadX	file:
Surface	.\openb3d\src\surface.cpp	/^Surface::Surface(){$/;"	f	class:Surface
Surface	.\openb3d\src\surface.h	/^class Surface{$/;"	c
SurfaceAlpha	.\methods.cpp	/^void SurfaceAlpha( Surface* obj,float a ){$/;"	f
SurfaceAlpha	.\openb3d\src\surface.cpp	/^void Surface::SurfaceAlpha(float a){$/;"	f	class:Surface
SurfaceBlue	.\methods.cpp	/^void SurfaceBlue( Surface* obj,float b ){$/;"	f
SurfaceBlue	.\openb3d\src\surface.cpp	/^void Surface::SurfaceBlue(float b){$/;"	f	class:Surface
SurfaceBrush	.\data.cpp	/^Brush* SurfaceBrush( Surface* obj,int varid ){$/;"	f
SurfaceColor	.\methods.cpp	/^void SurfaceColor( Surface* obj,float r,float g,float b,float a ){$/;"	f
SurfaceColor	.\openb3d\src\surface.cpp	/^void Surface::SurfaceColor(float r,float g,float b){$/;"	f	class:Surface
SurfaceColor	.\openb3d\src\surface.cpp	/^void Surface::SurfaceColor(float r,float g,float b,float a){$/;"	f	class:Surface
SurfaceCopy	.\methods.cpp	/^Surface* SurfaceCopy( Surface* obj ){$/;"	f
SurfaceFloat	.\data.cpp	/^float* SurfaceFloat( Surface* obj,int varid ){$/;"	f
SurfaceGreen	.\methods.cpp	/^void SurfaceGreen( Surface* obj,float g ){$/;"	f
SurfaceGreen	.\openb3d\src\surface.cpp	/^void Surface::SurfaceGreen(float g){$/;"	f	class:Surface
SurfaceInt	.\data.cpp	/^int* SurfaceInt( Surface* obj,int varid ){$/;"	f
SurfaceRed	.\methods.cpp	/^void SurfaceRed( Surface* obj,float r ){$/;"	f
SurfaceRed	.\openb3d\src\surface.cpp	/^void Surface::SurfaceRed(float r){$/;"	f	class:Surface
SurfaceShader	.\data.cpp	/^Shader* SurfaceShader( Surface* obj,int varid ){$/;"	f
SurfaceUInt	.\data.cpp	/^unsigned int* SurfaceUInt( Surface* obj,int varid ){$/;"	f
SurfaceUShort	.\data.cpp	/^unsigned short* SurfaceUShort( Surface* obj,int varid ){$/;"	f
SurfaceUpdateNormals	.\methods.cpp	/^void SurfaceUpdateNormals( Surface* obj ){$/;"	f
T	.\openb3d\src\project.cpp	49;"	d	file:
T	.\openb3d\src\project.cpp	73;"	d	file:
TERRAIN_H	.\openb3d\src\terrain.h	9;"	d
TERRAIN_ShaderMat	.\data.cpp	/^const int TERRAIN_ShaderMat=	10;$/;"	v
TERRAIN_c_col_tree	.\data.cpp	/^const int TERRAIN_c_col_tree=	8;$/;"	v
TERRAIN_class	.\data.cpp	/^const int TERRAIN_class=		51;$/;"	v
TERRAIN_eyepoint	.\data.cpp	/^const int TERRAIN_eyepoint=		9;$/;"	v
TERRAIN_height	.\data.cpp	/^const int TERRAIN_height=		7;$/;"	v
TERRAIN_level2dzsize	.\data.cpp	/^const int TERRAIN_level2dzsize=	6;$/;"	v
TERRAIN_mesh_info	.\data.cpp	/^const int TERRAIN_mesh_info=	3;$/;"	v
TERRAIN_size	.\data.cpp	/^const int TERRAIN_size=			4;$/;"	v
TERRAIN_terrain_list	.\data.cpp	/^const int TERRAIN_terrain_list=	1;$/;"	v
TERRAIN_triangleindex	.\data.cpp	/^const int TERRAIN_triangleindex=2;$/;"	v
TERRAIN_vsize	.\data.cpp	/^const int TERRAIN_vsize=		5;$/;"	v
TEXS	.\openb3d\src\model.cpp	/^const int TEXS=1;$/;"	v
TEXTUREFILTER_class	.\data.cpp	/^const int TEXTUREFILTER_class=	53;$/;"	v
TEXTURE_FILTER_H	.\openb3d\src\texture_filter.h	11;"	d
TEXTURE_H	.\openb3d\src\texture.h	2;"	d
TEXTURE_angle	.\data.cpp	/^const int TEXTURE_angle=		12;$/;"	v
TEXTURE_blend	.\data.cpp	/^const int TEXTURE_blend=		6;$/;"	v
TEXTURE_class	.\data.cpp	/^const int TEXTURE_class=		52;$/;"	v
TEXTURE_coords	.\data.cpp	/^const int TEXTURE_coords=		7;$/;"	v
TEXTURE_cube_face	.\data.cpp	/^const int TEXTURE_cube_face=	18;$/;"	v
TEXTURE_cube_mode	.\data.cpp	/^const int TEXTURE_cube_mode=	19;$/;"	v
TEXTURE_file	.\data.cpp	/^const int TEXTURE_file=			3;$/;"	v
TEXTURE_file_abs	.\data.cpp	/^const int TEXTURE_file_abs=		13;$/;"	v
TEXTURE_flags	.\data.cpp	/^const int TEXTURE_flags=		5;$/;"	v
TEXTURE_framebuffer	.\data.cpp	/^const int TEXTURE_framebuffer=	17;$/;"	v
TEXTURE_frames	.\data.cpp	/^const int TEXTURE_frames=		4;$/;"	v
TEXTURE_height	.\data.cpp	/^const int TEXTURE_height=		15;$/;"	v
TEXTURE_no_frames	.\data.cpp	/^const int TEXTURE_no_frames=	16;$/;"	v
TEXTURE_tex_list	.\data.cpp	/^const int TEXTURE_tex_list=		2;$/;"	v
TEXTURE_texture	.\data.cpp	/^const int TEXTURE_texture=		1;$/;"	v
TEXTURE_u_pos	.\data.cpp	/^const int TEXTURE_u_pos=		10;$/;"	v
TEXTURE_u_scale	.\data.cpp	/^const int TEXTURE_u_scale=		8;$/;"	v
TEXTURE_v_pos	.\data.cpp	/^const int TEXTURE_v_pos=		11;$/;"	v
TEXTURE_v_scale	.\data.cpp	/^const int TEXTURE_v_scale=		9;$/;"	v
TEXTURE_width	.\data.cpp	/^const int TEXTURE_width=		14;$/;"	v
TFormNormal	.\openb3d\src\entity.cpp	/^void Entity::TFormNormal(float x,float y,float z,Entity* src_ent,Entity* dest_ent){$/;"	f	class:Entity
TFormNormal	.\openb3d\src\functions.cpp	/^void TFormNormal(float x,float y,float z,Entity* src_ent,Entity* dest_ent){$/;"	f
TFormPoint	.\openb3d\src\entity.cpp	/^void Entity::TFormPoint(float x,float y,float z,Entity* src_ent,Entity* dest_ent){$/;"	f	class:Entity
TFormPoint	.\openb3d\src\functions.cpp	/^void TFormPoint(float x,float y,float z,Entity* src_ent,Entity* dest_ent){$/;"	f
TFormVector	.\openb3d\src\entity.cpp	/^void Entity::TFormVector(float x,float y,float z,Entity* src_ent,Entity* dest_ent){$/;"	f	class:Entity
TFormVector	.\openb3d\src\functions.cpp	/^void TFormVector(float x,float y,float z,Entity* src_ent,Entity* dest_ent){$/;"	f
TFormedX	.\openb3d\src\entity.cpp	/^float Entity::TFormedX(){$/;"	f	class:Entity
TFormedX	.\openb3d\src\functions.cpp	/^float TFormedX(){$/;"	f
TFormedY	.\openb3d\src\entity.cpp	/^float Entity::TFormedY(){$/;"	f	class:Entity
TFormedY	.\openb3d\src\functions.cpp	/^float TFormedY(){$/;"	f
TFormedZ	.\openb3d\src\entity.cpp	/^float Entity::TFormedZ(){$/;"	f	class:Entity
TFormedZ	.\openb3d\src\functions.cpp	/^float TFormedZ(){$/;"	f
TILT_H	.\openb3d\src\tilt.h	11;"	d
TILT_class	.\data.cpp	/^const int TILT_class=			54;$/;"	v
TOASTsub	.\openb3d\src\geosphere.cpp	/^void Geosphere::TOASTsub(int l, float v2[], float v1[], float v0[]){$/;"	f	class:Geosphere
TOUCH_H	.\openb3d\src\touch.h	11;"	d
TOUCH_class	.\data.cpp	/^const int TOUCH_class=			55;$/;"	v
TRANSFORM_class	.\data.cpp	/^const int TRANSFORM_class=		19;$/;"	v
TRIS	.\openb3d\src\model.cpp	/^const int TRIS=7;$/;"	v
TWOPI	.\openb3d\src\geom.h	/^const float TWOPI=PI*2.0f;			\/\/360 degrees$/;"	v
TagID	.\openb3d\src\model.cpp	/^int TagID(string tag){$/;"	f
Template	.\openb3d\src\x.cpp	/^		string Template;$/;"	m	class:loadX::XLoader_TreeNode	file:
Terrain	.\openb3d\src\terrain.h	/^	Terrain(){$/;"	f	class:Terrain
Terrain	.\openb3d\src\terrain.h	/^class Terrain : public Entity{$/;"	c
TerrainCamera	.\data.cpp	/^Camera* TerrainCamera( Terrain* obj,int varid ){$/;"	f
TerrainFloat	.\data.cpp	/^float* TerrainFloat( Terrain* obj,int varid ){$/;"	f
TerrainHeight	.\openb3d\src\functions.cpp	/^float TerrainHeight (Terrain* terr, int x, int z){$/;"	f
TerrainHeight	.\openb3d\src\terrain.cpp	/^float Terrain::TerrainHeight (int x, int z){$/;"	f	class:Terrain
TerrainShader	.\data.cpp	/^Shader* TerrainShader( Terrain* obj,int varid ){$/;"	f
TerrainUpdateNormals	.\methods.cpp	/^void TerrainUpdateNormals( Terrain* obj ){$/;"	f
TerrainX	.\openb3d\src\functions.cpp	/^float TerrainX (Terrain* terr, float x, float y, float z){$/;"	f
TerrainX	.\openb3d\src\terrain.cpp	/^float Terrain::TerrainX (float x, float y, float z){$/;"	f	class:Terrain
TerrainY	.\openb3d\src\functions.cpp	/^float TerrainY (Terrain* terr, float x, float y, float z){$/;"	f
TerrainY	.\openb3d\src\terrain.cpp	/^float Terrain::TerrainY (float x, float y, float z){$/;"	f	class:Terrain
TerrainZ	.\openb3d\src\functions.cpp	/^float TerrainZ (Terrain* terr, float x, float y, float z){$/;"	f
TerrainZ	.\openb3d\src\terrain.cpp	/^float Terrain::TerrainZ (float x, float y, float z){$/;"	f	class:Terrain
TexInList	.\methods.cpp	/^Texture* TexInList( Texture* obj ){$/;"	f
TexInList	.\openb3d\src\texture.cpp	/^Texture* Texture::TexInList(){$/;"	f	class:Texture
TexToBuffer	.\openb3d\src\functions.cpp	/^void TexToBuffer(Texture* tex,unsigned char* buffer, int frame){$/;"	f
TexToBuffer	.\openb3d\src\texture.cpp	/^void Texture::TexToBuffer(unsigned char* buffer, int frame){$/;"	f	class:Texture
Texture	.\openb3d\src\texture.h	/^	Texture(){$/;"	f	class:Texture
Texture	.\openb3d\src\texture.h	/^class Texture{$/;"	c
TextureBlend	.\openb3d\src\functions.cpp	/^void TextureBlend(Texture* tex,int blend){$/;"	f
TextureBlend	.\openb3d\src\texture.cpp	/^void Texture::TextureBlend(int blend_no){$/;"	f	class:Texture
TextureCoords	.\openb3d\src\functions.cpp	/^void TextureCoords(Texture* tex,int coords){$/;"	f
TextureCoords	.\openb3d\src\texture.cpp	/^void Texture::TextureCoords(int coords_no){$/;"	f	class:Texture
TextureCopy	.\methods.cpp	/^Texture* TextureCopy( Texture* obj ){$/;"	f
TextureFilter	.\openb3d\src\functions.cpp	/^void TextureFilter(char* match_text,int flags){$/;"	f
TextureFilter	.\openb3d\src\texture_filter.h	/^	TextureFilter(){};$/;"	f	class:TextureFilter
TextureFilter	.\openb3d\src\texture_filter.h	/^class TextureFilter{$/;"	c
TextureFlags	.\openb3d\src\functions.cpp	/^void TextureFlags(Texture* tex, int flags){$/;"	f
TextureFloat	.\data.cpp	/^float* TextureFloat( Texture* obj,int varid ){$/;"	f
TextureGLTexEnv	.\openb3d\src\functions.cpp	/^void TextureGLTexEnv(Texture* tex, int target, int pname, int param){$/;"	f
TextureHeight	.\openb3d\src\functions.cpp	/^int TextureHeight(Texture* tex){$/;"	f
TextureInt	.\data.cpp	/^int* TextureInt( Texture* obj,int varid ){$/;"	f
TextureLayer	.\openb3d\src\3ds.cpp	/^int            TextureLayer;$/;"	m	namespace:load3ds	file:
TextureName	.\openb3d\src\functions.cpp	/^const char* TextureName(Texture* tex){$/;"	f
TextureName	.\openb3d\src\texture.cpp	/^string Texture::TextureName(){$/;"	f	class:Texture
TextureString	.\data.cpp	/^const char* TextureString( Texture* obj,int varid ){$/;"	f
TextureUInt	.\data.cpp	/^unsigned int* TextureUInt( Texture* obj,int varid ){$/;"	f
TextureWidth	.\openb3d\src\functions.cpp	/^int TextureWidth(Texture* tex){$/;"	f
Tilt	.\openb3d\src\tilt.h	/^	Tilt(){$/;"	f	class:Tilt
Tilt	.\openb3d\src\tilt.h	/^class Tilt{$/;"	c
TiltPitch	.\openb3d\src\tilt.h	/^	static float TiltPitch(){$/;"	f	class:Tilt
TiltRoll	.\openb3d\src\tilt.h	/^	static float TiltRoll(){$/;"	f	class:Tilt
TiltX	.\openb3d\src\tilt.h	/^	static float TiltX(){$/;"	f	class:Tilt
TiltY	.\openb3d\src\tilt.h	/^	static float TiltY(){$/;"	f	class:Tilt
TiltYaw	.\openb3d\src\tilt.h	/^	static float TiltYaw(){$/;"	f	class:Tilt
TiltZ	.\openb3d\src\tilt.h	/^	static float TiltZ(){$/;"	f	class:Tilt
ToQuat	.\openb3d\src\matrix.h	/^	void ToQuat( float &qx, float &qy, float &qz, float &qw){$/;"	f	class:Matrix
Touch	.\openb3d\src\touch.h	/^	Touch(int xx,int yy,int old_xx,int old_yy,int touch_type){$/;"	f	class:Touch
Touch	.\openb3d\src\touch.h	/^class Touch{$/;"	c
TouchHit	.\openb3d\src\touch.h	/^	static int TouchHit(int touch_no,int all=false){$/;"	f	class:Touch
TouchType	.\openb3d\src\touch.h	/^	static int TouchType(int touch_no,int all=false){$/;"	f	class:Touch
TouchX	.\openb3d\src\touch.h	/^	static int TouchX(int touch_no,int all=false){$/;"	f	class:Touch
TouchXPrev	.\openb3d\src\touch.h	/^	static int TouchXPrev(int touch_no,int all=false){$/;"	f	class:Touch
TouchXSpeed	.\openb3d\src\touch.h	/^	static int TouchXSpeed(int touch_no){$/;"	f	class:Touch
TouchY	.\openb3d\src\touch.h	/^	static int TouchY(int touch_no,int all=false){$/;"	f	class:Touch
TouchYPrev	.\openb3d\src\touch.h	/^	static int TouchYPrev(int touch_no,int all=false){$/;"	f	class:Touch
TouchYSpeed	.\openb3d\src\touch.h	/^	static int TouchYSpeed(int touch_no){$/;"	f	class:Touch
TouchesDown	.\openb3d\src\touch.h	/^	static int TouchesDown(){$/;"	f	class:Touch
TouchesHit	.\openb3d\src\touch.h	/^	static int TouchesHit(){$/;"	f	class:Touch
TouchesRelease	.\openb3d\src\touch.h	/^	static int TouchesRelease(){$/;"	f	class:Touch
TouchesXSpeed	.\openb3d\src\touch.h	/^	static int TouchesXSpeed(){$/;"	f	class:Touch
TouchesYSpeed	.\openb3d\src\touch.h	/^	static int TouchesYSpeed(){$/;"	f	class:Touch
Transform	.\openb3d\src\geom.h	/^	Transform( const MMatrix &m ):m(m){$/;"	f	class:Transform
Transform	.\openb3d\src\geom.h	/^	Transform( const MMatrix &m,const Vector &v ):m(m),v(v){$/;"	f	class:Transform
Transform	.\openb3d\src\geom.h	/^	Transform( const Vector &v ):v(v){$/;"	f	class:Transform
Transform	.\openb3d\src\geom.h	/^	Transform(){$/;"	f	class:Transform
Transform	.\openb3d\src\geom.h	/^class Transform{$/;"	c
TransformMesh	.\methods.cpp	/^void TransformMesh( Mesh* obj,Matrix& mat ){$/;"	f
TransformMesh	.\openb3d\src\mesh.cpp	/^void Mesh::TransformMesh(Matrix& mat){$/;"	f	class:Mesh
TransformVec	.\openb3d\src\matrix.h	/^	void TransformVec(float &rx,float &ry,float &rz,int addTranslation = 0 ){$/;"	f	class:Matrix
Translate	.\openb3d\src\matrix.h	/^	void Translate(float x,float y,float z){$/;"	f	class:Matrix
TranslateEntity	.\openb3d\src\entity.cpp	/^void Entity::TranslateEntity(float tx,float ty,float tz,int glob){$/;"	f	class:Entity
TranslateEntity	.\openb3d\src\functions.cpp	/^void TranslateEntity(Entity* ent,float x,float y,float z,bool glob){$/;"	f
Transpose	.\openb3d\src\matrix.h	/^	void Transpose(){$/;"	f	class:Matrix
TreeCheck	.\methods.cpp	/^void TreeCheck( Mesh* obj ){$/;"	f
TreeCheck	.\openb3d\src\geosphere.cpp	/^void Geosphere::TreeCheck(CollisionInfo* ci){$/;"	f	class:Geosphere
TreeCheck	.\openb3d\src\mesh.cpp	/^void Mesh::TreeCheck(){$/;"	f	class:Mesh
TreeCheck	.\openb3d\src\octree.cpp	/^void OcTree::TreeCheck(CollisionInfo* ci){$/;"	f	class:OcTree
TreeCheck	.\openb3d\src\terrain.cpp	/^void Terrain::TreeCheck(CollisionInfo* ci){$/;"	f	class:Terrain
Tri	.\openb3d\src\shadow.h	/^	vector<ShadowTriangle*> Tri;$/;"	m	class:ShadowObject
Triangle	.\openb3d\src\tree.h	/^	struct Triangle{$/;"	s	class:MeshCollider
TriangleCount	.\openb3d\src\3ds.cpp	/^int            TriangleCount;$/;"	m	namespace:load3ds	file:
TriangleNX	.\methods.cpp	/^float TriangleNX( Surface* obj,int tri_no ){$/;"	f
TriangleNX	.\openb3d\src\surface.cpp	/^float Surface::TriangleNX(int tri_no){$/;"	f	class:Surface
TriangleNY	.\methods.cpp	/^float TriangleNY( Surface* obj,int tri_no ){$/;"	f
TriangleNY	.\openb3d\src\surface.cpp	/^float Surface::TriangleNY(int tri_no){$/;"	f	class:Surface
TriangleNZ	.\methods.cpp	/^float TriangleNZ( Surface* obj,int tri_no ){$/;"	f
TriangleNZ	.\openb3d\src\surface.cpp	/^float Surface::TriangleNZ(int tri_no){$/;"	f	class:Surface
TriangleVertex	.\openb3d\src\functions.cpp	/^int TriangleVertex(Surface* surf,int tri_no,int corner){$/;"	f
TriangleVertex	.\openb3d\src\surface.cpp	/^int Surface::TriangleVertex(int tri_no,int corner){$/;"	f	class:Surface
Trim	.\openb3d\src\string_helper.cpp	/^string Trim(string s){$/;"	f
TrimVerts	.\openb3d\src\model.cpp	/^void TrimVerts(Surface* surf){$/;"	f
TurnEntity	.\openb3d\src\entity.cpp	/^void Entity::TurnEntity(float x,float y,float z,int glob){$/;"	f	class:Entity
TurnEntity	.\openb3d\src\functions.cpp	/^void TurnEntity(Entity* ent,float x,float y,float z,bool glob){$/;"	f
TurnOff	.\openb3d\src\material.cpp	/^void Shader::TurnOff(){$/;"	f	class:Shader
TurnOn	.\openb3d\src\material.cpp	/^void Shader::TurnOn(Matrix& mat, Surface* surf, vector<float>* vertices){$/;"	f	class:Shader
TypeMap	.\openb3d\src\shaderobject.h	/^	map<string,int> TypeMap;$/;"	m	class:ProgramObject
USE_ENTITY_COORDS	.\openb3d\src\material.cpp	/^USE_ENTITY_COORDS,$/;"	e	enum:__anon4	file:
USE_EPSILON_TEST	.\openb3d\src\collidetri.c	22;"	d	file:
USE_FLOAT_1	.\openb3d\src\material.cpp	/^USE_FLOAT_1,$/;"	e	enum:__anon4	file:
USE_FLOAT_2	.\openb3d\src\material.cpp	/^USE_FLOAT_2,$/;"	e	enum:__anon4	file:
USE_FLOAT_3	.\openb3d\src\material.cpp	/^USE_FLOAT_3,$/;"	e	enum:__anon4	file:
USE_FLOAT_4	.\openb3d\src\material.cpp	/^USE_FLOAT_4,$/;"	e	enum:__anon4	file:
USE_INTEGER_1	.\openb3d\src\material.cpp	/^USE_INTEGER_1,$/;"	e	enum:__anon4	file:
USE_INTEGER_2	.\openb3d\src\material.cpp	/^USE_INTEGER_2,$/;"	e	enum:__anon4	file:
USE_INTEGER_3	.\openb3d\src\material.cpp	/^USE_INTEGER_3,$/;"	e	enum:__anon4	file:
USE_INTEGER_4	.\openb3d\src\material.cpp	/^USE_INTEGER_4,$/;"	e	enum:__anon4	file:
USE_MODELVIEW_MATRIX	.\openb3d\src\material.cpp	/^USE_MODELVIEW_MATRIX$/;"	e	enum:__anon4	file:
USE_MODEL_MATRIX	.\openb3d\src\material.cpp	/^USE_MODEL_MATRIX,$/;"	e	enum:__anon4	file:
USE_PROJ_MATRIX	.\openb3d\src\material.cpp	/^USE_PROJ_MATRIX,$/;"	e	enum:__anon4	file:
USE_SURFACE	.\openb3d\src\material.cpp	/^USE_SURFACE,$/;"	e	enum:__anon4	file:
USE_VIEW_MATRIX	.\openb3d\src\material.cpp	/^USE_VIEW_MATRIX,$/;"	e	enum:__anon4	file:
Update	.\openb3d\src\actions.cpp	/^void Action::Update(){$/;"	f	class:Action
Update	.\openb3d\src\camera.cpp	/^void Camera::Update(){$/;"	f	class:Camera
Update	.\openb3d\src\entity.h	/^	virtual void Update() {};$/;"	f	class:Entity
Update	.\openb3d\src\isosurface.h	/^	void Update(){}$/;"	f	class:Blob
Update	.\openb3d\src\isosurface.h	/^	void Update(){}$/;"	f	class:FieldArray
Update	.\openb3d\src\light.cpp	/^void Light::Update(){$/;"	f	class:Light
Update	.\openb3d\src\mesh.h	/^	void Update() {};$/;"	f	class:Mesh
Update	.\openb3d\src\particle.cpp	/^void ParticleEmitter::Update(){$/;"	f	class:ParticleEmitter
Update	.\openb3d\src\physics.cpp	/^void Constraint::Update(){$/;"	f	class:Constraint
Update	.\openb3d\src\physics.cpp	/^void RigidBody::Update(){$/;"	f	class:RigidBody
Update	.\openb3d\src\pivot.cpp	/^void Pivot::Update(){$/;"	f	class:Pivot
Update	.\openb3d\src\shadow.cpp	/^void ShadowObject::Update(Camera* Cam){$/;"	f	class:ShadowObject
UpdateAllEntities	.\openb3d\src\entity.cpp	/^void Entity::UpdateAllEntities(void(Update)(Entity* ent,Entity* ent2),Entity* ent2){$/;"	f	class:Entity
UpdateAnim	.\methods.cpp	/^void UpdateAnim( ShadowObject* obj ){$/;"	f
UpdateAnim	.\openb3d\src\shadow.cpp	/^void ShadowObject::UpdateAnim(){$/;"	f	class:ShadowObject
UpdateCaster	.\methods.cpp	/^void UpdateCaster( ShadowObject* obj ){$/;"	f
UpdateCaster	.\openb3d\src\shadow.cpp	/^void ShadowObject::UpdateCaster(){$/;"	f	class:ShadowObject
UpdateChildren	.\methods.cpp	/^void UpdateChildren( Entity* ent_p ){$/;"	f
UpdateChildren	.\openb3d\src\entity.cpp	/^void Entity::UpdateChildren(Entity* ent_p){$/;"	f	class:Entity
UpdateCollisions	.\openb3d\src\collision2.cpp	/^void UpdateCollisions(){$/;"	f
UpdateDynamicCollisions	.\openb3d\src\collision2.cpp	/^void UpdateDynamicCollisions(){$/;"	f
UpdateEntityAnim	.\methods.cpp	/^void UpdateEntityAnim( Mesh& mesh ){$/;"	f
UpdateEntityAnim	.\openb3d\src\global.cpp	/^void Global::UpdateEntityAnim(Mesh& mesh){$/;"	f	class:Global
UpdateEntityRender	.\openb3d\src\camera.cpp	/^void UpdateEntityRender(Entity* ent,Entity* cam){$/;"	f
UpdateMat	.\methods.cpp	/^void UpdateMat( Entity* obj,bool load_identity ){$/;"	f
UpdateMat	.\openb3d\src\entity.cpp	/^void Entity::UpdateMat(bool load_identity){$/;"	f	class:Entity
UpdateNormals	.\openb3d\src\functions.cpp	/^void UpdateNormals(Mesh* mesh){$/;"	f
UpdateNormals	.\openb3d\src\geosphere.cpp	/^void Geosphere::UpdateNormals (int preserve){$/;"	f	class:Geosphere
UpdateNormals	.\openb3d\src\mesh.cpp	/^void Mesh::UpdateNormals(){$/;"	f	class:Mesh
UpdateNormals	.\openb3d\src\surface.cpp	/^void Surface::UpdateNormals(){$/;"	f	class:Surface
UpdateNormals	.\openb3d\src\terrain.cpp	/^void Terrain::UpdateNormals(){$/;"	f	class:Terrain
UpdateParticle	.\openb3d\src\particle.h	/^	void (*UpdateParticle)(Entity* ent, int life);$/;"	m	class:ParticleEmitter
UpdateProjMatrix	.\methods.cpp	/^void UpdateProjMatrix( Camera* obj ){$/;"	f
UpdateProjMatrix	.\openb3d\src\camera.cpp	/^void Camera::UpdateProjMatrix(){$/;"	f	class:Camera
UpdateSampler	.\openb3d\src\shadermat.h	/^	char UpdateSampler;$/;"	m	class:Shader
UpdateShadow	.\methods.cpp	/^void UpdateShadow( Mesh* obj ){$/;"	f
UpdateShadow	.\openb3d\src\mesh.cpp	/^void Mesh::UpdateShadow(){$/;"	f	class:Mesh
UpdateSprite	.\methods.cpp	/^void UpdateSprite( Camera* obj,Sprite& sprite ){$/;"	f
UpdateSprite	.\openb3d\src\camera.cpp	/^void Camera::UpdateSprite(Sprite& sprite){$/;"	f	class:Camera
UpdateStaticCollisions	.\openb3d\src\collision2.cpp	/^void UpdateStaticCollisions(){$/;"	f
UpdateTerrain	.\methods.cpp	/^void UpdateTerrain( Terrain* obj ){$/;"	f
UpdateTerrain	.\openb3d\src\geosphere.cpp	/^void Geosphere::UpdateTerrain(){$/;"	f	class:Geosphere
UpdateTerrain	.\openb3d\src\octree.cpp	/^void OcTree::UpdateTerrain(){$/;"	f	class:OcTree
UpdateTerrain	.\openb3d\src\terrain.cpp	/^void Terrain::UpdateTerrain(){$/;"	f	class:Terrain
UpdateTerrain	.\openb3d\src\voxterrain.cpp	/^void VoxelTerrain::UpdateTerrain(){$/;"	f	class:VoxelTerrain
UpdateTexCoords	.\openb3d\src\functions.cpp	/^void UpdateTexCoords(Surface* surf){$/;"	f
UpdateTexCoords	.\openb3d\src\surface.cpp	/^void Surface::UpdateTexCoords(){$/;"	f	class:Surface
UpdateVBO	.\methods.cpp	/^void UpdateVBO( Surface* obj ){$/;"	f
UpdateVBO	.\openb3d\src\surface.cpp	/^void Surface::UpdateVBO(){$/;"	f	class:Surface
UpdateWorld	.\openb3d\src\functions.cpp	/^void UpdateWorld(float anim_speed){$/;"	f
UpdateWorld	.\openb3d\src\global.cpp	/^void Global::UpdateWorld(float anim_speed){$/;"	f	class:Global
Upper	.\openb3d\src\string_helper.cpp	/^string Upper(string s){$/;"	f
UseFloat	.\openb3d\src\functions.cpp	/^void UseFloat(Shader* material, char* name, float* v1){$/;"	f
UseFloat	.\openb3d\src\material.cpp	/^void Shader::UseFloat(string name, float* v1){$/;"	f	class:Shader
UseFloat2	.\openb3d\src\functions.cpp	/^void UseFloat2(Shader* material, char* name, float* v1, float* v2){$/;"	f
UseFloat2	.\openb3d\src\material.cpp	/^void Shader::UseFloat2(string name, float* v1, float* v2){$/;"	f	class:Shader
UseFloat3	.\openb3d\src\functions.cpp	/^void UseFloat3(Shader* material, char* name, float* v1, float* v2, float* v3){$/;"	f
UseFloat3	.\openb3d\src\material.cpp	/^void Shader::UseFloat3(string name, float* v1, float* v2, float* v3){$/;"	f	class:Shader
UseFloat4	.\openb3d\src\functions.cpp	/^void UseFloat4(Shader* material, char* name, float* v1, float* v2, float* v3, float* v4){$/;"	f
UseFloat4	.\openb3d\src\material.cpp	/^void Shader::UseFloat4(string name, float* v1, float* v2, float* v3, float* v4){$/;"	f	class:Shader
UseInteger	.\openb3d\src\functions.cpp	/^void UseInteger(Shader* material, char* name, int* v1){$/;"	f
UseInteger	.\openb3d\src\material.cpp	/^void Shader::UseInteger(string name, int* v1){$/;"	f	class:Shader
UseInteger2	.\openb3d\src\functions.cpp	/^void UseInteger2(Shader* material, char* name, int* v1, int* v2){$/;"	f
UseInteger2	.\openb3d\src\material.cpp	/^void Shader::UseInteger2(string name, int* v1, int* v2){$/;"	f	class:Shader
UseInteger3	.\openb3d\src\functions.cpp	/^void UseInteger3(Shader* material, char* name, int* v1, int* v2, int* v3){$/;"	f
UseInteger3	.\openb3d\src\material.cpp	/^void Shader::UseInteger3(string name, int* v1, int* v2, int* v3){$/;"	f	class:Shader
UseInteger4	.\openb3d\src\functions.cpp	/^void UseInteger4(Shader* material, char* name, int* v1, int* v2, int* v3, int* v4){$/;"	f
UseInteger4	.\openb3d\src\material.cpp	/^void Shader::UseInteger4(string name, int* v1, int* v2, int* v3, int* v4){$/;"	f	class:Shader
UseMatrix	.\openb3d\src\functions.cpp	/^void UseMatrix(Shader* material, char* name, int mode){$/;"	f
UseMatrix	.\openb3d\src\material.cpp	/^void Shader::UseMatrix(string name, int mode){$/;"	f	class:Shader
UseStencil	.\openb3d\src\functions.cpp	/^void UseStencil(Stencil* stencil){$/;"	f
UseStencil	.\openb3d\src\stencil.cpp	/^void Stencil::UseStencil(){$/;"	f	class:Stencil
UseSurface	.\openb3d\src\functions.cpp	/^void UseSurface(Shader* material, char* name, Surface* surf, int vbo){$/;"	f
UseSurface	.\openb3d\src\material.cpp	/^void Shader::UseSurface(string name, Surface* surf, int vbo){$/;"	f	class:Shader
VCreated	.\openb3d\src\shadow.h	/^	char VCreated;$/;"	m	class:ShadowObject
VECTOR_class	.\data.cpp	/^const int VECTOR_class=			13; \/\/ geom.h$/;"	v
VOXELSPRITE_class	.\data.cpp	/^const int VOXELSPRITE_class=	58;$/;"	v
VOXEL_H	.\openb3d\src\voxel.h	2;"	d
VOXTERRAIN_H	.\openb3d\src\voxterrain.h	2;"	d
VRTS	.\openb3d\src\model.cpp	/^const int VRTS=6;$/;"	v
Vector	.\openb3d\src\geom.h	/^	Vector( float x,float y,float z ):x(x),y(y),z(z){$/;"	f	class:Vector
Vector	.\openb3d\src\geom.h	/^	Vector():x(0),y(0),z(0){$/;"	f	class:Vector
Vector	.\openb3d\src\geom.h	/^class Vector{$/;"	c
VectorPitch	.\openb3d\src\functions.cpp	/^float VectorPitch(float vx,float vy,float vz){$/;"	f
VectorYaw	.\openb3d\src\functions.cpp	/^float VectorYaw(float vx,float vy,float vz){$/;"	f
Vertex	.\openb3d\src\tree.h	/^	struct Vertex{$/;"	s	class:MeshCollider
VertexAlpha	.\openb3d\src\functions.cpp	/^float VertexAlpha(Surface* surf,int vid){$/;"	f
VertexAlpha	.\openb3d\src\surface.cpp	/^float Surface::VertexAlpha(int vid){$/;"	f	class:Surface
VertexBlue	.\openb3d\src\functions.cpp	/^float VertexBlue(Surface* surf,int vid){$/;"	f
VertexBlue	.\openb3d\src\surface.cpp	/^float Surface::VertexBlue(int vid){$/;"	f	class:Surface
VertexColor	.\openb3d\src\functions.cpp	/^void VertexColor(Surface* surf,int vid,float r,float g,float b,float a){$/;"	f
VertexColor	.\openb3d\src\surface.cpp	/^void Surface::VertexColor(int vid,float r,float g,float b,float a){$/;"	f	class:Surface
VertexCoords	.\openb3d\src\functions.cpp	/^void VertexCoords(Surface* surf,int vid,float x,float y,float z){$/;"	f
VertexCoords	.\openb3d\src\surface.cpp	/^void Surface::VertexCoords(int vid,float x,float y,float z){$/;"	f	class:Surface
VertexCount	.\openb3d\src\3ds.cpp	/^int            VertexCount;$/;"	m	namespace:load3ds	file:
VertexDeform	.\methods.cpp	/^void VertexDeform(Mesh* ent){$/;"	f
VertexDeform	.\openb3d\src\animation.cpp	/^void Animation::VertexDeform(Mesh* ent){$/;"	f	class:Animation
VertexGreen	.\openb3d\src\functions.cpp	/^float VertexGreen(Surface* surf,int vid){$/;"	f
VertexGreen	.\openb3d\src\surface.cpp	/^float Surface::VertexGreen(int vid){$/;"	f	class:Surface
VertexNX	.\openb3d\src\functions.cpp	/^float VertexNX(Surface* surf,int vid){$/;"	f
VertexNX	.\openb3d\src\surface.cpp	/^float Surface::VertexNX(int vid){$/;"	f	class:Surface
VertexNY	.\openb3d\src\functions.cpp	/^float VertexNY(Surface* surf,int vid){$/;"	f
VertexNY	.\openb3d\src\surface.cpp	/^float Surface::VertexNY(int vid){$/;"	f	class:Surface
VertexNZ	.\openb3d\src\functions.cpp	/^float VertexNZ(Surface* surf,int vid){$/;"	f
VertexNZ	.\openb3d\src\surface.cpp	/^float Surface::VertexNZ(int vid){$/;"	f	class:Surface
VertexNormal	.\openb3d\src\functions.cpp	/^void VertexNormal(Surface* surf,int vid,float nx,float ny,float nz){$/;"	f
VertexNormal	.\openb3d\src\surface.cpp	/^void Surface::VertexNormal(int vid,float nx,float ny,float nz){$/;"	f	class:Surface
VertexRed	.\openb3d\src\functions.cpp	/^float VertexRed(Surface* surf,int vid){$/;"	f
VertexRed	.\openb3d\src\surface.cpp	/^float Surface::VertexRed(int vid){$/;"	f	class:Surface
VertexTexCoords	.\openb3d\src\functions.cpp	/^void VertexTexCoords(Surface* surf,int vid,float u,float v,float w,int coord_set){$/;"	f
VertexTexCoords	.\openb3d\src\surface.cpp	/^void Surface::VertexTexCoords(int vi,float u,float v,float w,int coords_set){$/;"	f	class:Surface
VertexU	.\openb3d\src\functions.cpp	/^float VertexU(Surface* surf,int vid,int coord_set){$/;"	f
VertexU	.\openb3d\src\surface.cpp	/^float Surface::VertexU(int vid,int coord_set){$/;"	f	class:Surface
VertexV	.\openb3d\src\functions.cpp	/^float VertexV(Surface* surf,int vid,int coord_set){$/;"	f
VertexV	.\openb3d\src\surface.cpp	/^float Surface::VertexV(int vid,int coord_set){$/;"	f	class:Surface
VertexW	.\openb3d\src\functions.cpp	/^float VertexW(Surface* surf,int vid,int coord_set){$/;"	f
VertexW	.\openb3d\src\surface.cpp	/^float Surface::VertexW(int vid,int coord_set){$/;"	f	class:Surface
VertexX	.\openb3d\src\functions.cpp	/^float VertexX(Surface* surf,int vid){$/;"	f
VertexX	.\openb3d\src\surface.cpp	/^float Surface::VertexX(int vid){$/;"	f	class:Surface
VertexY	.\openb3d\src\functions.cpp	/^float VertexY(Surface* surf,int vid){$/;"	f
VertexY	.\openb3d\src\surface.cpp	/^float Surface::VertexY(int vid){$/;"	f	class:Surface
VertexZ	.\openb3d\src\functions.cpp	/^float VertexZ(Surface* surf,int vid){$/;"	f
VertexZ	.\openb3d\src\surface.cpp	/^float Surface::VertexZ(int vid){$/;"	f	class:Surface
VolumeLength	.\openb3d\src\shadow.cpp	/^float ShadowObject::VolumeLength=1000;$/;"	m	class:ShadowObject	file:
VolumeLength	.\openb3d\src\shadow.h	/^	static float VolumeLength;$/;"	m	class:ShadowObject
VoxelSprite	.\openb3d\src\voxel.h	/^class VoxelSprite : public Mesh{$/;"	c
VoxelSpriteMaterial	.\openb3d\src\functions.cpp	/^void VoxelSpriteMaterial(VoxelSprite* voxelspr, Material* mat){$/;"	f
VoxelSpriteMaterial	.\openb3d\src\voxel.cpp	/^void VoxelSprite::VoxelSpriteMaterial(Material* mat){$/;"	f	class:VoxelSprite
VoxelTerrain	.\openb3d\src\voxterrain.h	/^class VoxelTerrain : public Terrain{$/;"	c
Wireframe	.\openb3d\src\functions.cpp	/^void Wireframe(int enable){$/;"	f
WriteByte	.\openb3d\src\file.cpp	/^void File::WriteByte(char c){$/;"	f	class:File
WriteFile	.\openb3d\src\file.cpp	/^File* File::WriteFile(string filename){$/;"	f	class:File
WriteFloat	.\openb3d\src\file.cpp	/^void File::WriteFloat(float f){$/;"	f	class:File
WriteInt	.\openb3d\src\file.cpp	/^void File::WriteInt(int i){$/;"	f	class:File
WriteLine	.\openb3d\src\file.cpp	/^void File::WriteLine(string s){$/;"	f	class:File
WriteLong	.\openb3d\src\file.cpp	/^void File::WriteLong(long l){$/;"	f	class:File
WriteShort	.\openb3d\src\file.cpp	/^void File::WriteShort(short s){$/;"	f	class:File
WriteString	.\openb3d\src\file.cpp	/^void File::WriteString(string s){$/;"	f	class:File
XLoader_FindAlphaChar	.\openb3d\src\x.cpp	/^int XLoader_FindAlphaChar(string s){$/;"	f	namespace:loadX
XLoader_FindBracketMatch	.\openb3d\src\x.cpp	/^int XLoader_FindBracketMatch(string s){$/;"	f	namespace:loadX
XLoader_FindTreeElements	.\openb3d\src\x.cpp	/^list<XLoader_TreeNode*> XLoader_FindTreeElements(XLoader_TreeNode* tree, string Template, int recur=0){$/;"	f	namespace:loadX
XLoader_MakeTree	.\openb3d\src\x.cpp	/^XLoader_TreeNode* XLoader_MakeTree(string s, XLoader_TreeNode* parent = 0){$/;"	f	namespace:loadX
XLoader_RemoveUnprintables	.\openb3d\src\x.cpp	/^string XLoader_RemoveUnprintables(string s){$/;"	f	namespace:loadX
XLoader_TreeNode	.\openb3d\src\x.cpp	/^	class XLoader_TreeNode{$/;"	c	namespace:loadX	file:
Xcf	.\openb3d\src\isosurface.cpp	/^static float Xcf, Ycf, Zcf;$/;"	v	file:
Xcf	.\openb3d\src\octree.cpp	/^static float Xcf, Ycf, Zcf;$/;"	v	file:
YCbCr_to_RGB_row	.\openb3d\src\stb_image.c	/^static void YCbCr_to_RGB_row(stbi__uint8 *out, const stbi__uint8 *y, const stbi__uint8 *pcb, const stbi__uint8 *pcr, int count, int step)$/;"	f	file:
Ycf	.\openb3d\src\isosurface.cpp	/^static float Xcf, Ycf, Zcf;$/;"	v	file:
Ycf	.\openb3d\src\octree.cpp	/^static float Xcf, Ycf, Zcf;$/;"	v	file:
ZFAST_BITS	.\openb3d\src\stb_image.c	1975;"	d	file:
ZFAST_MASK	.\openb3d\src\stb_image.c	1976;"	d	file:
Zcf	.\openb3d\src\isosurface.cpp	/^static float Xcf, Ycf, Zcf;$/;"	v	file:
Zcf	.\openb3d\src\octree.cpp	/^static float Xcf, Ycf, Zcf;$/;"	v	file:
_CRT_SECURE_NO_WARNINGS	.\openb3d\src\stb_image.c	193;"	d	file:
_CRT_SECURE_NO_WARNINGS	.\openb3d\src\stb_image.h	127;"	d
__bb_openb3d_openb3dlib_openb3dlib	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^int __bb_openb3d_openb3dlib_openb3dlib(){$/;"	f
__bb_openb3d_openb3dlib_openb3dlib	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^int __bb_openb3d_openb3dlib_openb3dlib(){$/;"	f
__bb_openb3d_openb3dlib_openb3dlib	.\.bmx\openb3dlib.bmx.release.win32.x64.c	/^int __bb_openb3d_openb3dlib_openb3dlib(){$/;"	f
__bb_openb3d_openb3dlib_openb3dlib	.\.bmx\openb3dlib.bmx.release.win32.x86.c	/^int __bb_openb3d_openb3dlib_openb3dlib(){$/;"	f
__bb_openb3d_openb3dlib_openb3dlib_inited	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static int __bb_openb3d_openb3dlib_openb3dlib_inited = 0;$/;"	v	file:
__bb_openb3d_openb3dlib_openb3dlib_inited	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static int __bb_openb3d_openb3dlib_openb3dlib_inited = 0;$/;"	v	file:
__bb_openb3d_openb3dlib_openb3dlib_inited	.\.bmx\openb3dlib.bmx.release.win32.x64.c	/^static int __bb_openb3d_openb3dlib_openb3dlib_inited = 0;$/;"	v	file:
__bb_openb3d_openb3dlib_openb3dlib_inited	.\.bmx\openb3dlib.bmx.release.win32.x86.c	/^static int __bb_openb3d_openb3dlib_openb3dlib_inited = 0;$/;"	v	file:
__functions_h__	.\openb3d\src\functions.h	2;"	d
_bb_openb3d_openb3dlib_source	.\.bmx\source.bmx.debug.win32.x64.c	/^int _bb_openb3d_openb3dlib_source(){$/;"	f
_bb_openb3d_openb3dlib_source	.\.bmx\source.bmx.debug.win32.x86.c	/^int _bb_openb3d_openb3dlib_source(){$/;"	f
_bb_openb3d_openb3dlib_source	.\.bmx\source.bmx.release.win32.x64.c	/^int _bb_openb3d_openb3dlib_source(){$/;"	f
_bb_openb3d_openb3dlib_source	.\.bmx\source.bmx.release.win32.x86.c	/^int _bb_openb3d_openb3dlib_source(){$/;"	f
_bb_openb3d_openb3dlib_source_inited	.\.bmx\source.bmx.debug.win32.x64.c	/^static int _bb_openb3d_openb3dlib_source_inited = 0;$/;"	v	file:
_bb_openb3d_openb3dlib_source_inited	.\.bmx\source.bmx.debug.win32.x86.c	/^static int _bb_openb3d_openb3dlib_source_inited = 0;$/;"	v	file:
_bb_openb3d_openb3dlib_source_inited	.\.bmx\source.bmx.release.win32.x64.c	/^static int _bb_openb3d_openb3dlib_source_inited = 0;$/;"	v	file:
_bb_openb3d_openb3dlib_source_inited	.\.bmx\source.bmx.release.win32.x86.c	/^static int _bb_openb3d_openb3dlib_source_inited = 0;$/;"	v	file:
_s0	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s0={$/;"	v	file:
_s0	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s0={$/;"	v	file:
_s1	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s1={$/;"	v	file:
_s1	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s1={$/;"	v	file:
_s10	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s10={$/;"	v	file:
_s10	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s10={$/;"	v	file:
_s11	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s11={$/;"	v	file:
_s11	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s11={$/;"	v	file:
_s12	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s12={$/;"	v	file:
_s12	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s12={$/;"	v	file:
_s13	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s13={$/;"	v	file:
_s13	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s13={$/;"	v	file:
_s14	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s14={$/;"	v	file:
_s14	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s14={$/;"	v	file:
_s15	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s15={$/;"	v	file:
_s15	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s15={$/;"	v	file:
_s16	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s16={$/;"	v	file:
_s16	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s16={$/;"	v	file:
_s17	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s17={$/;"	v	file:
_s17	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s17={$/;"	v	file:
_s18	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s18={$/;"	v	file:
_s18	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s18={$/;"	v	file:
_s19	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s19={$/;"	v	file:
_s19	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s19={$/;"	v	file:
_s2	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s2={$/;"	v	file:
_s2	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s2={$/;"	v	file:
_s20	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s20={$/;"	v	file:
_s20	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s20={$/;"	v	file:
_s21	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s21={$/;"	v	file:
_s21	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s21={$/;"	v	file:
_s22	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s22={$/;"	v	file:
_s22	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s22={$/;"	v	file:
_s23	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s23={$/;"	v	file:
_s23	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s23={$/;"	v	file:
_s24	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s24={$/;"	v	file:
_s24	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s24={$/;"	v	file:
_s25	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s25={$/;"	v	file:
_s25	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s25={$/;"	v	file:
_s26	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s26={$/;"	v	file:
_s26	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s26={$/;"	v	file:
_s27	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s27={$/;"	v	file:
_s27	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s27={$/;"	v	file:
_s28	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s28={$/;"	v	file:
_s28	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s28={$/;"	v	file:
_s29	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s29={$/;"	v	file:
_s29	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s29={$/;"	v	file:
_s3	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s3={$/;"	v	file:
_s3	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s3={$/;"	v	file:
_s30	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s30={$/;"	v	file:
_s30	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s30={$/;"	v	file:
_s31	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s31={$/;"	v	file:
_s31	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s31={$/;"	v	file:
_s32	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s32={$/;"	v	file:
_s32	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s32={$/;"	v	file:
_s33	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s33={$/;"	v	file:
_s33	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s33={$/;"	v	file:
_s34	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s34={$/;"	v	file:
_s34	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s34={$/;"	v	file:
_s35	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s35={$/;"	v	file:
_s35	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s35={$/;"	v	file:
_s36	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s36={$/;"	v	file:
_s36	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s36={$/;"	v	file:
_s37	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s37={$/;"	v	file:
_s37	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s37={$/;"	v	file:
_s38	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s38={$/;"	v	file:
_s38	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s38={$/;"	v	file:
_s39	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s39={$/;"	v	file:
_s39	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s39={$/;"	v	file:
_s4	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s4={$/;"	v	file:
_s4	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s4={$/;"	v	file:
_s40	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s40={$/;"	v	file:
_s40	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s40={$/;"	v	file:
_s41	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s41={$/;"	v	file:
_s41	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s41={$/;"	v	file:
_s42	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s42={$/;"	v	file:
_s42	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s42={$/;"	v	file:
_s43	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s43={$/;"	v	file:
_s43	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s43={$/;"	v	file:
_s44	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s44={$/;"	v	file:
_s44	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s44={$/;"	v	file:
_s45	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s45={$/;"	v	file:
_s45	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s45={$/;"	v	file:
_s46	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s46={$/;"	v	file:
_s46	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s46={$/;"	v	file:
_s47	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s47={$/;"	v	file:
_s47	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s47={$/;"	v	file:
_s48	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s48={$/;"	v	file:
_s48	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s48={$/;"	v	file:
_s49	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s49={$/;"	v	file:
_s49	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s49={$/;"	v	file:
_s5	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s5={$/;"	v	file:
_s5	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s5={$/;"	v	file:
_s50	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s50={$/;"	v	file:
_s50	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s50={$/;"	v	file:
_s51	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s51={$/;"	v	file:
_s51	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s51={$/;"	v	file:
_s52	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s52={$/;"	v	file:
_s52	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s52={$/;"	v	file:
_s53	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s53={$/;"	v	file:
_s53	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s53={$/;"	v	file:
_s54	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s54={$/;"	v	file:
_s54	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s54={$/;"	v	file:
_s55	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s55={$/;"	v	file:
_s55	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s55={$/;"	v	file:
_s56	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s56={$/;"	v	file:
_s56	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s56={$/;"	v	file:
_s57	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s57={$/;"	v	file:
_s57	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s57={$/;"	v	file:
_s58	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s58={$/;"	v	file:
_s58	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s58={$/;"	v	file:
_s59	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s59={$/;"	v	file:
_s59	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s59={$/;"	v	file:
_s6	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s6={$/;"	v	file:
_s6	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s6={$/;"	v	file:
_s60	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s60={$/;"	v	file:
_s60	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s60={$/;"	v	file:
_s61	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s61={$/;"	v	file:
_s61	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s61={$/;"	v	file:
_s62	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s62={$/;"	v	file:
_s62	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s62={$/;"	v	file:
_s63	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s63={$/;"	v	file:
_s63	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s63={$/;"	v	file:
_s64	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s64={$/;"	v	file:
_s64	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s64={$/;"	v	file:
_s65	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s65={$/;"	v	file:
_s65	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s65={$/;"	v	file:
_s66	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s66={$/;"	v	file:
_s66	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s66={$/;"	v	file:
_s67	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s67={$/;"	v	file:
_s67	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s67={$/;"	v	file:
_s68	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s68={$/;"	v	file:
_s68	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s68={$/;"	v	file:
_s69	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s69={$/;"	v	file:
_s69	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s69={$/;"	v	file:
_s7	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s7={$/;"	v	file:
_s7	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s7={$/;"	v	file:
_s70	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s70={$/;"	v	file:
_s70	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s70={$/;"	v	file:
_s71	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s71={$/;"	v	file:
_s71	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s71={$/;"	v	file:
_s72	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s72={$/;"	v	file:
_s72	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s72={$/;"	v	file:
_s8	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s8={$/;"	v	file:
_s8	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s8={$/;"	v	file:
_s9	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^static BBString _s9={$/;"	v	file:
_s9	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^static BBString _s9={$/;"	v	file:
a	.\openb3d\src\actions.h	/^	float a,b,c;$/;"	m	class:Action
a	.\openb3d\src\geom.h	/^	Vector a,b;$/;"	m	class:Box
accFrustum	.\methods.cpp	/^void accFrustum( Camera* obj,float left_,float right_,float bottom,float top,float zNear,float zFar,float pixdx,float pixdy,float eyedx,float eyedy,float focus ){$/;"	f
accFrustum	.\openb3d\src\camera.cpp	/^void Camera::accFrustum(float left_,float right_,float bottom,float top,float zNear,float zFar,float pixdx,float pixdy,float eyedx,float eyedy,float focus){$/;"	f	class:Camera
accPerspective	.\methods.cpp	/^void accPerspective( Camera* obj,float fovy,float aspect,float zNear,float zFar,float pixdx,float pixdy,float eyedx,float eyedy,float focus ){$/;"	f
accPerspective	.\openb3d\src\camera.cpp	/^void Camera::accPerspective(float fovy,float aspect,float zNear,float zFar,float pixdx,float pixdy,float eyedx,float eyedy,float focus){$/;"	f	class:Camera
acosdeg	.\openb3d\src\maths_helper.cpp	/^double acosdeg(double val)$/;"	f
act	.\openb3d\src\actions.h	/^	int act;$/;"	m	class:Action
action_list	.\openb3d\src\actions.cpp	/^list<Action*> Action::action_list;$/;"	m	class:Action	file:
action_list	.\openb3d\src\actions.h	/^	static list<Action*> action_list;$/;"	m	class:Action
all_touch_list	.\openb3d\src\touch.cpp	/^vector<Touch*> Touch::all_touch_list;$/;"	m	class:Touch	file:
all_touch_list	.\openb3d\src\touch.h	/^	static vector<Touch*> all_touch_list; \/\/ includes active and 'dead' touches - i.e. recently removed and cancelled touches$/;"	m	class:Touch
alloc_tmp	.\openb3d\src\geom.h	/^	static MMatrix &alloc_tmp(){ static int tmp=0;return tmps[tmp++&63];	}$/;"	f	class:MMatrix
alloc_tmp	.\openb3d\src\geom.h	/^	static Transform &alloc_tmp(){ static int tmp=0;return tmps[tmp++&63]; }$/;"	f	class:Transform
alpha	.\openb3d\src\brush.h	/^	float red,green,blue,alpha;$/;"	m	class:Brush
alpha	.\openb3d\src\stencil.h	/^	float alpha;$/;"	m	class:Stencil
alpha_enable	.\openb3d\src\global.cpp	/^int Global::alpha_enable=-1;$/;"	m	class:Global	file:
alpha_enable	.\openb3d\src\global.h	/^	static int alpha_enable;$/;"	m	class:Global
alpha_enable	.\openb3d\src\surface.h	/^	int alpha_enable;$/;"	m	class:Surface
alpha_order	.\openb3d\src\entity.h	/^	float alpha_order;$/;"	m	class:Entity
ambient_blue	.\openb3d\src\global.cpp	/^float Global::ambient_red=0.5,Global::ambient_green=0.5,Global::ambient_blue=0.5;$/;"	m	class:Global	file:
ambient_blue	.\openb3d\src\global.h	/^	static float ambient_red,ambient_green,ambient_blue;$/;"	m	class:Global
ambient_green	.\openb3d\src\global.cpp	/^float Global::ambient_red=0.5,Global::ambient_green=0.5,Global::ambient_blue=0.5;$/;"	m	class:Global	file:
ambient_green	.\openb3d\src\global.h	/^	static float ambient_red,ambient_green,ambient_blue;$/;"	m	class:Global
ambient_red	.\openb3d\src\global.cpp	/^float Global::ambient_red=0.5,Global::ambient_green=0.5,Global::ambient_blue=0.5;$/;"	m	class:Global	file:
ambient_red	.\openb3d\src\global.h	/^	static float ambient_red,ambient_green,ambient_blue;$/;"	m	class:Global
ambient_shader	.\openb3d\src\global.cpp	/^Shader* Global::ambient_shader=0;$/;"	m	class:Global	file:
ambient_shader	.\openb3d\src\global.h	/^	static Shader* ambient_shader;$/;"	m	class:Global
angle	.\openb3d\src\sprite.h	/^	float angle;$/;"	m	class:Sprite
angle	.\openb3d\src\texture.h	/^	float u_scale,v_scale,u_pos,v_pos,angle;$/;"	m	class:Texture
anim	.\openb3d\src\entity.h	/^	int anim; \/\/ true if mesh contains anim data$/;"	m	class:Entity
anim_dir	.\openb3d\src\entity.h	/^	int anim_dir; \/\/ 1=forward, -1=backward$/;"	m	class:Entity
anim_list	.\openb3d\src\entity.h	/^	int anim_list;$/;"	m	class:Entity
anim_mode	.\openb3d\src\entity.h	/^	int anim_mode;$/;"	m	class:Entity
anim_render	.\openb3d\src\entity.h	/^	int anim_render; \/\/ true to render as anim mesh$/;"	m	class:Entity
anim_seq	.\openb3d\src\entity.h	/^	int anim_seq;$/;"	m	class:Entity
anim_seqs_first	.\openb3d\src\entity.h	/^	vector<int> anim_seqs_first;$/;"	m	class:Entity
anim_seqs_last	.\openb3d\src\entity.h	/^	vector<int> anim_seqs_last;$/;"	m	class:Entity
anim_speed	.\openb3d\src\entity.h	/^	float anim_speed;$/;"	m	class:Entity
anim_speed	.\openb3d\src\global.cpp	/^float Global::anim_speed=1.0;$/;"	m	class:Global	file:
anim_speed	.\openb3d\src\global.h	/^	static float anim_speed;$/;"	m	class:Global
anim_surf_list	.\openb3d\src\mesh.h	/^	list<Surface*> anim_surf_list; \/\/ only used if mesh contains anim info, only contains vertex coords array, initialised upon loading b3d$/;"	m	class:Mesh
anim_time	.\openb3d\src\entity.h	/^	float anim_time;$/;"	m	class:Entity
anim_trans	.\openb3d\src\entity.h	/^	int anim_trans;$/;"	m	class:Entity
anim_update	.\openb3d\src\entity.h	/^	int anim_update;$/;"	m	class:Entity
animate_list	.\openb3d\src\entity.cpp	/^list<Entity*> Entity::animate_list;$/;"	m	class:Entity	file:
animate_list	.\openb3d\src\entity.h	/^	static list<Entity*> animate_list;$/;"	m	class:Entity
arb_program	.\openb3d\src\shadermat.h	/^	ProgramObject* arb_program;$/;"	m	class:Shader
asindeg	.\openb3d\src\maths_helper.cpp	/^double asindeg(double val)$/;"	f
at_eof	.\openb3d\src\stb_image.c	/^stbi_inline static int at_eof(stbi *s)$/;"	f	file:
atan2deg	.\openb3d\src\maths_helper.cpp	/^double atan2deg(double val,double val2)$/;"	f
atandeg	.\openb3d\src\maths_helper.cpp	/^double atandeg(double val)$/;"	f
ax	.\openb3d\src\collision.h	/^	float ax;$/;"	m	struct:CollisionInfo
ay	.\openb3d\src\collision.h	/^	float ay;$/;"	m	struct:CollisionInfo
az	.\openb3d\src\collision.h	/^	float az;$/;"	m	struct:CollisionInfo
b	.\openb3d\src\actions.h	/^	float a,b,c;$/;"	m	class:Action
b	.\openb3d\src\geom.h	/^	Vector a,b;$/;"	m	class:Box
b3dReadString	.\openb3d\src\model.cpp	/^string b3dReadString(File* file){$/;"	f
bgindex	.\openb3d\src\stb_image.c	/^   int flags, bgindex, ratio, transparent, eflags;$/;"	m	struct:stbi_gif_struct	file:
bit_reverse	.\openb3d\src\stb_image.c	/^stbi_inline static int bit_reverse(int v, int bits)$/;"	f	file:
bitcount	.\openb3d\src\stb_image.c	/^static int bitcount(unsigned int a)$/;"	f	file:
bitreverse16	.\openb3d\src\stb_image.c	/^stbi_inline static int bitreverse16(int n)$/;"	f	file:
blend	.\openb3d\src\brush.h	/^	int blend,fx;$/;"	m	class:Brush
blend	.\openb3d\src\sprite_batch.h	/^	int blend;$/;"	m	class:SpriteBatch
blend	.\openb3d\src\texture.h	/^	int flags,blend,coords;$/;"	m	class:Texture
blend_mode	.\openb3d\src\global.cpp	/^int Global::blend_mode=-1;$/;"	m	class:Global	file:
blend_mode	.\openb3d\src\global.h	/^	static int blend_mode;$/;"	m	class:Global
blue	.\openb3d\src\brush.h	/^	float red,green,blue,alpha;$/;"	m	class:Brush
blue	.\openb3d\src\light.h	/^	float red,green,blue;$/;"	m	class:Light
bmask	.\openb3d\src\stb_image.c	/^static stbi__uint32 bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};$/;"	v	file:
bmp_load	.\openb3d\src\stb_image.c	/^static stbi_uc *bmp_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
bmp_test	.\openb3d\src\stb_image.c	/^static int bmp_test(stbi *s)$/;"	f	file:
body	.\openb3d\src\physics.h	/^	Entity* body;$/;"	m	class:RigidBody
bones	.\openb3d\src\mesh.h	/^	vector<Bone*> bones;$/;"	m	class:Mesh
box	.\openb3d\src\tree.h	/^		Box box;$/;"	m	struct:MeshCollider::Node
boxCollide	.\openb3d\src\collision.cpp	/^bool Collision::boxCollide( const Line &line,float radius,const Box &box ){$/;"	f	class:Collision
box_d	.\openb3d\src\entity.h	/^	float box_x,box_y,box_z,box_w,box_h,box_d;$/;"	m	class:Entity
box_h	.\openb3d\src\entity.h	/^	float box_x,box_y,box_z,box_w,box_h,box_d;$/;"	m	class:Entity
box_w	.\openb3d\src\entity.h	/^	float box_x,box_y,box_z,box_w,box_h,box_d;$/;"	m	class:Entity
box_x	.\openb3d\src\entity.h	/^	float box_x,box_y,box_z,box_w,box_h,box_d;$/;"	m	class:Entity
box_y	.\openb3d\src\entity.h	/^	float box_x,box_y,box_z,box_w,box_h,box_d;$/;"	m	class:Entity
box_z	.\openb3d\src\entity.h	/^	float box_x,box_y,box_z,box_w,box_h,box_d;$/;"	m	class:Entity
brush	.\openb3d\src\3ds.cpp	/^Brush*         brush;$/;"	m	namespace:load3ds	file:
brush	.\openb3d\src\entity.h	/^	Brush brush;$/;"	m	class:Entity
brush	.\openb3d\src\surface.h	/^	Brush* brush;$/;"	m	class:Surface
buffer	.\openb3d\src\bank.h	/^	void* buffer;$/;"	m	class:Bank
buffer_start	.\openb3d\src\stb_image.c	/^   stbi__uint8 buffer_start[128];$/;"	m	struct:__anon9	file:
buffercenter	.\openb3d\src\isosurface.h	/^	int* buffercenter;$/;"	m	class:Fluid
buflen	.\openb3d\src\stb_image.c	/^   int buflen;$/;"	m	struct:__anon9	file:
build_huffman	.\openb3d\src\stb_image.c	/^static int build_huffman(huffman *h, int *count)$/;"	f	file:
bx	.\openb3d\src\collision.h	/^	float bx;$/;"	m	struct:CollisionInfo
by	.\openb3d\src\collision.h	/^	float by;$/;"	m	struct:CollisionInfo
bz	.\openb3d\src\collision.h	/^	float bz;$/;"	m	struct:CollisionInfo
c	.\openb3d\src\actions.h	/^	float a,b,c;$/;"	m	class:Action
c_col_tree	.\openb3d\src\mesh.h	/^	MeshCollider* c_col_tree;$/;"	m	class:Mesh
c_col_tree	.\openb3d\src\terrain.h	/^	MeshCollider* c_col_tree;$/;"	m	class:Terrain
c_col_tree_geosub	.\openb3d\src\geosphere.cpp	/^void Geosphere::c_col_tree_geosub(int l, float v2[], float v1[], float v0[]){$/;"	f	class:Geosphere
cache_frame	.\openb3d\src\brush.h	/^	unsigned int cache_frame[8];$/;"	m	class:Brush
cam_list	.\openb3d\src\camera.cpp	/^list<Camera*> Camera::cam_list;$/;"	m	class:Camera	file:
cam_list	.\openb3d\src\camera.h	/^	static list<Camera*> cam_list;$/;"	m	class:Camera
camera_in_use	.\openb3d\src\global.cpp	/^Camera* Global::camera_in_use;$/;"	m	class:Global	file:
camera_in_use	.\openb3d\src\global.h	/^	static Camera* camera_in_use;$/;"	m	class:Global
cast_shadow	.\openb3d\src\light.h	/^	char cast_shadow;$/;"	m	class:Light
cells	.\openb3d\src\isosurface.h	/^	int* cells;$/;"	m	class:Fluid
centre	.\openb3d\src\geom.h	/^	Vector centre()const{$/;"	f	class:Box
channel	.\openb3d\src\stb_image.c	/^   stbi_uc size,type,channel;$/;"	m	struct:__anon20	file:
charge	.\openb3d\src\isosurface.h	/^	float charge;$/;"	m	class:Blob
check_png_header	.\openb3d\src\stb_image.c	/^static int check_png_header(stbi *s)$/;"	f	file:
child	.\openb3d\src\octree.h	/^	OcTreeChild child;$/;"	m	class:OcTree
child	.\openb3d\src\octree.h	/^	OcTreeChild* child[8];$/;"	m	class:OcTreeChild
child_list	.\openb3d\src\entity.h	/^	list<Entity*> child_list;$/;"	m	class:Entity
children	.\openb3d\src\x.cpp	/^		list<XLoader_TreeNode*> children;$/;"	m	class:loadX::XLoader_TreeNode	file:
chunk	.\openb3d\src\stb_image.c	/^} chunk;$/;"	t	typeref:struct:__anon17	file:
clamp	.\openb3d\src\stb_image.c	/^stbi_inline static stbi__uint8 clamp(int x)$/;"	f	file:
class_name	.\openb3d\src\entity.h	/^	string class_name;$/;"	m	class:Entity
cleanup_jpeg	.\openb3d\src\stb_image.c	/^static void cleanup_jpeg(jpeg *j)$/;"	f	file:
clear	.\openb3d\src\geom.h	/^	void clear(){$/;"	f	class:Box
clear	.\openb3d\src\geom.h	/^	void clear(){$/;"	f	class:Vector
clearCollisions	.\openb3d\src\collision2.cpp	/^void clearCollisions(){$/;"	f
cls_b	.\openb3d\src\camera.h	/^	float cls_r,cls_g,cls_b;$/;"	m	class:Camera
cls_b	.\openb3d\src\stencil.h	/^	float cls_r,cls_g,cls_b;$/;"	m	class:Stencil
cls_color	.\openb3d\src\camera.h	/^	bool cls_color,cls_zbuffer;$/;"	m	class:Camera
cls_color	.\openb3d\src\stencil.h	/^	bool cls_color,cls_zbuffer;$/;"	m	class:Stencil
cls_g	.\openb3d\src\camera.h	/^	float cls_r,cls_g,cls_b;$/;"	m	class:Camera
cls_g	.\openb3d\src\stencil.h	/^	float cls_r,cls_g,cls_b;$/;"	m	class:Stencil
cls_r	.\openb3d\src\camera.h	/^	float cls_r,cls_g,cls_b;$/;"	m	class:Camera
cls_r	.\openb3d\src\stencil.h	/^	float cls_r,cls_g,cls_b;$/;"	m	class:Stencil
cls_zbuffer	.\openb3d\src\camera.h	/^	bool cls_color,cls_zbuffer;$/;"	m	class:Camera
cls_zbuffer	.\openb3d\src\stencil.h	/^	bool cls_color,cls_zbuffer;$/;"	m	class:Stencil
cnt_tris	.\openb3d\src\shadow.h	/^	int cnt_tris;$/;"	m	class:ShadowObject
code	.\openb3d\src\stb_image.c	/^   stbi__uint16 code[256];$/;"	m	struct:__anon11	file:
code_bits	.\openb3d\src\stb_image.c	/^   int            code_bits;   \/\/ number of valid bits$/;"	m	struct:__anon12	file:
code_buffer	.\openb3d\src\stb_image.c	/^   stbi__uint32         code_buffer; \/\/ jpeg entropy-coded buffer$/;"	m	struct:__anon12	file:
code_buffer	.\openb3d\src\stb_image.c	/^   stbi__uint32 code_buffer;$/;"	m	struct:__anon16	file:
codes	.\openb3d\src\stb_image.c	/^   stbi_gif_lzw codes[4096];$/;"	m	struct:stbi_gif_struct	file:
cofactor	.\openb3d\src\geom.h	/^	MMatrix &cofactor()const{$/;"	f	class:MMatrix
col_coords	.\openb3d\src\collision.cpp	/^Vector col_coords;$/;"	v
col_index	.\openb3d\src\collision.cpp	/^int col_index;	$/;"	v
col_method	.\openb3d\src\collision2.h	/^	int col_method;$/;"	m	class:CollisionPair
col_normal	.\openb3d\src\collision.cpp	/^Vector col_normal;$/;"	v
col_pos	.\openb3d\src\collision.cpp	/^Vector col_pos;$/;"	v
col_surface	.\openb3d\src\collision.cpp	/^int col_surface;$/;"	v
col_time	.\openb3d\src\collision.cpp	/^int col_time;$/;"	v
col_tree_sub	.\methods.cpp	/^void col_tree_sub( Terrain* obj,int l,float v0[],float v1[],float v2[] ){$/;"	f
col_tree_sub	.\openb3d\src\terrain.cpp	/^void Terrain::col_tree_sub(int l, float v0[], float v1[], float v2[]){$/;"	f	class:Terrain
coll_line	.\openb3d\src\collision.h	/^	Line coll_line;$/;"	m	struct:CollisionInfo
collide	.\openb3d\src\tree.cpp	/^bool MeshCollider::collide( const Box &line_box,const Line &line,float radius,const Transform &tform,Collision *curr_coll,MeshCollider::Node *node ){$/;"	f	class:MeshCollider
collide	.\openb3d\src\tree.cpp	/^bool MeshCollider::collide( const Line &line,float radius,const Transform &t,Collision *curr_coll ){$/;"	f	class:MeshCollider
collision	.\openb3d\src\entity.h	/^	vector<CollisionImpact*> collision;$/;"	m	class:Entity
collision_type	.\openb3d\src\entity.h	/^	int collision_type;$/;"	m	class:Entity
color_table	.\openb3d\src\stb_image.c	/^   stbi__uint8 *color_table;$/;"	m	struct:stbi_gif_struct	file:
compute_huffman_codes	.\openb3d\src\stb_image.c	/^static int compute_huffman_codes(zbuf *a)$/;"	f	file:
compute_transparency	.\openb3d\src\stb_image.c	/^static int compute_transparency(png *z, stbi__uint8 tc[3], int out_n)$/;"	f	file:
compute_y	.\openb3d\src\stb_image.c	/^static stbi__uint8 compute_y(int r, int g, int b)$/;"	f	file:
constraint_list	.\openb3d\src\physics.cpp	/^list<Constraint*> Constraint::constraint_list;$/;"	m	class:Constraint	file:
constraint_list	.\openb3d\src\physics.h	/^	static list<Constraint*> constraint_list;$/;"	m	class:Constraint
contains	.\openb3d\src\geom.h	/^	bool contains( const Vector &q ){$/;"	f	class:Box
content	.\openb3d\src\x.cpp	/^		string content;$/;"	m	class:loadX::XLoader_TreeNode	file:
convertToDouble	.\openb3d\src\x.cpp	/^inline double convertToDouble(std::string const& s)$/;"	f	namespace:loadX
convert_format	.\openb3d\src\stb_image.c	/^static unsigned char *convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)$/;"	f	file:
coords	.\openb3d\src\texture.h	/^	int flags,blend,coords;$/;"	m	class:Texture
coords	.\openb3d\src\tree.h	/^		Vector coords;$/;"	m	struct:MeshCollider::Vertex
coplanar_tri_tri	.\openb3d\src\collidetri.c	/^int coplanar_tri_tri(float N[3],float V0[3],float V1[3],float V2[3],$/;"	f
corner	.\openb3d\src\geom.h	/^	Vector corner( int n )const{$/;"	f	class:Box
cosdeg	.\openb3d\src\maths_helper.cpp	/^double cosdeg(double degrees)$/;"	f
cp_list	.\openb3d\src\collision2.cpp	/^list<CollisionPair*> CollisionPair::cp_list;$/;"	m	class:CollisionPair	file:
cp_list	.\openb3d\src\collision2.h	/^	static list<CollisionPair*> cp_list;$/;"	m	class:CollisionPair
createLeaf	.\openb3d\src\tree.cpp	/^MeshCollider::Node *MeshCollider::createLeaf( const vector<int> &tris ){$/;"	f	class:MeshCollider
createNode	.\openb3d\src\tree.cpp	/^MeshCollider::Node *MeshCollider::createNode( const vector<int> &tris ){$/;"	f	class:MeshCollider
create_png_image	.\openb3d\src\stb_image.c	/^static int create_png_image(png *a, stbi__uint8 *raw, stbi__uint32 raw_len, int out_n, int interlaced)$/;"	f	file:
create_png_image_raw	.\openb3d\src\stb_image.c	/^static int create_png_image_raw(png *a, stbi__uint8 *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y)$/;"	f	file:
cross	.\openb3d\src\geom.h	/^	Vector cross( const Vector &q )const{$/;"	f	class:Vector
cube_face	.\openb3d\src\texture.h	/^	int cube_face,cube_mode;$/;"	m	class:Texture
cube_mode	.\openb3d\src\texture.h	/^	int cube_face,cube_mode;$/;"	m	class:Texture
cull	.\openb3d\src\shadow.h	/^	int cull;$/;"	m	class:ShadowTriangle
cull_radius	.\openb3d\src\entity.h	/^	float cull_radius;$/;"	m	class:Entity
cur_x	.\openb3d\src\stb_image.c	/^   int cur_x, cur_y;$/;"	m	struct:stbi_gif_struct	file:
cur_y	.\openb3d\src\stb_image.c	/^   int cur_x, cur_y;$/;"	m	struct:stbi_gif_struct	file:
d	.\openb3d\src\csg.h	/^	float d;$/;"	m	class:CSGTriangle
d	.\openb3d\src\geom.h	/^	Vector o,d;$/;"	m	class:Line
d	.\openb3d\src\geom.h	/^	float d;$/;"	m	class:Plane
data	.\openb3d\src\isosurface.h	/^	float* data;$/;"	m	class:FieldArray
data	.\openb3d\src\shadow.h	/^	float data[7];$/;"	m	class:Edge
data	.\openb3d\src\stb_image.c	/^      stbi__uint8 *data;$/;"	m	struct:__anon12::__anon13	file:
data_array	.\openb3d\src\isosurface.cpp	/^static FieldArray* data_array;$/;"	v	file:
dc_pred	.\openb3d\src\stb_image.c	/^      int dc_pred;$/;"	m	struct:__anon12::__anon13	file:
decls	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^struct BBDebugScope_365{int kind; const char *name; BBDebugDecl decls[366]; };$/;"	m	struct:BBDebugScope_365	file:
decls	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^struct BBDebugScope_365{int kind; const char *name; BBDebugDecl decls[366]; };$/;"	m	struct:BBDebugScope_365	file:
decode	.\openb3d\src\stb_image.c	/^stbi_inline static int decode(jpeg *j, huffman *h)$/;"	f	file:
decode_block	.\openb3d\src\stb_image.c	/^static int decode_block(jpeg *j, short data[64], huffman *hdc, huffman *hac, int b)$/;"	f	file:
decode_jpeg_header	.\openb3d\src\stb_image.c	/^static int decode_jpeg_header(jpeg *z, int scan)$/;"	f	file:
decode_jpeg_image	.\openb3d\src\stb_image.c	/^static int decode_jpeg_image(jpeg *j)$/;"	f	file:
default_distance	.\openb3d\src\stb_image.c	/^static stbi__uint8 default_length[288], default_distance[32];$/;"	v	file:
default_length	.\openb3d\src\stb_image.c	/^static stbi__uint8 default_length[288], default_distance[32];$/;"	v	file:
default_program	.\openb3d\src\material.cpp	/^static int default_program=0;$/;"	v	file:
deg2rad	.\openb3d\src\maths_helper.h	/^inline double deg2rad(double degrees)$/;"	f
delete_list	.\openb3d\src\octree.cpp	/^static list<Mesh*>* delete_list;$/;"	v	file:
delta	.\openb3d\src\stb_image.c	/^   int    delta[17];   \/\/ old 'firstsymbol' - old 'firstcode'$/;"	m	struct:__anon11	file:
depth	.\data.cpp	/^int Global::mode,Global::depth,Global::rate;$/;"	m	class:Global	file:
depth	.\openb3d\src\geom.h	/^	float depth()const{$/;"	f	class:Box
depth	.\openb3d\src\global.h	/^	static int width,height,mode,depth,rate;$/;"	m	class:Global
depth	.\openb3d\src\isosurface.h	/^	int width, height, depth;$/;"	m	class:FieldArray
depth	.\openb3d\src\octree.h	/^	float x,y,z, width, height, depth;$/;"	m	class:OcTreeChild
dequant	.\openb3d\src\stb_image.c	/^   stbi__uint8 dequant[4][64];$/;"	m	struct:__anon12	file:
dequant2	.\openb3d\src\stb_image.c	/^   unsigned short dequant2[4][64];$/;"	m	struct:__anon12	file:
des_type	.\openb3d\src\collision2.h	/^	int des_type;$/;"	m	class:CollisionPair
determinant	.\openb3d\src\geom.h	/^	float determinant()const{$/;"	f	class:MMatrix
dezigzag	.\openb3d\src\stb_image.c	/^static stbi__uint8 dezigzag[64+15] =$/;"	v	file:
dir	.\openb3d\src\collision.h	/^	Vector dir;$/;"	m	struct:CollisionInfo
dist	.\openb3d\src\csg.cpp	/^float dist(float x, float y, float z, float x2, float y2, float z2){$/;"	f	namespace:CSG
dist_base	.\openb3d\src\stb_image.c	/^static int dist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,$/;"	v	file:
dist_extra	.\openb3d\src\stb_image.c	/^static int dist_extra[32] =$/;"	v	file:
distance	.\openb3d\src\geom.h	/^	float distance( const Vector &q )const{$/;"	f	class:Plane
distance	.\openb3d\src\geom.h	/^	float distance( const Vector &q )const{$/;"	f	class:Vector
div16	.\openb3d\src\stb_image.c	1729;"	d	file:
div4	.\openb3d\src\stb_image.c	1680;"	d	file:
do_png	.\openb3d\src\stb_image.c	/^static unsigned char *do_png(png *p, int *x, int *y, int *n, int req_comp)$/;"	f	file:
do_zlib	.\openb3d\src\stb_image.c	/^static int do_zlib(zbuf *a, char *obuf, int olen, int exp, int parse_header)$/;"	f	file:
dot	.\openb3d\src\geom.h	/^	float dot( const Quat &q )const{$/;"	f	struct:Quat
dot	.\openb3d\src\geom.h	/^	float dot( const Vector &q )const{$/;"	f	class:Vector
dradius	.\openb3d\src\geosphere.h	/^	float dradius;$/;"	m	class:Geosphere
dradius	.\openb3d\src\terrain.h	/^	float dradius;$/;"	m	class:Terrain
drawsub	.\methods.cpp	/^void drawsub( Terrain* obj,int l,float v0[],float v1[],float v2[] ){$/;"	f
drawsub	.\openb3d\src\terrain.cpp	/^void Terrain::drawsub(int l, float v0[], float v1[], float v2[]){$/;"	f	class:Terrain
dst_radius	.\openb3d\src\collision.h	/^	float dst_radius;$/;"	m	struct:CollisionInfo
dv	.\openb3d\src\collision.h	/^	Vector dv;$/;"	m	struct:CollisionInfo
dynamic	.\openb3d\src\entity.h	/^	int dynamic;$/;"	m	class:Entity
dynamic_pitch	.\openb3d\src\entity.h	/^	float dynamic_x,dynamic_y,dynamic_z,dynamic_yaw,dynamic_pitch,dynamic_roll;$/;"	m	class:Entity
dynamic_roll	.\openb3d\src\entity.h	/^	float dynamic_x,dynamic_y,dynamic_z,dynamic_yaw,dynamic_pitch,dynamic_roll;$/;"	m	class:Entity
dynamic_x	.\openb3d\src\entity.h	/^	float dynamic_x,dynamic_y,dynamic_z,dynamic_yaw,dynamic_pitch,dynamic_roll;$/;"	m	class:Entity
dynamic_y	.\openb3d\src\entity.h	/^	float dynamic_x,dynamic_y,dynamic_z,dynamic_yaw,dynamic_pitch,dynamic_roll;$/;"	m	class:Entity
dynamic_yaw	.\openb3d\src\entity.h	/^	float dynamic_x,dynamic_y,dynamic_z,dynamic_yaw,dynamic_pitch,dynamic_roll;$/;"	m	class:Entity
dynamic_z	.\openb3d\src\entity.h	/^	float dynamic_x,dynamic_y,dynamic_z,dynamic_yaw,dynamic_pitch,dynamic_roll;$/;"	m	class:Entity
e	.\openb3d\src\stb_image.c	/^static int e(const char *str)$/;"	f	file:
e	.\openb3d\src\stb_image.c	529;"	d	file:
e	.\openb3d\src\stb_image.c	531;"	d	file:
e	.\openb3d\src\stb_image.c	533;"	d	file:
edgeTable	.\openb3d\src\isosurface.cpp	/^\/*extern*\/ const int edgeTable[256]={$/;"	v
edgeTest	.\openb3d\src\collision.cpp	/^static bool edgeTest( const Vector &v0,const Vector &v1,const Vector &pn,const Vector &en,const Line &line,float radius,Collision *curr_coll ){$/;"	f	file:
eflags	.\openb3d\src\stb_image.c	/^   int flags, bgindex, ratio, transparent, eflags;$/;"	m	struct:stbi_gif_struct	file:
emitter_list	.\openb3d\src\particle.cpp	/^list<ParticleEmitter*> ParticleEmitter::emitter_list;$/;"	m	class:ParticleEmitter	file:
emitter_list	.\openb3d\src\particle.h	/^	static list<ParticleEmitter*> emitter_list;$/;"	m	class:ParticleEmitter
empty	.\openb3d\src\geom.h	/^	bool empty()const{$/;"	f	class:Box
ent	.\openb3d\src\actions.h	/^	Entity* ent;$/;"	m	class:Action
ent	.\openb3d\src\collision2.h	/^	Entity* ent;$/;"	m	class:CollisionImpact
ent	.\openb3d\src\particle.h	/^		Entity* ent;$/;"	m	struct:ParticleEmitter::ParticleData
ent	.\openb3d\src\shadermat.h	/^		Entity* ent;$/;"	m	union:ShaderData::__anon5
ent_list	.\openb3d\src\pick.cpp	/^list<Entity*> Pick::ent_list;$/;"	m	class:Pick	file:
ent_list	.\openb3d\src\pick.h	/^	static list<Entity*> ent_list; \/\/ list containing pickable entities$/;"	m	class:Pick
ent_lists	.\openb3d\src\collision2.cpp	/^list<Entity*> CollisionPair::ent_lists[MAX_TYPES];$/;"	m	class:CollisionPair	file:
ent_lists	.\openb3d\src\collision2.h	/^	static list<Entity*> ent_lists[MAX_TYPES];$/;"	m	class:CollisionPair
entity_list	.\openb3d\src\entity.cpp	/^list<Entity*> Entity::entity_list;$/;"	m	class:Entity	file:
entity_list	.\openb3d\src\entity.h	/^	static list<Entity*> entity_list;$/;"	m	class:Entity
eof	.\openb3d\src\stb_image.c	/^   int      (*eof)   (void *user);                       \/\/ returns nonzero if we are at end of file\/data$/;"	m	struct:__anon8	file:
eof	.\openb3d\src\stb_image.h	/^   int      (*eof)   (void *user);                       \/\/ returns nonzero if we are at end of file\/data$/;"	m	struct:__anon22
epf	.\openb3d\src\stb_image.c	536;"	d	file:
epuc	.\openb3d\src\stb_image.c	537;"	d	file:
expand	.\openb3d\src\geom.h	/^	void expand( float n ){$/;"	f	class:Box
expand	.\openb3d\src\stb_image.c	/^static int expand(zbuf *z, int n)  \/\/ need to make room for n bytes$/;"	f	file:
expand_palette	.\openb3d\src\stb_image.c	/^static int expand_palette(png *a, stbi__uint8 *palette, int len, int pal_img_n)$/;"	f	file:
expanded	.\openb3d\src\stb_image.c	/^   stbi__uint8 *idata, *expanded, *out;$/;"	m	struct:__anon18	file:
extend_receive	.\openb3d\src\stb_image.c	/^stbi_inline static int extend_receive(jpeg *j, int n)$/;"	f	file:
eyepoint	.\openb3d\src\terrain.h	/^	Camera* eyepoint; 			\/\/reference to camera$/;"	m	class:Terrain
f2f	.\openb3d\src\stb_image.c	1227;"	d	file:
fList	.\openb3d\src\shaderobject.h	/^	list<ShaderObject*> fList;	\/\/ Frag shader list. A List of what Frag shaders are attached to this ProgramObject$/;"	m	class:ProgramObject
failure_reason	.\openb3d\src\stb_image.c	/^static const char *failure_reason;$/;"	v	file:
far	.\openb3d\src\octree.h	/^	float near,far;$/;"	m	class:OcTreeChild
fast	.\openb3d\src\stb_image.c	/^   stbi__uint16 fast[1 << ZFAST_BITS];$/;"	m	struct:__anon15	file:
fast	.\openb3d\src\stb_image.c	/^   stbi__uint8  fast[1 << FAST_BITS];$/;"	m	struct:__anon11	file:
fieldarray	.\openb3d\src\isosurface.h	/^	FieldArray* fieldarray;$/;"	m	class:Fluid
file	.\openb3d\src\texture.h	/^	string file;$/;"	m	class:Texture
file_abs	.\openb3d\src\texture.h	/^	string file_abs;$/;"	m	class:Texture
filepath_in_use	.\openb3d\src\file.cpp	/^static string filepath_in_use;$/;"	v	file:
fill_bits	.\openb3d\src\stb_image.c	/^static void fill_bits(zbuf *z)$/;"	f	file:
findmax	.\openb3d\src\csg.cpp	/^float findmax(float a,float b,float c){$/;"	f	namespace:CSG
findmin	.\openb3d\src\csg.cpp	/^float findmin(float a,float b,float c){$/;"	f	namespace:CSG
first	.\openb3d\src\stb_image.c	/^   stbi__uint8 first;$/;"	m	struct:stbi_gif_lzw_struct	file:
first_row_filter	.\openb3d\src\stb_image.c	/^static stbi__uint8 first_row_filter[5] =$/;"	v	file:
firstcode	.\openb3d\src\stb_image.c	/^   stbi__uint16 firstcode[16];$/;"	m	struct:__anon15	file:
firstsymbol	.\openb3d\src\stb_image.c	/^   stbi__uint16 firstsymbol[16];$/;"	m	struct:__anon15	file:
flags	.\openb3d\src\animation_keys.h	/^	vector<int> flags;$/;"	m	class:AnimationKeys
flags	.\openb3d\src\stb_image.c	/^   int flags, bgindex, ratio, transparent, eflags;$/;"	m	struct:stbi_gif_struct	file:
flags	.\openb3d\src\texture.h	/^	int flags,blend,coords;$/;"	m	class:Texture
flags	.\openb3d\src\texture_filter.h	/^	int flags;$/;"	m	class:TextureFilter
float2fixed	.\openb3d\src\stb_image.c	1766;"	d	file:
float2int	.\openb3d\src\stb_image.c	919;"	d	file:
fluid	.\openb3d\src\isosurface.h	/^	Fluid* fluid;$/;"	m	class:Blob
fog_b	.\openb3d\src\camera.h	/^	float fog_r,fog_g,fog_b;$/;"	m	class:Camera
fog_enabled	.\openb3d\src\global.cpp	/^int Global::fog_enabled=false;$/;"	m	class:Global	file:
fog_enabled	.\openb3d\src\global.h	/^	static int fog_enabled; \/\/ used to keep track of whether fog is enabled between camera update and mesh render$/;"	m	class:Global
fog_g	.\openb3d\src\camera.h	/^	float fog_r,fog_g,fog_b;$/;"	m	class:Camera
fog_mode	.\openb3d\src\camera.h	/^	int fog_mode;$/;"	m	class:Camera
fog_r	.\openb3d\src\camera.h	/^	float fog_r,fog_g,fog_b;$/;"	m	class:Camera
fog_range_far	.\openb3d\src\camera.h	/^	float fog_range_near,fog_range_far;$/;"	m	class:Camera
fog_range_near	.\openb3d\src\camera.h	/^	float fog_range_near,fog_range_far;$/;"	m	class:Camera
fp	.\openb3d\src\shadermat.h	/^		float* fp[4];$/;"	m	union:ShaderData::__anon5
fragShaderCount	.\openb3d\src\shaderobject.h	/^	int fragShaderCount;$/;"	m	class:ProgramObject
framebuffer	.\openb3d\src\texture.h	/^	unsigned int* framebuffer;$/;"	m	class:Texture
frames	.\openb3d\src\animation_keys.h	/^	int frames;$/;"	m	class:AnimationKeys
frames	.\openb3d\src\texture.h	/^	unsigned int* frames;$/;"	m	class:Texture
frustum	.\openb3d\src\camera.h	/^	float frustum[6][4];$/;"	m	class:Camera
fsh	.\openb3d\src\stb_image.c	1228;"	d	file:
fx	.\openb3d\src\brush.h	/^	int blend,fx;$/;"	m	class:Brush
fx1	.\openb3d\src\global.cpp	/^int Global::fx1=-1;$/;"	m	class:Global	file:
fx1	.\openb3d\src\global.h	/^	static int fx1;$/;"	m	class:Global
fx2	.\openb3d\src\global.cpp	/^int Global::fx2=-1;$/;"	m	class:Global	file:
fx2	.\openb3d\src\global.h	/^	static int fx2;$/;"	m	class:Global
geosub	.\openb3d\src\geosphere.cpp	/^void Geosphere::geosub(int l, float v2[], float v1[], float v0[]){$/;"	f	class:Geosphere
get16	.\openb3d\src\stb_image.c	/^static int get16(stbi *s)$/;"	f	file:
get16le	.\openb3d\src\stb_image.c	/^static int get16le(stbi *s)$/;"	f	file:
get32	.\openb3d\src\stb_image.c	/^static stbi__uint32 get32(stbi *s)$/;"	f	file:
get32le	.\openb3d\src\stb_image.c	/^static stbi__uint32 get32le(stbi *s)$/;"	f	file:
get8	.\openb3d\src\stb_image.c	/^stbi_inline static int get8(stbi *s)$/;"	f	file:
get8u	.\openb3d\src\stb_image.c	/^stbi_inline static stbi__uint8 get8u(stbi *s)$/;"	f	file:
get_chunk_header	.\openb3d\src\stb_image.c	/^static chunk get_chunk_header(stbi *s)$/;"	f	file:
get_marker	.\openb3d\src\stb_image.c	/^static stbi__uint8 get_marker(jpeg *j)$/;"	f	file:
getn	.\openb3d\src\stb_image.c	/^static int getn(stbi *s, stbi_uc *buffer, int n)$/;"	f	file:
gif_test	.\openb3d\src\stb_image.c	/^static int gif_test(stbi *s)$/;"	f	file:
glBlendFunc	.\openb3d\src\brush.h	/^	int glBlendFunc[2];\/\/$/;"	m	class:Brush
glTexEnv	.\openb3d\src\texture.h	/^	int glTexEnv[3][12];\/\/$/;"	m	class:Texture
glTexEnv_count	.\openb3d\src\texture.h	/^	int glTexEnv_count;\/\/$/;"	m	class:Texture
gl_light	.\openb3d\src\light.cpp	/^int Light::gl_light[]={GL_LIGHT0,GL_LIGHT1,GL_LIGHT2,GL_LIGHT3,GL_LIGHT4,GL_LIGHT5,GL_LIGHT6,GL_LIGHT7};$/;"	m	class:Light	file:
gl_light	.\openb3d\src\light.h	/^	static int gl_light[];$/;"	m	class:Light
gluProject	.\openb3d\src\project.cpp	/^gluProject(GLfloat objx, GLfloat objy, GLfloat objz,$/;"	f
gluUnProject	.\openb3d\src\project.cpp	/^gluUnProject(GLfloat winx, GLfloat winy, GLfloat winz,$/;"	f
green	.\openb3d\src\brush.h	/^	float red,green,blue,alpha;$/;"	m	class:Brush
green	.\openb3d\src\light.h	/^	float red,green,blue;$/;"	m	class:Light
grid	.\openb3d\src\matrix.h	/^	float grid[4][4];$/;"	m	class:Matrix
grow_buffer_unsafe	.\openb3d\src\stb_image.c	/^static void grow_buffer_unsafe(jpeg *j)$/;"	f	file:
gx	.\openb3d\src\particle.h	/^	float gx,gy,gz;		\/\/Gravity$/;"	m	class:ParticleEmitter
gy	.\openb3d\src\particle.h	/^	float gx,gy,gz;		\/\/Gravity$/;"	m	class:ParticleEmitter
gz	.\openb3d\src\particle.h	/^	float gx,gy,gz;		\/\/Gravity$/;"	m	class:ParticleEmitter
h	.\openb3d\src\stb_image.c	/^      int h,v;$/;"	m	struct:__anon12::__anon13	file:
h	.\openb3d\src\stb_image.c	/^   int w,h;$/;"	m	struct:stbi_gif_struct	file:
h2	.\openb3d\src\stb_image.c	/^      int x,y,w2,h2;$/;"	m	struct:__anon12::__anon13	file:
h2l_gamma_i	.\openb3d\src\stb_image.c	/^static float h2l_gamma_i=1.0f\/2.2f, h2l_scale_i=1.0f;$/;"	v	file:
h2l_scale_i	.\openb3d\src\stb_image.c	/^static float h2l_gamma_i=1.0f\/2.2f, h2l_scale_i=1.0f;$/;"	v	file:
ha	.\openb3d\src\stb_image.c	/^      int hd,ha;$/;"	m	struct:__anon12::__anon13	file:
handle_x	.\openb3d\src\sprite.h	/^	float handle_x,handle_y; $/;"	m	class:Sprite
handle_y	.\openb3d\src\sprite.h	/^	float handle_x,handle_y; $/;"	m	class:Sprite
hd	.\openb3d\src\stb_image.c	/^      int hd,ha;$/;"	m	struct:__anon12::__anon13	file:
hdr_convert	.\openb3d\src\stb_image.c	/^static void hdr_convert(float *output, stbi_uc *input, int req_comp)$/;"	f	file:
hdr_gettoken	.\openb3d\src\stb_image.c	/^static char *hdr_gettoken(stbi *z, char *buffer)$/;"	f	file:
hdr_load	.\openb3d\src\stb_image.c	/^static float *hdr_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
hdr_test	.\openb3d\src\stb_image.c	/^static int hdr_test(stbi *s)$/;"	f	file:
hdr_to_ldr	.\openb3d\src\stb_image.c	/^static stbi_uc *hdr_to_ldr(float   *data, int x, int y, int comp)$/;"	f	file:
height	.\openb3d\src\geom.h	/^	float height()const{$/;"	f	class:Box
height	.\openb3d\src\global.cpp	/^int Global::width=640,Global::height=480;$/;"	m	class:Global	file:
height	.\openb3d\src\global.h	/^	static int width,height,mode,depth,rate;$/;"	m	class:Global
height	.\openb3d\src\isosurface.h	/^	int width, height, depth;$/;"	m	class:FieldArray
height	.\openb3d\src\octree.h	/^	float x,y,z, width, height, depth;$/;"	m	class:OcTreeChild
height	.\openb3d\src\terrain.h	/^	float* height; 				\/\/heightmap$/;"	m	class:Terrain
height	.\openb3d\src\texture.h	/^	int width,height; \/\/ returned by Name\/Width\/Height commands$/;"	m	class:Texture
hide	.\openb3d\src\entity.h	/^	int hide;$/;"	m	class:Entity
high_bit	.\openb3d\src\stb_image.c	/^static int high_bit(unsigned int z)$/;"	f	file:
hit	.\openb3d\src\touch.h	/^	int hit;$/;"	m	class:Touch
hitTest	.\openb3d\src\collision.cpp	/^bool hitTest( const Line &line,float radius,const Transform &tf,MeshCollider* mesh_col,int method,Collision* curr_coll,CollisionInfo &ci  ){$/;"	f
hits	.\openb3d\src\collision.h	/^	int hits;$/;"	m	struct:CollisionInfo
hs	.\openb3d\src\stb_image.c	/^   int hs,vs;   \/\/ expansion factor in each axis$/;"	m	struct:__anon14	file:
hsize	.\openb3d\src\geosphere.h	/^	float hsize;$/;"	m	class:Geosphere
huff_ac	.\openb3d\src\stb_image.c	/^   huffman huff_ac[4];$/;"	m	struct:__anon12	file:
huff_dc	.\openb3d\src\stb_image.c	/^   huffman huff_dc[4];$/;"	m	struct:__anon12	file:
huffman	.\openb3d\src\stb_image.c	/^} huffman;$/;"	t	typeref:struct:__anon11	file:
i	.\openb3d\src\geom.h	/^	Vector i()const{$/;"	f	struct:Quat
i	.\openb3d\src\geom.h	/^	Vector i,j,k;$/;"	m	class:MMatrix
id	.\openb3d\src\stb_image.c	/^      int id;$/;"	m	struct:__anon12::__anon13	file:
id_ta	.\openb3d\src\shadow.h	/^	ShadowTriangle* id_ta;$/;"	m	class:ShadowTriangle
id_tb	.\openb3d\src\shadow.h	/^	ShadowTriangle* id_tb;$/;"	m	class:ShadowTriangle
id_tc	.\openb3d\src\shadow.h	/^	ShadowTriangle* id_tc;$/;"	m	class:ShadowTriangle
idata	.\openb3d\src\stb_image.c	/^   stbi__uint8 *idata, *expanded, *out;$/;"	m	struct:__anon18	file:
idct_block	.\openb3d\src\stb_image.c	/^static void idct_block(stbi__uint8 *out, int out_stride, short data[64], stbi_dequantize_t *dequantize)$/;"	f	file:
img_buffer	.\openb3d\src\stb_image.c	/^   stbi__uint8 *img_buffer, *img_buffer_end;$/;"	m	struct:__anon9	file:
img_buffer_end	.\openb3d\src\stb_image.c	/^   stbi__uint8 *img_buffer, *img_buffer_end;$/;"	m	struct:__anon9	file:
img_buffer_original	.\openb3d\src\stb_image.c	/^   stbi__uint8 *img_buffer_original;$/;"	m	struct:__anon9	file:
img_comp	.\openb3d\src\stb_image.c	/^   } img_comp[4];$/;"	m	struct:__anon12	typeref:struct:__anon12::__anon13	file:
img_h_max	.\openb3d\src\stb_image.c	/^   int img_h_max, img_v_max;$/;"	m	struct:__anon12	file:
img_mcu_h	.\openb3d\src\stb_image.c	/^   int img_mcu_w, img_mcu_h;$/;"	m	struct:__anon12	file:
img_mcu_w	.\openb3d\src\stb_image.c	/^   int img_mcu_w, img_mcu_h;$/;"	m	struct:__anon12	file:
img_mcu_x	.\openb3d\src\stb_image.c	/^   int img_mcu_x, img_mcu_y;$/;"	m	struct:__anon12	file:
img_mcu_y	.\openb3d\src\stb_image.c	/^   int img_mcu_x, img_mcu_y;$/;"	m	struct:__anon12	file:
img_n	.\openb3d\src\stb_image.c	/^   int img_n, img_out_n;$/;"	m	struct:__anon9	file:
img_out_n	.\openb3d\src\stb_image.c	/^   int img_n, img_out_n;$/;"	m	struct:__anon9	file:
img_v_max	.\openb3d\src\stb_image.c	/^   int img_h_max, img_v_max;$/;"	m	struct:__anon12	file:
img_x	.\openb3d\src\stb_image.c	/^   stbi__uint32 img_x, img_y;$/;"	m	struct:__anon9	file:
img_y	.\openb3d\src\stb_image.c	/^   stbi__uint32 img_x, img_y;$/;"	m	struct:__anon9	file:
index	.\openb3d\src\collision.h	/^	int index;$/;"	m	struct:Collision
index	.\openb3d\src\tree.h	/^		int verts[3],index;$/;"	m	struct:MeshCollider::Triangle
init_defaults	.\openb3d\src\stb_image.c	/^static void init_defaults(void)$/;"	f	file:
inner_ang	.\openb3d\src\light.h	/^	float inner_ang,outer_ang;$/;"	m	class:Light
intersect	.\openb3d\src\geom.h	/^	Line intersect( const Plane &q )const{$/;"	f	class:Plane
intersect	.\openb3d\src\geom.h	/^	Vector intersect( const Line &q )const{$/;"	f	class:Plane
intersects	.\openb3d\src\tree.cpp	/^bool MeshCollider::intersects( const MeshCollider &c,const Transform &t )const{$/;"	f	class:MeshCollider
inv_mat	.\openb3d\src\bone.h	/^	Matrix inv_mat; \/\/ set in TModel, when loading anim mesh$/;"	m	class:Bone
inv_y_scale	.\openb3d\src\collision.h	/^	float radius,inv_y_scale;$/;"	m	struct:CollisionInfo
invert_matrix	.\openb3d\src\project.cpp	/^invert_matrix(const GLfloat * m, GLfloat * out)$/;"	f	file:
io	.\openb3d\src\stb_image.c	/^   stbi_io_callbacks io;$/;"	m	struct:__anon9	file:
io_user_data	.\openb3d\src\stb_image.c	/^   void *io_user_data;$/;"	m	struct:__anon9	file:
ip	.\openb3d\src\shadermat.h	/^		int* ip[4];$/;"	m	union:ShaderData::__anon5
is3D	.\openb3d\src\shadermat.h	/^	int is3D;$/;"	m	class:Sampler
isBlock	.\openb3d\src\octree.h	/^	int isBlock;$/;"	m	class:OcTreeChild
j	.\openb3d\src\geom.h	/^	Vector i,j,k;$/;"	m	class:MMatrix
j	.\openb3d\src\geom.h	/^	Vector j()const{$/;"	f	struct:Quat
jpeg	.\openb3d\src\stb_image.c	/^} jpeg;$/;"	t	typeref:struct:__anon12	file:
k	.\openb3d\src\geom.h	/^	Vector i,j,k;$/;"	m	class:MMatrix
k	.\openb3d\src\geom.h	/^	Vector k()const{$/;"	f	struct:Quat
keys	.\openb3d\src\bone.h	/^	AnimationKeys* keys;$/;"	m	class:Bone
kind	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^struct BBDebugScope_365{int kind; const char *name; BBDebugDecl decls[366]; };$/;"	m	struct:BBDebugScope_365	file:
kind	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^struct BBDebugScope_365{int kind; const char *name; BBDebugDecl decls[366]; };$/;"	m	struct:BBDebugScope_365	file:
kqw	.\openb3d\src\bone.h	/^	float kx,ky,kz,kqw,kqx,kqy,kqz; \/\/ used to store current keyframe in AnimateMesh, for use with transition$/;"	m	class:Bone
kqx	.\openb3d\src\bone.h	/^	float kx,ky,kz,kqw,kqx,kqy,kqz; \/\/ used to store current keyframe in AnimateMesh, for use with transition$/;"	m	class:Bone
kqy	.\openb3d\src\bone.h	/^	float kx,ky,kz,kqw,kqx,kqy,kqz; \/\/ used to store current keyframe in AnimateMesh, for use with transition$/;"	m	class:Bone
kqz	.\openb3d\src\bone.h	/^	float kx,ky,kz,kqw,kqx,kqy,kqz; \/\/ used to store current keyframe in AnimateMesh, for use with transition$/;"	m	class:Bone
kx	.\openb3d\src\bone.h	/^	float kx,ky,kz,kqw,kqx,kqy,kqz; \/\/ used to store current keyframe in AnimateMesh, for use with transition$/;"	m	class:Bone
ky	.\openb3d\src\bone.h	/^	float kx,ky,kz,kqw,kqx,kqy,kqz; \/\/ used to store current keyframe in AnimateMesh, for use with transition$/;"	m	class:Bone
kz	.\openb3d\src\bone.h	/^	float kx,ky,kz,kqw,kqx,kqy,kqz; \/\/ used to store current keyframe in AnimateMesh, for use with transition$/;"	m	class:Bone
l2h_gamma	.\openb3d\src\stb_image.c	/^static float l2h_gamma=2.2f, l2h_scale=1.0f;$/;"	v	file:
l2h_scale	.\openb3d\src\stb_image.c	/^static float l2h_gamma=2.2f, l2h_scale=1.0f;$/;"	v	file:
ldr_to_hdr	.\openb3d\src\stb_image.c	/^static float   *ldr_to_hdr(stbi_uc *data, int x, int y, int comp)$/;"	f	file:
leaves	.\openb3d\src\tree.h	/^	vector<Node*> leaves;$/;"	m	class:MeshCollider
left	.\openb3d\src\tree.h	/^		Node *left,*right;$/;"	m	struct:MeshCollider::Node
length	.\openb3d\src\geom.h	/^	float length()const{$/;"	f	class:Vector
length	.\openb3d\src\geom.h	/^	float length()const{$/;"	f	struct:Quat
length	.\openb3d\src\physics.h	/^	float length;$/;"	m	class:Constraint
length	.\openb3d\src\stb_image.c	/^   stbi__uint32 length;$/;"	m	struct:__anon17	file:
length_base	.\openb3d\src\stb_image.c	/^static int length_base[31] = {$/;"	v	file:
length_extra	.\openb3d\src\stb_image.c	/^static int length_extra[31]= $/;"	v	file:
level	.\openb3d\src\isosurface.cpp	/^static int level;$/;"	v	file:
level2dzsize	.\openb3d\src\terrain.h	/^	float level2dzsize[ROAM_LMAX+1]; 	\/* Max midpoint displacement per level     *\/$/;"	m	class:Terrain
lflags	.\openb3d\src\stb_image.c	/^   int lflags;$/;"	m	struct:stbi_gif_struct	file:
lifetime	.\openb3d\src\particle.h	/^	int lifetime;$/;"	m	class:ParticleEmitter
light_list	.\openb3d\src\light.cpp	/^vector<Light*> Light::light_list;$/;"	m	class:Light	file:
light_list	.\openb3d\src\light.h	/^	static vector<Light*> light_list;$/;"	m	class:Light
light_no	.\openb3d\src\light.cpp	/^int Light::light_no=0;$/;"	m	class:Light	file:
light_no	.\openb3d\src\light.h	/^	static int light_no;$/;"	m	class:Light
light_type	.\openb3d\src\light.h	/^	char light_type;$/;"	m	class:Light
light_x	.\openb3d\src\shadow.cpp	/^float ShadowObject::light_x, ShadowObject::light_y, ShadowObject::light_z;$/;"	m	class:ShadowObject	file:
light_x	.\openb3d\src\shadow.h	/^	static float light_x;$/;"	m	class:ShadowObject
light_y	.\openb3d\src\shadow.cpp	/^float ShadowObject::light_x, ShadowObject::light_y, ShadowObject::light_z;$/;"	m	class:ShadowObject	file:
light_y	.\openb3d\src\shadow.h	/^	static float light_y;$/;"	m	class:ShadowObject
light_z	.\openb3d\src\shadow.cpp	/^float ShadowObject::light_x, ShadowObject::light_y, ShadowObject::light_z;$/;"	m	class:ShadowObject	file:
light_z	.\openb3d\src\shadow.h	/^	static float light_z;$/;"	m	class:ShadowObject
line0	.\openb3d\src\stb_image.c	/^   stbi__uint8 *line0,*line1;$/;"	m	struct:__anon14	file:
line1	.\openb3d\src\stb_image.c	/^   stbi__uint8 *line0,*line1;$/;"	m	struct:__anon14	file:
line_size	.\openb3d\src\stb_image.c	/^   int line_size;$/;"	m	struct:stbi_gif_struct	file:
linebuf	.\openb3d\src\stb_image.c	/^      stbi__uint8 *linebuf;$/;"	m	struct:__anon12::__anon13	file:
load3ds	.\openb3d\src\3ds.cpp	/^namespace load3ds{$/;"	n	file:
load3ds	.\openb3d\src\3ds.h	/^namespace load3ds{$/;"	n
loadBrush	.\openb3d\src\x.cpp	/^void loadBrush(list<XLoader_TreeNode*> matlist, Brush* brushes[], vector<string> &brushnames){$/;"	f	namespace:loadX
loadMD2	.\openb3d\src\md2.cpp	/^namespace loadMD2{$/;"	n	file:
loadMD2	.\openb3d\src\md2.h	/^namespace loadMD2{$/;"	n
loadX	.\openb3d\src\x.cpp	/^namespace loadX{$/;"	n	file:
loadX	.\openb3d\src\x.h	/^namespace loadX{$/;"	n
load_jpeg_image	.\openb3d\src\stb_image.c	/^static stbi__uint8 *load_jpeg_image(jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)$/;"	f	file:
loop	.\openb3d\src\csg.h	/^	int loop;$/;"	m	class:CSGTriangle
lpal	.\openb3d\src\stb_image.c	/^   stbi__uint8 lpal[256][4];$/;"	m	struct:stbi_gif_struct	file:
m	.\openb3d\src\geom.h	/^	MMatrix m;$/;"	m	class:Transform
marker	.\openb3d\src\stb_image.c	/^   unsigned char  marker;      \/\/ marker seen while filling entropy buffer$/;"	m	struct:__anon12	file:
mat	.\openb3d\src\entity.h	/^	Matrix mat;$/;"	m	class:Entity
mat2	.\openb3d\src\bone.h	/^	Matrix mat2;$/;"	m	class:Bone
mat_sp	.\openb3d\src\mesh.h	/^	Matrix mat_sp; \/\/ mat_sp used in TMesh's Update to provide necessary additional transform matrix for sprites$/;"	m	class:Mesh
material	.\openb3d\src\voxel.h	/^	Material* material[8];$/;"	m	class:VoxelSprite
matmul	.\openb3d\src\project.cpp	/^matmul(GLfloat * product, const GLfloat * a, const GLfloat * b)$/;"	f	file:
max_lights	.\openb3d\src\light.cpp	/^int Light::max_lights=8;$/;"	m	class:Light	file:
max_lights	.\openb3d\src\light.h	/^	static int max_lights;$/;"	m	class:Light
max_x	.\openb3d\src\mesh.h	/^	float min_x,min_y,min_z,max_x,max_y,max_z;$/;"	m	class:Mesh
max_x	.\openb3d\src\stb_image.c	/^   int max_x, max_y;$/;"	m	struct:stbi_gif_struct	file:
max_y	.\openb3d\src\mesh.h	/^	float min_x,min_y,min_z,max_x,max_y,max_z;$/;"	m	class:Mesh
max_y	.\openb3d\src\stb_image.c	/^   int max_x, max_y;$/;"	m	struct:stbi_gif_struct	file:
max_z	.\openb3d\src\mesh.h	/^	float min_x,min_y,min_z,max_x,max_y,max_z;$/;"	m	class:Mesh
maxcode	.\openb3d\src\stb_image.c	/^   int maxcode[17];$/;"	m	struct:__anon15	file:
maxcode	.\openb3d\src\stb_image.c	/^   unsigned int maxcode[18];$/;"	m	struct:__anon11	file:
md2_anorms	.\openb3d\src\md2.cpp	/^const float md2_anorms[][3]={$/;"	m	namespace:loadMD2	file:
mesh	.\openb3d\src\3ds.cpp	/^Mesh*          mesh;$/;"	m	namespace:load3ds	file:
mesh	.\openb3d\src\csg.h	/^	Mesh* mesh;$/;"	m	class:CSGTriangle
mesh	.\openb3d\src\octree.h	/^	Mesh* mesh;$/;"	m	class:OcTreeChild
mesh	.\openb3d\src\sprite_batch.h	/^	Mesh* mesh;$/;"	m	class:SpriteBatch
mesh_info	.\openb3d\src\terrain.cpp	/^MeshInfo* Terrain::mesh_info;$/;"	m	class:Terrain	file:
mesh_info	.\openb3d\src\terrain.h	/^	static MeshInfo* mesh_info;$/;"	m	class:Terrain
metaball_list	.\openb3d\src\isosurface.h	/^	list<Blob*> metaball_list;$/;"	m	class:Fluid
midStencilVal	.\openb3d\src\shadow.cpp	/^int ShadowObject::midStencilVal;$/;"	m	class:ShadowObject	file:
midStencilVal	.\openb3d\src\shadow.h	/^	static int midStencilVal;$/;"	m	class:ShadowObject
midStencilVal	.\openb3d\src\stencil.cpp	/^int Stencil::midStencilVal;$/;"	m	class:Stencil	file:
midStencilVal	.\openb3d\src\stencil.h	/^	static int midStencilVal;$/;"	m	class:Stencil
min_x	.\openb3d\src\mesh.h	/^	float min_x,min_y,min_z,max_x,max_y,max_z;$/;"	m	class:Mesh
min_y	.\openb3d\src\mesh.h	/^	float min_x,min_y,min_z,max_x,max_y,max_z;$/;"	m	class:Mesh
min_z	.\openb3d\src\mesh.h	/^	float min_x,min_y,min_z,max_x,max_y,max_z;$/;"	m	class:Mesh
mod_mat	.\openb3d\src\camera.h	/^	float mod_mat[16];$/;"	m	class:Camera
mode	.\data.cpp	/^int Global::mode,Global::depth,Global::rate;$/;"	m	class:Global	file:
mode	.\openb3d\src\global.h	/^	static int width,height,mode,depth,rate;$/;"	m	class:Global
n	.\openb3d\src\geom.h	/^	Vector n;$/;"	m	class:Plane
n_hit	.\openb3d\src\collision.h	/^	int n_hit;$/;"	m	struct:CollisionInfo
n_px	.\openb3d\src\bone.h	/^	float n_px,n_py,n_pz,n_sx,n_sy,n_sz,n_rx,n_ry,n_rz,n_qw,n_qx,n_qy,n_qz;$/;"	m	class:Bone
n_py	.\openb3d\src\bone.h	/^	float n_px,n_py,n_pz,n_sx,n_sy,n_sz,n_rx,n_ry,n_rz,n_qw,n_qx,n_qy,n_qz;$/;"	m	class:Bone
n_pz	.\openb3d\src\bone.h	/^	float n_px,n_py,n_pz,n_sx,n_sy,n_sz,n_rx,n_ry,n_rz,n_qw,n_qx,n_qy,n_qz;$/;"	m	class:Bone
n_qw	.\openb3d\src\bone.h	/^	float n_px,n_py,n_pz,n_sx,n_sy,n_sz,n_rx,n_ry,n_rz,n_qw,n_qx,n_qy,n_qz;$/;"	m	class:Bone
n_qx	.\openb3d\src\bone.h	/^	float n_px,n_py,n_pz,n_sx,n_sy,n_sz,n_rx,n_ry,n_rz,n_qw,n_qx,n_qy,n_qz;$/;"	m	class:Bone
n_qy	.\openb3d\src\bone.h	/^	float n_px,n_py,n_pz,n_sx,n_sy,n_sz,n_rx,n_ry,n_rz,n_qw,n_qx,n_qy,n_qz;$/;"	m	class:Bone
n_qz	.\openb3d\src\bone.h	/^	float n_px,n_py,n_pz,n_sx,n_sy,n_sz,n_rx,n_ry,n_rz,n_qw,n_qx,n_qy,n_qz;$/;"	m	class:Bone
n_rx	.\openb3d\src\bone.h	/^	float n_px,n_py,n_pz,n_sx,n_sy,n_sz,n_rx,n_ry,n_rz,n_qw,n_qx,n_qy,n_qz;$/;"	m	class:Bone
n_ry	.\openb3d\src\bone.h	/^	float n_px,n_py,n_pz,n_sx,n_sy,n_sz,n_rx,n_ry,n_rz,n_qw,n_qx,n_qy,n_qz;$/;"	m	class:Bone
n_rz	.\openb3d\src\bone.h	/^	float n_px,n_py,n_pz,n_sx,n_sy,n_sz,n_rx,n_ry,n_rz,n_qw,n_qx,n_qy,n_qz;$/;"	m	class:Bone
n_sx	.\openb3d\src\bone.h	/^	float n_px,n_py,n_pz,n_sx,n_sy,n_sz,n_rx,n_ry,n_rz,n_qw,n_qx,n_qy,n_qz;$/;"	m	class:Bone
n_sy	.\openb3d\src\bone.h	/^	float n_px,n_py,n_pz,n_sx,n_sy,n_sz,n_rx,n_ry,n_rz,n_qw,n_qx,n_qy,n_qz;$/;"	m	class:Bone
n_sz	.\openb3d\src\bone.h	/^	float n_px,n_py,n_pz,n_sx,n_sy,n_sz,n_rx,n_ry,n_rz,n_qw,n_qx,n_qy,n_qz;$/;"	m	class:Bone
name	.\.bmx\openb3dlib.bmx.debug.win32.x64.c	/^struct BBDebugScope_365{int kind; const char *name; BBDebugDecl decls[366]; };$/;"	m	struct:BBDebugScope_365	file:
name	.\.bmx\openb3dlib.bmx.debug.win32.x86.c	/^struct BBDebugScope_365{int kind; const char *name; BBDebugDecl decls[366]; };$/;"	m	struct:BBDebugScope_365	file:
name	.\openb3d\src\brush.h	/^	string name;$/;"	m	class:Brush
name	.\openb3d\src\entity.h	/^	string name;$/;"	m	class:Entity
name	.\openb3d\src\shadermat.h	/^	string name;$/;"	m	class:Shader
name	.\openb3d\src\shadermat.h	/^	string name;$/;"	m	class:ShaderData
name	.\openb3d\src\x.cpp	/^		string name;$/;"	m	class:loadX::XLoader_TreeNode	file:
near	.\openb3d\src\octree.h	/^	float near,far;$/;"	m	class:OcTreeChild
nearest	.\openb3d\src\geom.h	/^	Vector nearest( const Vector &q )const{$/;"	f	class:Line
nearest	.\openb3d\src\geom.h	/^	Vector nearest( const Vector &q )const{$/;"	f	class:Plane
negate	.\openb3d\src\geom.h	/^	void negate(){$/;"	f	class:Plane
new_no	.\openb3d\src\entity.h	/^	int new_no;$/;"	m	class:Entity
new_x	.\openb3d\src\entity.h	/^	float new_x;$/;"	m	class:Entity
new_y	.\openb3d\src\entity.h	/^	float new_y;$/;"	m	class:Entity
new_z	.\openb3d\src\entity.h	/^	float new_z;$/;"	m	class:Entity
nextActions	.\openb3d\src\actions.h	/^	list<Action*> nextActions;$/;"	m	class:Action
no_collisions	.\openb3d\src\entity.h	/^	int no_collisions;$/;"	m	class:Entity
no_frames	.\openb3d\src\texture.h	/^	int no_frames;$/;"	m	class:Texture
no_lights	.\openb3d\src\light.cpp	/^int Light::no_lights=0;$/;"	m	class:Light	file:
no_lights	.\openb3d\src\light.h	/^	static int no_lights;$/;"	m	class:Light
no_mats	.\openb3d\src\voxel.h	/^	int no_mats;$/;"	m	class:VoxelSprite
no_seqs	.\openb3d\src\entity.h	/^	int no_seqs;$/;"	m	class:Entity
no_surfs	.\openb3d\src\mesh.h	/^	int no_surfs;$/;"	m	class:Mesh
no_texs	.\openb3d\src\brush.h	/^	int no_texs;$/;"	m	class:Brush
no_tris	.\openb3d\src\surface.h	/^	int no_tris;$/;"	m	class:Surface
no_verts	.\openb3d\src\surface.h	/^	int no_verts;$/;"	m	class:Surface
nodeBox	.\openb3d\src\tree.cpp	/^Box MeshCollider::nodeBox( const vector<int> &tris ){$/;"	f	class:MeshCollider
nomore	.\openb3d\src\stb_image.c	/^   int            nomore;      \/\/ flag if we saw a marker so must stop$/;"	m	struct:__anon12	file:
normal	.\openb3d\src\collision.h	/^	Vector normal;$/;"	m	struct:Collision
normalize	.\openb3d\src\geom.h	/^	void normalize(){$/;"	f	class:Vector
normalize	.\openb3d\src\geom.h	/^	void normalize(){$/;"	f	struct:Quat
normalized	.\openb3d\src\geom.h	/^	Quat normalized()const{$/;"	f	struct:Quat
normalized	.\openb3d\src\geom.h	/^	Vector normalized()const{$/;"	f	class:Vector
npicked	.\openb3d\src\csg.cpp	/^float npicked[3], tpicked[3];$/;"	m	namespace:CSG	file:
num_bits	.\openb3d\src\stb_image.c	/^   int num_bits;$/;"	m	struct:__anon16	file:
nx	.\openb3d\src\collision2.h	/^	float nx,ny,nz;$/;"	m	class:CollisionImpact
nx	.\openb3d\src\csg.h	/^	float nx,ny,nz;$/;"	m	class:CSGTriangle
nx	.\openb3d\src\shadow.h	/^	float nx, ny, nz;$/;"	m	class:ShadowTriangle
ny	.\openb3d\src\collision2.h	/^	float nx,ny,nz;$/;"	m	class:CollisionImpact
ny	.\openb3d\src\csg.h	/^	float nx,ny,nz;$/;"	m	class:CSGTriangle
ny	.\openb3d\src\shadow.h	/^	float nx, ny, nz;$/;"	m	class:ShadowTriangle
nz	.\openb3d\src\collision2.h	/^	float nx,ny,nz;$/;"	m	class:CollisionImpact
nz	.\openb3d\src\csg.h	/^	float nx,ny,nz;$/;"	m	class:CSGTriangle
nz	.\openb3d\src\shadow.h	/^	float nx, ny, nz;$/;"	m	class:ShadowTriangle
o	.\openb3d\src\geom.h	/^	Vector o,d;$/;"	m	class:Line
obscurer	.\openb3d\src\entity.h	/^	int obscurer;$/;"	m	class:Entity
old_mat	.\openb3d\src\entity.h	/^	Matrix old_mat;$/;"	m	class:Entity
old_pitch	.\openb3d\src\entity.h	/^	float old_pitch;$/;"	m	class:Entity
old_roll	.\openb3d\src\entity.h	/^	float old_roll;$/;"	m	class:Entity
old_x	.\openb3d\src\entity.h	/^	float old_x;$/;"	m	class:Entity
old_x	.\openb3d\src\touch.h	/^	float old_x,old_y;$/;"	m	class:Touch
old_y	.\openb3d\src\entity.h	/^	float old_y;$/;"	m	class:Entity
old_y	.\openb3d\src\touch.h	/^	float old_x,old_y;$/;"	m	class:Touch
old_yaw	.\openb3d\src\entity.h	/^	float old_yaw;$/;"	m	class:Entity
old_z	.\openb3d\src\entity.h	/^	float old_z;$/;"	m	class:Entity
onx	.\openb3d\src\csg.h	/^	float onx,ony,onz;$/;"	m	class:CSGTriangle
ony	.\openb3d\src\csg.h	/^	float onx,ony,onz;$/;"	m	class:CSGTriangle
onz	.\openb3d\src\csg.h	/^	float onx,ony,onz;$/;"	m	class:CSGTriangle
operator !=	.\openb3d\src\geom.h	/^	bool operator!=( const MMatrix &q )const{$/;"	f	class:MMatrix
operator !=	.\openb3d\src\geom.h	/^	bool operator!=( const Transform &q )const{$/;"	f	class:Transform
operator !=	.\openb3d\src\geom.h	/^	bool operator!=( const Vector &q )const{$/;"	f	class:Vector
operator *	.\openb3d\src\geom.h	/^	Box operator*( const Box &q )const{$/;"	f	class:Transform
operator *	.\openb3d\src\geom.h	/^	Line operator*( const Line &q )const{$/;"	f	class:Transform
operator *	.\openb3d\src\geom.h	/^	MMatrix &operator*( const MMatrix &q )const{$/;"	f	class:MMatrix
operator *	.\openb3d\src\geom.h	/^	Quat operator*( const Quat &q )const{$/;"	f	struct:Quat
operator *	.\openb3d\src\geom.h	/^	Quat operator*( float q )const{$/;"	f	struct:Quat
operator *	.\openb3d\src\geom.h	/^	Transform &operator*( const Transform &q )const{$/;"	f	class:Transform
operator *	.\openb3d\src\geom.h	/^	Vector operator*( const Vector &q )const{$/;"	f	class:MMatrix
operator *	.\openb3d\src\geom.h	/^	Vector operator*( const Vector &q )const{$/;"	f	class:Transform
operator *	.\openb3d\src\geom.h	/^	Vector operator*( const Vector &q )const{$/;"	f	class:Vector
operator *	.\openb3d\src\geom.h	/^	Vector operator*( const Vector &q )const{$/;"	f	struct:Quat
operator *	.\openb3d\src\geom.h	/^	Vector operator*( float q )const{$/;"	f	class:Line
operator *	.\openb3d\src\geom.h	/^	Vector operator*( float scale )const{$/;"	f	class:Vector
operator *=	.\openb3d\src\geom.h	/^	Vector &operator*=( const Vector &q ){$/;"	f	class:Vector
operator *=	.\openb3d\src\geom.h	/^	Vector &operator*=( float scale ){$/;"	f	class:Vector
operator +	.\openb3d\src\geom.h	/^	Line operator+( const Vector &q )const{$/;"	f	class:Line
operator +	.\openb3d\src\geom.h	/^	Quat operator+( const Quat &q )const{$/;"	f	struct:Quat
operator +	.\openb3d\src\geom.h	/^	Vector operator+( const Vector &q )const{$/;"	f	class:Vector
operator +=	.\openb3d\src\geom.h	/^	Vector &operator+=( const Vector &q ){$/;"	f	class:Vector
operator -	.\openb3d\src\geom.h	/^	Line operator-( const Vector &q )const{$/;"	f	class:Line
operator -	.\openb3d\src\geom.h	/^	MMatrix &operator-()const{$/;"	f	class:MMatrix
operator -	.\openb3d\src\geom.h	/^	Plane operator-()const{$/;"	f	class:Plane
operator -	.\openb3d\src\geom.h	/^	Quat operator-( const Quat &q )const{$/;"	f	struct:Quat
operator -	.\openb3d\src\geom.h	/^	Quat operator-()const{$/;"	f	struct:Quat
operator -	.\openb3d\src\geom.h	/^	Transform &operator-()const{$/;"	f	class:Transform
operator -	.\openb3d\src\geom.h	/^	Vector operator-( const Vector &q )const{$/;"	f	class:Vector
operator -	.\openb3d\src\geom.h	/^	Vector operator-()const{$/;"	f	class:Vector
operator -=	.\openb3d\src\geom.h	/^	Vector &operator-=( const Vector &q ){$/;"	f	class:Vector
operator /	.\openb3d\src\geom.h	/^	Quat operator\/( float q )const{$/;"	f	struct:Quat
operator /	.\openb3d\src\geom.h	/^	Vector operator\/( const Vector &q )const{$/;"	f	class:Vector
operator /	.\openb3d\src\geom.h	/^	Vector operator\/( float scale )const{$/;"	f	class:Vector
operator /=	.\openb3d\src\geom.h	/^	Vector &operator\/=( const Vector &q ){$/;"	f	class:Vector
operator /=	.\openb3d\src\geom.h	/^	Vector &operator\/=( float scale ){$/;"	f	class:Vector
operator <	.\openb3d\src\geom.h	/^	bool operator<( const Vector &q )const{$/;"	f	class:Vector
operator ==	.\openb3d\src\geom.h	/^	bool operator==( const MMatrix &q )const{$/;"	f	class:MMatrix
operator ==	.\openb3d\src\geom.h	/^	bool operator==( const Transform &q )const{$/;"	f	class:Transform
operator ==	.\openb3d\src\geom.h	/^	bool operator==( const Vector &q )const{$/;"	f	class:Vector
operator []	.\openb3d\src\geom.h	/^	Vector &operator[]( int n ){$/;"	f	class:MMatrix
operator []	.\openb3d\src\geom.h	/^	const Vector &operator[]( int n )const{$/;"	f	class:MMatrix
operator []	.\openb3d\src\geom.h	/^	float &operator[]( int n ){$/;"	f	class:Vector
operator []	.\openb3d\src\geom.h	/^	float operator[]( int n )const{$/;"	f	class:Vector
operator const float *	.\openb3d\src\geom.h	/^	operator const float *(){$/;"	f	class:Vector
operator float*	.\openb3d\src\geom.h	/^	operator float*(){$/;"	f	class:Vector
operator ~	.\openb3d\src\geom.h	/^	MMatrix &operator~()const{$/;"	f	class:MMatrix
operator ~	.\openb3d\src\geom.h	/^	Transform &operator~()const{$/;"	f	class:Transform
order	.\openb3d\src\entity.h	/^	int order;$/;"	m	class:Entity
order	.\openb3d\src\sprite_batch.h	/^	int order;$/;"	m	class:SpriteBatch
order	.\openb3d\src\stb_image.c	/^   int scan_n, order[4];$/;"	m	struct:__anon12	file:
orthogonalize	.\openb3d\src\geom.h	/^	void orthogonalize(){$/;"	f	class:MMatrix
orthogonalized	.\openb3d\src\geom.h	/^	MMatrix &orthogonalized()const{$/;"	f	class:MMatrix
out	.\openb3d\src\stb_image.c	/^   stbi__uint8 *idata, *expanded, *out;$/;"	m	struct:__anon18	file:
out	.\openb3d\src\stb_image.c	/^   stbi_uc *out;                 \/\/ output buffer (always 4 components)$/;"	m	struct:stbi_gif_struct	file:
outer_ang	.\openb3d\src\light.h	/^	float inner_ang,outer_ang;$/;"	m	class:Light
overlaps	.\openb3d\src\geom.h	/^	bool overlaps( const Box &q )const{$/;"	f	class:Box
pFile	.\openb3d\src\file.h	/^	FILE * pFile;$/;"	m	class:File
paeth	.\openb3d\src\stb_image.c	/^static int paeth(int a, int b, int c)$/;"	f	file:
pal	.\openb3d\src\stb_image.c	/^   stbi__uint8  pal[256][4];$/;"	m	struct:stbi_gif_struct	file:
panic	.\openb3d\src\collision.h	/^	Vector panic;$/;"	m	struct:CollisionInfo
parallel	.\openb3d\src\shadow.cpp	/^int ShadowObject::parallel;$/;"	m	class:ShadowObject	file:
parallel	.\openb3d\src\shadow.h	/^	static int parallel;$/;"	m	class:ShadowObject
parent	.\openb3d\src\entity.h	/^	Entity* parent;$/;"	m	class:Entity
parse	.\openb3d\src\stb_image.c	/^   int parse, step;$/;"	m	struct:stbi_gif_struct	file:
parse_entropy_coded_data	.\openb3d\src\stb_image.c	/^static int parse_entropy_coded_data(jpeg *z)$/;"	f	file:
parse_huffman_block	.\openb3d\src\stb_image.c	/^static int parse_huffman_block(zbuf *a)$/;"	f	file:
parse_png_file	.\openb3d\src\stb_image.c	/^static int parse_png_file(png *z, int scan, int req_comp)$/;"	f	file:
parse_uncompressed_block	.\openb3d\src\stb_image.c	/^static int parse_uncompressed_block(zbuf *a)$/;"	f	file:
parse_zlib	.\openb3d\src\stb_image.c	/^static int parse_zlib(zbuf *a, int parse_header)$/;"	f	file:
parse_zlib_header	.\openb3d\src\stb_image.c	/^static int parse_zlib_header(zbuf *a)$/;"	f	file:
particleLife	.\openb3d\src\particle.h	/^		int particleLife;$/;"	m	struct:ParticleEmitter::ParticleData
particleSpeed	.\openb3d\src\particle.h	/^	float particleSpeed;$/;"	m	class:ParticleEmitter
particle_base	.\openb3d\src\particle.h	/^	Entity* particle_base;$/;"	m	class:ParticleEmitter
particle_batch_list	.\openb3d\src\particle.cpp	/^list<ParticleBatch*> ParticleBatch::particle_batch_list;$/;"	m	class:ParticleBatch	file:
particle_batch_list	.\openb3d\src\particle.h	/^	static list<ParticleBatch*> particle_batch_list;$/;"	m	class:ParticleBatch
particles	.\openb3d\src\particle.h	/^	list<ParticleData> particles;$/;"	m	class:ParticleEmitter
pic_copyval	.\openb3d\src\stb_image.c	/^static void pic_copyval(int channel,stbi_uc *dest,const stbi_uc *src)$/;"	f	file:
pic_is4	.\openb3d\src\stb_image.c	/^static int pic_is4(stbi *s,const char *str)$/;"	f	file:
pic_load	.\openb3d\src\stb_image.c	/^static stbi_uc *pic_load(stbi *s,int *px,int *py,int *comp,int req_comp)$/;"	f	file:
pic_load2	.\openb3d\src\stb_image.c	/^static stbi_uc *pic_load2(stbi *s,int width,int height,int *comp, stbi_uc *result)$/;"	f	file:
pic_packet_t	.\openb3d\src\stb_image.c	/^} pic_packet_t;$/;"	t	typeref:struct:__anon20	file:
pic_readval	.\openb3d\src\stb_image.c	/^static stbi_uc *pic_readval(stbi *s, int channel, stbi_uc *dest)$/;"	f	file:
pic_test	.\openb3d\src\stb_image.c	/^static int pic_test(stbi *s)$/;"	f	file:
pick_mode	.\openb3d\src\entity.h	/^	int pick_mode;$/;"	m	class:Entity
picked_ent	.\openb3d\src\pick.cpp	/^Entity* Pick::picked_ent;$/;"	m	class:Pick	file:
picked_ent	.\openb3d\src\pick.h	/^	static Entity* picked_ent;$/;"	m	class:Pick
picked_nx	.\openb3d\src\pick.cpp	/^float Pick::picked_nx;$/;"	m	class:Pick	file:
picked_nx	.\openb3d\src\pick.h	/^	static float picked_nx;$/;"	m	class:Pick
picked_ny	.\openb3d\src\pick.cpp	/^float Pick::picked_ny;$/;"	m	class:Pick	file:
picked_ny	.\openb3d\src\pick.h	/^	static float picked_ny;$/;"	m	class:Pick
picked_nz	.\openb3d\src\pick.cpp	/^float Pick::picked_nz;$/;"	m	class:Pick	file:
picked_nz	.\openb3d\src\pick.h	/^	static float picked_nz;$/;"	m	class:Pick
picked_surface	.\openb3d\src\pick.cpp	/^Surface* Pick::picked_surface;$/;"	m	class:Pick	file:
picked_surface	.\openb3d\src\pick.h	/^	static Surface* picked_surface;$/;"	m	class:Pick
picked_time	.\openb3d\src\pick.cpp	/^float Pick::picked_time;$/;"	m	class:Pick	file:
picked_time	.\openb3d\src\pick.h	/^	static float picked_time;$/;"	m	class:Pick
picked_triangle	.\openb3d\src\pick.cpp	/^int Pick::picked_triangle;$/;"	m	class:Pick	file:
picked_triangle	.\openb3d\src\pick.h	/^	static int picked_triangle;$/;"	m	class:Pick
picked_x	.\openb3d\src\pick.cpp	/^float Pick::picked_x;$/;"	m	class:Pick	file:
picked_x	.\openb3d\src\pick.h	/^	static float picked_x;$/;"	m	class:Pick
picked_y	.\openb3d\src\pick.cpp	/^float Pick::picked_y;$/;"	m	class:Pick	file:
picked_y	.\openb3d\src\pick.h	/^	static float picked_y;$/;"	m	class:Pick
picked_z	.\openb3d\src\pick.cpp	/^float Pick::picked_z;$/;"	m	class:Pick	file:
picked_z	.\openb3d\src\pick.h	/^	static float picked_z;$/;"	m	class:Pick
pitch	.\openb3d\src\geom.h	/^	float pitch()const{$/;"	f	class:Vector
pitchMMatrix	.\openb3d\src\geom.h	/^inline MMatrix pitchMMatrix( float q ){$/;"	f
pitchQuat	.\openb3d\src\geom.h	/^inline Quat pitchQuat( float p ){$/;"	f
planes	.\openb3d\src\collision.h	/^	Plane planes[2];$/;"	m	struct:CollisionInfo
png	.\openb3d\src\stb_image.c	/^} png;$/;"	t	typeref:struct:__anon18	file:
prefix	.\openb3d\src\stb_image.c	/^   stbi__int16 prefix;$/;"	m	struct:stbi_gif_lzw_struct	file:
process_frame_header	.\openb3d\src\stb_image.c	/^static int process_frame_header(jpeg *z, int scan)$/;"	f	file:
process_marker	.\openb3d\src\stb_image.c	/^static int process_marker(jpeg *z, int m)$/;"	f	file:
process_scan_header	.\openb3d\src\stb_image.c	/^static int process_scan_header(jpeg *z)$/;"	f	file:
progName	.\openb3d\src\shaderobject.h	/^	string progName;$/;"	m	class:ProgramObject
proj_mat	.\openb3d\src\camera.h	/^	float proj_mat[16];$/;"	m	class:Camera
proj_mode	.\openb3d\src\camera.h	/^	int proj_mode;$/;"	m	class:Camera
project_enabled	.\openb3d\src\camera.h	/^	int project_enabled;$/;"	m	class:Camera
projected_x	.\openb3d\src\camera.cpp	/^float Camera::projected_x,Camera::projected_y,Camera::projected_z;$/;"	m	class:Camera	file:
projected_x	.\openb3d\src\camera.h	/^	static float projected_x;$/;"	m	class:Camera
projected_y	.\openb3d\src\camera.cpp	/^float Camera::projected_x,Camera::projected_y,Camera::projected_z;$/;"	m	class:Camera	file:
projected_y	.\openb3d\src\camera.h	/^	static float projected_y;$/;"	m	class:Camera
projected_z	.\openb3d\src\camera.cpp	/^float Camera::projected_x,Camera::projected_y,Camera::projected_z;$/;"	m	class:Camera	file:
projected_z	.\openb3d\src\camera.h	/^	static float projected_z;$/;"	m	class:Camera
psd_load	.\openb3d\src\stb_image.c	/^static stbi_uc *psd_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
psd_test	.\openb3d\src\stb_image.c	/^static int psd_test(stbi *s)$/;"	f	file:
px	.\openb3d\src\animation_keys.h	/^	vector<float> px;$/;"	m	class:AnimationKeys
px	.\openb3d\src\entity.h	/^	float px,py,pz;$/;"	m	class:Entity
py	.\openb3d\src\animation_keys.h	/^	vector<float> py;$/;"	m	class:AnimationKeys
py	.\openb3d\src\entity.h	/^	float px,py,pz;$/;"	m	class:Entity
pz	.\openb3d\src\animation_keys.h	/^	vector<float> pz;$/;"	m	class:AnimationKeys
pz	.\openb3d\src\entity.h	/^	float px,py,pz;$/;"	m	class:Entity
quatPitch	.\openb3d\src\geom.h	/^inline float quatPitch( const Quat &q ){$/;"	f
quatRoll	.\openb3d\src\geom.h	/^inline float quatRoll( const Quat &q ){$/;"	f
quatYaw	.\openb3d\src\geom.h	/^inline float quatYaw( const Quat &q ){$/;"	f
qw	.\openb3d\src\animation_keys.h	/^	vector<float> qw;$/;"	m	class:AnimationKeys
qw	.\openb3d\src\entity.h	/^	float qw,qx,qy,qz;$/;"	m	class:Entity
qx	.\openb3d\src\animation_keys.h	/^	vector<float> qx;$/;"	m	class:AnimationKeys
qx	.\openb3d\src\entity.h	/^	float qw,qx,qy,qz;$/;"	m	class:Entity
qy	.\openb3d\src\animation_keys.h	/^	vector<float> qy;$/;"	m	class:AnimationKeys
qy	.\openb3d\src\entity.h	/^	float qw,qx,qy,qz;$/;"	m	class:Entity
qz	.\openb3d\src\animation_keys.h	/^	vector<float> qz;$/;"	m	class:AnimationKeys
qz	.\openb3d\src\entity.h	/^	float qw,qx,qy,qz;$/;"	m	class:Entity
rad2deg	.\openb3d\src\maths_helper.h	/^inline double rad2deg(double radians)$/;"	f
radii	.\openb3d\src\collision.h	/^	Vector radii;$/;"	m	struct:CollisionInfo
radius	.\openb3d\src\collision.h	/^	float radius,inv_y_scale;$/;"	m	struct:CollisionInfo
radius	.\openb3d\src\geosphere.cpp	/^static float radius;$/;"	v	file:
radius	.\openb3d\src\octree.cpp	/^static float radius;$/;"	v	file:
radius	.\openb3d\src\terrain.cpp	/^static float radius;$/;"	v	file:
radius_x	.\openb3d\src\entity.h	/^	float radius_x,radius_y;$/;"	m	class:Entity
radius_y	.\openb3d\src\entity.h	/^	float radius_x,radius_y;$/;"	m	class:Entity
range	.\openb3d\src\light.h	/^	float range;$/;"	m	class:Light
range_far	.\openb3d\src\camera.h	/^	float range_near,range_far;$/;"	m	class:Camera
range_near	.\openb3d\src\camera.h	/^	float range_near,range_far;$/;"	m	class:Camera
rate	.\data.cpp	/^int Global::mode,Global::depth,Global::rate;$/;"	m	class:Global	file:
rate	.\openb3d\src\actions.h	/^	float rate;$/;"	m	class:Action
rate	.\openb3d\src\global.h	/^	static int width,height,mode,depth,rate;$/;"	m	class:Global
rate	.\openb3d\src\particle.h	/^	int rate;$/;"	m	class:ParticleEmitter
rate_counter	.\openb3d\src\particle.h	/^	int rate_counter;$/;"	m	class:ParticleEmitter
ratio	.\openb3d\src\stb_image.c	/^   int flags, bgindex, ratio, transparent, eflags;$/;"	m	struct:stbi_gif_struct	file:
raw_data	.\openb3d\src\stb_image.c	/^      void *raw_data;$/;"	m	struct:__anon12::__anon13	file:
ray_plane	.\openb3d\src\csg.cpp	/^int ray_plane(float p1x, float p1y, float p1z, float p2x, float p2y, float p2z, float nx, float ny, float nz, float d){$/;"	f	namespace:CSG
read	.\openb3d\src\stb_image.c	/^   int      (*read)  (void *user,char *data,int size);   \/\/ fill 'data' with 'size' bytes.  return number of bytes actually read $/;"	m	struct:__anon8	file:
read	.\openb3d\src\stb_image.h	/^   int      (*read)  (void *user,char *data,int size);   \/\/ fill 'data' with 'size' bytes.  return number of bytes actually read $/;"	m	struct:__anon22
read_from_callbacks	.\openb3d\src\stb_image.c	/^   int read_from_callbacks;$/;"	m	struct:__anon9	file:
red	.\openb3d\src\brush.h	/^	float red,green,blue,alpha;$/;"	m	class:Brush
red	.\openb3d\src\light.h	/^	float red,green,blue;$/;"	m	class:Light
refill_buffer	.\openb3d\src\stb_image.c	/^static void refill_buffer(stbi *s)$/;"	f	file:
render_blobs	.\openb3d\src\isosurface.cpp	/^static list<Blob*> render_blobs;$/;"	v	file:
render_list	.\openb3d\src\camera.cpp	/^list<Mesh*> Camera::render_list;$/;"	m	class:Camera	file:
render_list	.\openb3d\src\camera.h	/^	static list<Mesh*> render_list;$/;"	m	class:Camera
render_mode	.\openb3d\src\isosurface.h	/^	int render_mode;$/;"	m	class:Fluid
render_mode	.\openb3d\src\sprite.h	/^	int render_mode;$/;"	m	class:Sprite
resample	.\openb3d\src\stb_image.c	/^   resample_row_func resample;$/;"	m	struct:__anon14	file:
resample_row_1	.\openb3d\src\stb_image.c	/^static stbi__uint8 *resample_row_1(stbi__uint8 *out, stbi__uint8 *in_near, stbi__uint8 *in_far, int w, int hs)$/;"	f	file:
resample_row_func	.\openb3d\src\stb_image.c	/^typedef stbi__uint8 *(*resample_row_func)(stbi__uint8 *out, stbi__uint8 *in0, stbi__uint8 *in1,$/;"	t	file:
resample_row_generic	.\openb3d\src\stb_image.c	/^static stbi__uint8 *resample_row_generic(stbi__uint8 *out, stbi__uint8 *in_near, stbi__uint8 *in_far, int w, int hs)$/;"	f	file:
resample_row_h_2	.\openb3d\src\stb_image.c	/^static stbi__uint8*  resample_row_h_2(stbi__uint8 *out, stbi__uint8 *in_near, stbi__uint8 *in_far, int w, int hs)$/;"	f	file:
resample_row_hv_2	.\openb3d\src\stb_image.c	/^static stbi__uint8 *resample_row_hv_2(stbi__uint8 *out, stbi__uint8 *in_near, stbi__uint8 *in_far, int w, int hs)$/;"	f	file:
resample_row_v_2	.\openb3d\src\stb_image.c	/^static stbi__uint8* resample_row_v_2(stbi__uint8 *out, stbi__uint8 *in_near, stbi__uint8 *in_far, int w, int hs)$/;"	f	file:
reset	.\openb3d\src\stb_image.c	/^static void reset(jpeg *j)$/;"	f	file:
reset_bounds	.\openb3d\src\mesh.h	/^	int reset_bounds;$/;"	m	class:Mesh
reset_col_tree	.\openb3d\src\mesh.h	/^	int reset_col_tree;$/;"	m	class:Mesh
reset_vbo	.\openb3d\src\surface.h	/^	int reset_vbo; \/\/ (-1 = all)$/;"	m	class:Surface
response	.\openb3d\src\collision2.h	/^	int response;$/;"	m	class:CollisionPair
restart_interval	.\openb3d\src\stb_image.c	/^   int restart_interval, todo;$/;"	m	struct:__anon12	file:
right	.\openb3d\src\tree.h	/^		Node *left,*right;$/;"	m	struct:MeshCollider::Node
rigidBody_list	.\openb3d\src\physics.cpp	/^list<RigidBody*> RigidBody::rigidBody_list;$/;"	m	class:RigidBody	file:
rigidBody_list	.\openb3d\src\physics.h	/^	static list<RigidBody*> rigidBody_list;$/;"	m	class:RigidBody
rollMMatrix	.\openb3d\src\geom.h	/^inline MMatrix rollMMatrix( float q ){$/;"	f
rollQuat	.\openb3d\src\geom.h	/^inline Quat rollQuat( float r ){$/;"	f
root_ent	.\openb3d\src\global.cpp	/^Pivot* Global::root_ent=new Pivot();$/;"	m	class:Global	file:
root_ent	.\openb3d\src\global.h	/^	static Pivot* root_ent;$/;"	m	class:Global
rotationMMatrix	.\openb3d\src\geom.h	/^inline MMatrix rotationMMatrix( const Vector &rot ){$/;"	f
rotationMMatrix	.\openb3d\src\geom.h	/^inline MMatrix rotationMMatrix( float p,float y,float r ){$/;"	f
rotationQuat	.\openb3d\src\geom.cpp	/^Quat rotationQuat( float p,float y,float r ){$/;"	f
rotmat	.\openb3d\src\entity.h	/^	Matrix rotmat;$/;"	m	class:Entity
rx	.\openb3d\src\entity.h	/^	float rx,ry,rz;$/;"	m	class:Entity
ry	.\openb3d\src\entity.h	/^	float rx,ry,rz;$/;"	m	class:Entity
rz	.\openb3d\src\entity.h	/^	float rx,ry,rz;$/;"	m	class:Entity
s	.\openb3d\src\stb_image.c	/^   stbi *s;$/;"	m	struct:__anon12	file:
s	.\openb3d\src\stb_image.c	/^   stbi *s;$/;"	m	struct:__anon18	file:
scaleMMatrix	.\openb3d\src\geom.h	/^inline MMatrix scaleMMatrix( const Vector &scale ){$/;"	f
scaleMMatrix	.\openb3d\src\geom.h	/^inline MMatrix scaleMMatrix( float x,float y,float z ){$/;"	f
scale_x	.\openb3d\src\sprite.h	/^	float scale_x,scale_y;$/;"	m	class:Sprite
scale_y	.\openb3d\src\sprite.h	/^	float scale_x,scale_y;$/;"	m	class:Sprite
scan_n	.\openb3d\src\stb_image.c	/^   int scan_n, order[4];$/;"	m	struct:__anon12	file:
shaderName	.\openb3d\src\shaderobject.h	/^	string shaderName;$/;"	m	class:ShaderObject
shadow_list	.\openb3d\src\shadow.cpp	/^list<ShadowObject*> ShadowObject::shadow_list;$/;"	m	class:ShadowObject	file:
shadow_list	.\openb3d\src\shadow.h	/^	static list<ShadowObject*> shadow_list;$/;"	m	class:ShadowObject
shiftsigned	.\openb3d\src\stb_image.c	/^static int shiftsigned(int v, int shift, int bits)$/;"	f	file:
shine	.\openb3d\src\brush.h	/^	float shine;$/;"	m	class:Brush
sindeg	.\openb3d\src\maths_helper.cpp	/^double sindeg(double degrees)$/;"	f
size	.\openb3d\src\bank.h	/^	int size;$/;"	m	class:Bank
size	.\openb3d\src\stb_image.c	/^   stbi__uint8  size[257];$/;"	m	struct:__anon11	file:
size	.\openb3d\src\stb_image.c	/^   stbi__uint8  size[288];$/;"	m	struct:__anon15	file:
size	.\openb3d\src\stb_image.c	/^   stbi_uc size,type,channel;$/;"	m	struct:__anon20	file:
size	.\openb3d\src\terrain.h	/^	float size; 				\/\/terrainsize$/;"	m	class:Terrain
skip	.\openb3d\src\stb_image.c	/^   void     (*skip)  (void *user,int n);                 \/\/ skip the next 'n' bytes, or 'unget' the last -n bytes if negative$/;"	m	struct:__anon8	file:
skip	.\openb3d\src\stb_image.c	/^static void skip(stbi *s, int n)$/;"	f	file:
skip	.\openb3d\src\stb_image.h	/^   void     (*skip)  (void *user,unsigned n);            \/\/ skip the next 'n' bytes$/;"	m	struct:__anon22
slerpTo	.\openb3d\src\geom.h	/^	Quat slerpTo( const Quat &q,float a )const{$/;"	f	struct:Quat
sphereCollide	.\openb3d\src\collision.cpp	/^bool Collision::sphereCollide( const Line &line,float radius,const Vector &dest,float dest_radius ){$/;"	f	class:Collision
split	.\openb3d\src\x.cpp	/^inline vector<string> split(const string& strValue, char separator){$/;"	f	namespace:loadX
sprite_batch_list	.\openb3d\src\sprite_batch.cpp	/^list<SpriteBatch*> SpriteBatch::sprite_batch_list;$/;"	m	class:SpriteBatch	file:
sprite_batch_list	.\openb3d\src\sprite_batch.h	/^	static list<SpriteBatch*> sprite_batch_list;$/;"	m	class:SpriteBatch
src_type	.\openb3d\src\collision2.h	/^	int src_type;$/;"	m	class:CollisionPair
start_callbacks	.\openb3d\src\stb_image.c	/^static void start_callbacks(stbi *s, stbi_io_callbacks *c, void *user)$/;"	f	file:
start_file	.\openb3d\src\stb_image.c	/^static void start_file(stbi *s, FILE *f)$/;"	f	file:
start_mem	.\openb3d\src\stb_image.c	/^static void start_mem(stbi *s, stbi__uint8 const *buffer, int len)$/;"	f	file:
start_x	.\openb3d\src\stb_image.c	/^   int start_x, start_y;$/;"	m	struct:stbi_gif_struct	file:
start_y	.\openb3d\src\stb_image.c	/^   int start_x, start_y;$/;"	m	struct:stbi_gif_struct	file:
stbi	.\openb3d\src\stb_image.c	/^} stbi;$/;"	t	typeref:struct:__anon9	file:
stbi_YCbCr_installed	.\openb3d\src\stb_image.c	/^static stbi_YCbCr_to_RGB_run stbi_YCbCr_installed = YCbCr_to_RGB_row;$/;"	v	file:
stbi_YCbCr_to_RGB_run	.\openb3d\src\stb_image.c	/^typedef void (*stbi_YCbCr_to_RGB_run)(stbi_uc *output, stbi_uc const  *y, stbi_uc const *cb, stbi_uc const *cr, int count, int step);$/;"	t	file:
stbi_YCbCr_to_RGB_run	.\openb3d\src\stb_image.h	/^typedef void (*stbi_YCbCr_to_RGB_run)(stbi_uc *output, stbi_uc const  *y, stbi_uc const *cb, stbi_uc const *cr, int count, int step);$/;"	t
stbi__int16	.\openb3d\src\stb_image.c	/^typedef   signed short stbi__int16;$/;"	t	file:
stbi__int16	.\openb3d\src\stb_image.c	/^typedef int16_t  stbi__int16;$/;"	t	file:
stbi__int32	.\openb3d\src\stb_image.c	/^typedef   signed int   stbi__int32;$/;"	t	file:
stbi__int32	.\openb3d\src\stb_image.c	/^typedef int32_t  stbi__int32;$/;"	t	file:
stbi__uint16	.\openb3d\src\stb_image.c	/^typedef uint16_t stbi__uint16;$/;"	t	file:
stbi__uint16	.\openb3d\src\stb_image.c	/^typedef unsigned short stbi__uint16;$/;"	t	file:
stbi__uint32	.\openb3d\src\stb_image.c	/^typedef uint32_t stbi__uint32;$/;"	t	file:
stbi__uint32	.\openb3d\src\stb_image.c	/^typedef unsigned int   stbi__uint32;$/;"	t	file:
stbi__uint8	.\openb3d\src\stb_image.c	/^typedef uint8_t  stbi__uint8;$/;"	t	file:
stbi__uint8	.\openb3d\src\stb_image.c	/^typedef unsigned char  stbi__uint8;$/;"	t	file:
stbi_bmp_info	.\openb3d\src\stb_image.c	/^static int stbi_bmp_info(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
stbi_bmp_load	.\openb3d\src\stb_image.c	/^static stbi_uc *stbi_bmp_load(stbi *s,int *x, int *y, int *comp, int req_comp)$/;"	f	file:
stbi_bmp_test	.\openb3d\src\stb_image.c	/^static int stbi_bmp_test(stbi *s)$/;"	f	file:
stbi_convert_iphone_png_to_rgb	.\openb3d\src\stb_image.c	/^void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)$/;"	f
stbi_de_iphone	.\openb3d\src\stb_image.c	/^static void stbi_de_iphone(png *z)$/;"	f	file:
stbi_de_iphone_flag	.\openb3d\src\stb_image.c	/^static int stbi_de_iphone_flag = 0;$/;"	v	file:
stbi_dequantize_t	.\openb3d\src\stb_image.c	/^typedef stbi__uint8 stbi_dequantize_t;$/;"	t	file:
stbi_dequantize_t	.\openb3d\src\stb_image.c	/^typedef unsigned short stbi_dequantize_t;$/;"	t	file:
stbi_failure_reason	.\openb3d\src\stb_image.c	/^const char *stbi_failure_reason(void)$/;"	f
stbi_fill_gif_background	.\openb3d\src\stb_image.c	/^static void stbi_fill_gif_background(stbi_gif *g)$/;"	f	file:
stbi_gif	.\openb3d\src\stb_image.c	/^} stbi_gif;$/;"	t	typeref:struct:stbi_gif_struct	file:
stbi_gif_header	.\openb3d\src\stb_image.c	/^static int stbi_gif_header(stbi *s, stbi_gif *g, int *comp, int is_info)$/;"	f	file:
stbi_gif_info	.\openb3d\src\stb_image.c	/^static int stbi_gif_info(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
stbi_gif_info_raw	.\openb3d\src\stb_image.c	/^static int stbi_gif_info_raw(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
stbi_gif_load	.\openb3d\src\stb_image.c	/^static stbi_uc *stbi_gif_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
stbi_gif_load_next	.\openb3d\src\stb_image.c	/^static stbi__uint8 *stbi_gif_load_next(stbi *s, stbi_gif *g, int *comp, int req_comp)$/;"	f	file:
stbi_gif_lzw	.\openb3d\src\stb_image.c	/^} stbi_gif_lzw;$/;"	t	typeref:struct:stbi_gif_lzw_struct	file:
stbi_gif_lzw_struct	.\openb3d\src\stb_image.c	/^typedef struct stbi_gif_lzw_struct {$/;"	s	file:
stbi_gif_parse_colortable	.\openb3d\src\stb_image.c	/^static void stbi_gif_parse_colortable(stbi *s, stbi__uint8 pal[256][4], int num_entries, int transp)$/;"	f	file:
stbi_gif_struct	.\openb3d\src\stb_image.c	/^typedef struct stbi_gif_struct$/;"	s	file:
stbi_gif_test	.\openb3d\src\stb_image.c	/^static int stbi_gif_test(stbi *s)$/;"	f	file:
stbi_hdr_info	.\openb3d\src\stb_image.c	/^static int stbi_hdr_info(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
stbi_hdr_load	.\openb3d\src\stb_image.c	/^static float *stbi_hdr_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
stbi_hdr_test	.\openb3d\src\stb_image.c	/^static int stbi_hdr_test(stbi* s)$/;"	f	file:
stbi_hdr_to_ldr_gamma	.\openb3d\src\stb_image.c	/^void   stbi_hdr_to_ldr_gamma(float gamma) { h2l_gamma_i = 1\/gamma; }$/;"	f
stbi_hdr_to_ldr_scale	.\openb3d\src\stb_image.c	/^void   stbi_hdr_to_ldr_scale(float scale) { h2l_scale_i = 1\/scale; }$/;"	f
stbi_idct_8x8	.\openb3d\src\stb_image.c	/^typedef void (*stbi_idct_8x8)(stbi_uc *out, int out_stride, short data[64], unsigned short *dequantize);$/;"	t	file:
stbi_idct_8x8	.\openb3d\src\stb_image.h	/^typedef void (*stbi_idct_8x8)(stbi_uc *out, int out_stride, short data[64], unsigned short *dequantize);$/;"	t
stbi_idct_installed	.\openb3d\src\stb_image.c	/^static stbi_idct_8x8 stbi_idct_installed = idct_block;$/;"	v	file:
stbi_image_free	.\openb3d\src\stb_image.c	/^void stbi_image_free(void *retval_from_stbi_load)$/;"	f
stbi_info	.\openb3d\src\stb_image.c	/^int stbi_info(char const *filename, int *x, int *y, int *comp)$/;"	f
stbi_info_from_callbacks	.\openb3d\src\stb_image.c	/^int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)$/;"	f
stbi_info_from_file	.\openb3d\src\stb_image.c	/^int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)$/;"	f
stbi_info_from_memory	.\openb3d\src\stb_image.c	/^int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)$/;"	f
stbi_info_main	.\openb3d\src\stb_image.c	/^static int stbi_info_main(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
stbi_inline	.\openb3d\src\stb_image.c	357;"	d	file:
stbi_inline	.\openb3d\src\stb_image.c	359;"	d	file:
stbi_inline	.\openb3d\src\stb_image.c	362;"	d	file:
stbi_install_YCbCr_to_RGB	.\openb3d\src\stb_image.c	/^void stbi_install_YCbCr_to_RGB(stbi_YCbCr_to_RGB_run func)$/;"	f
stbi_install_idct	.\openb3d\src\stb_image.c	/^void stbi_install_idct(stbi_idct_8x8 func)$/;"	f
stbi_io_callbacks	.\openb3d\src\stb_image.c	/^} stbi_io_callbacks;$/;"	t	typeref:struct:__anon8	file:
stbi_io_callbacks	.\openb3d\src\stb_image.h	/^} stbi_io_callbacks;$/;"	t	typeref:struct:__anon22
stbi_is_hdr	.\openb3d\src\stb_image.c	/^extern int      stbi_is_hdr          (char const *filename)$/;"	f
stbi_is_hdr_from_callbacks	.\openb3d\src\stb_image.c	/^extern int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)$/;"	f
stbi_is_hdr_from_file	.\openb3d\src\stb_image.c	/^extern int      stbi_is_hdr_from_file(FILE *f)$/;"	f
stbi_is_hdr_from_memory	.\openb3d\src\stb_image.c	/^int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)$/;"	f
stbi_jpeg_info	.\openb3d\src\stb_image.c	/^static int stbi_jpeg_info(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
stbi_jpeg_info_raw	.\openb3d\src\stb_image.c	/^static int stbi_jpeg_info_raw(jpeg *j, int *x, int *y, int *comp)$/;"	f	file:
stbi_jpeg_load	.\openb3d\src\stb_image.c	/^static unsigned char *stbi_jpeg_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
stbi_jpeg_test	.\openb3d\src\stb_image.c	/^static int stbi_jpeg_test(stbi *s)$/;"	f	file:
stbi_ldr_to_hdr_gamma	.\openb3d\src\stb_image.c	/^void   stbi_ldr_to_hdr_gamma(float gamma) { l2h_gamma = gamma; }$/;"	f
stbi_ldr_to_hdr_scale	.\openb3d\src\stb_image.c	/^void   stbi_ldr_to_hdr_scale(float scale) { l2h_scale = scale; }$/;"	f
stbi_load	.\openb3d\src\stb_image.c	/^unsigned char *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_load_from_callbacks	.\openb3d\src\stb_image.c	/^unsigned char *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_load_from_file	.\openb3d\src\stb_image.c	/^unsigned char *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_load_from_memory	.\openb3d\src\stb_image.c	/^unsigned char *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_load_main	.\openb3d\src\stb_image.c	/^static unsigned char *stbi_load_main(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
stbi_loadf	.\openb3d\src\stb_image.c	/^float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_loadf_from_callbacks	.\openb3d\src\stb_image.c	/^float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_loadf_from_file	.\openb3d\src\stb_image.c	/^float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_loadf_from_memory	.\openb3d\src\stb_image.c	/^float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_loadf_main	.\openb3d\src\stb_image.c	/^float *stbi_loadf_main(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_lrot	.\openb3d\src\stb_image.c	395;"	d	file:
stbi_lrot	.\openb3d\src\stb_image.c	397;"	d	file:
stbi_out_gif_code	.\openb3d\src\stb_image.c	/^static void stbi_out_gif_code(stbi_gif *g, stbi__uint16 code)$/;"	f	file:
stbi_pic_info	.\openb3d\src\stb_image.c	/^static int stbi_pic_info(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
stbi_pic_load	.\openb3d\src\stb_image.c	/^static stbi_uc *stbi_pic_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
stbi_pic_test	.\openb3d\src\stb_image.c	/^static int stbi_pic_test(stbi *s)$/;"	f	file:
stbi_png_info	.\openb3d\src\stb_image.c	/^static int      stbi_png_info(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
stbi_png_info_raw	.\openb3d\src\stb_image.c	/^static int stbi_png_info_raw(png *p, int *x, int *y, int *comp)$/;"	f	file:
stbi_png_load	.\openb3d\src\stb_image.c	/^static unsigned char *stbi_png_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
stbi_png_partial	.\openb3d\src\stb_image.c	/^int stbi_png_partial; \/\/ a quick hack to only allow decoding some of a PNG... I should implement real streaming support instead$/;"	v
stbi_png_test	.\openb3d\src\stb_image.c	/^static int stbi_png_test(stbi *s)$/;"	f	file:
stbi_process_gif_raster	.\openb3d\src\stb_image.c	/^static stbi__uint8 *stbi_process_gif_raster(stbi *s, stbi_gif *g)$/;"	f	file:
stbi_psd_info	.\openb3d\src\stb_image.c	/^static int stbi_psd_info(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
stbi_psd_load	.\openb3d\src\stb_image.c	/^static stbi_uc *stbi_psd_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
stbi_psd_test	.\openb3d\src\stb_image.c	/^static int stbi_psd_test(stbi *s)$/;"	f	file:
stbi_resample	.\openb3d\src\stb_image.c	/^} stbi_resample;$/;"	t	typeref:struct:__anon14	file:
stbi_rewind	.\openb3d\src\stb_image.c	/^static void stbi_rewind(stbi *s)$/;"	f	file:
stbi_set_unpremultiply_on_load	.\openb3d\src\stb_image.c	/^void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)$/;"	f
stbi_stdio_callbacks	.\openb3d\src\stb_image.c	/^static stbi_io_callbacks stbi_stdio_callbacks =$/;"	v	file:
stbi_tga_info	.\openb3d\src\stb_image.c	/^int stbi_tga_info(stbi *s, int *x, int *y, int *comp)$/;"	f
stbi_tga_load	.\openb3d\src\stb_image.c	/^static stbi_uc *stbi_tga_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
stbi_tga_test	.\openb3d\src\stb_image.c	/^static int stbi_tga_test(stbi *s)$/;"	f	file:
stbi_uc	.\openb3d\src\stb_image.c	/^typedef unsigned char stbi_uc;$/;"	t	file:
stbi_uc	.\openb3d\src\stb_image.h	/^typedef unsigned char stbi_uc;$/;"	t
stbi_unpremultiply_on_load	.\openb3d\src\stb_image.c	/^static int stbi_unpremultiply_on_load = 0;$/;"	v	file:
stbi_zlib_decode_buffer	.\openb3d\src\stb_image.c	/^int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)$/;"	f
stbi_zlib_decode_malloc	.\openb3d\src\stb_image.c	/^char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)$/;"	f
stbi_zlib_decode_malloc_guesssize	.\openb3d\src\stb_image.c	/^char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)$/;"	f
stbi_zlib_decode_malloc_guesssize_headerflag	.\openb3d\src\stb_image.c	/^char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)$/;"	f
stbi_zlib_decode_noheader_buffer	.\openb3d\src\stb_image.c	/^int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)$/;"	f
stbi_zlib_decode_noheader_malloc	.\openb3d\src\stb_image.c	/^char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)$/;"	f
stdio_eof	.\openb3d\src\stb_image.c	/^static int stdio_eof(void *user)$/;"	f	file:
stdio_read	.\openb3d\src\stb_image.c	/^static int stdio_read(void *user, char *data, int size)$/;"	f	file:
stdio_skip	.\openb3d\src\stb_image.c	/^static void stdio_skip(void *user, int n)$/;"	f	file:
stencil_mode	.\openb3d\src\stencil.h	/^	int stencil_mode;$/;"	m	class:Stencil
stencil_operator	.\openb3d\src\stencil.h	/^	int stencil_operator;$/;"	m	class:Stencil
step	.\openb3d\src\stb_image.c	/^   int parse, step;$/;"	m	struct:stbi_gif_struct	file:
string_find_and_replace	.\openb3d\src\x.cpp	/^void string_find_and_replace( string &source, string find, string replace ) {$/;"	f	namespace:loadX
suffix	.\openb3d\src\stb_image.c	/^   stbi__uint8 suffix;$/;"	m	struct:stbi_gif_lzw_struct	file:
surf	.\openb3d\src\collision2.h	/^	Surface* surf;$/;"	m	class:CollisionImpact
surf	.\openb3d\src\csg.h	/^	Surface* surf;$/;"	m	class:CSGTriangle
surf	.\openb3d\src\shadermat.h	/^			Surface* surf;$/;"	m	struct:ShaderData::__anon5::__anon6
surf	.\openb3d\src\shadow.h	/^	Surface* surf;$/;"	m	class:Edge
surf	.\openb3d\src\shadow.h	/^	int surf;$/;"	m	class:ShadowTriangle
surf	.\openb3d\src\sprite_batch.h	/^	Surface* surf;$/;"	m	class:SpriteBatch
surf_list	.\openb3d\src\mesh.h	/^	list<Surface*> surf_list;$/;"	m	class:Mesh
surface	.\openb3d\src\3ds.cpp	/^Surface*       surface;$/;"	m	namespace:load3ds	file:
surface	.\openb3d\src\collision.h	/^	int surface;$/;"	m	struct:Collision
surface	.\openb3d\src\tree.h	/^		int surface;$/;"	m	struct:MeshCollider::Triangle
sv	.\openb3d\src\collision.h	/^	Vector sv;$/;"	m	struct:CollisionInfo
sx	.\openb3d\src\animation_keys.h	/^	vector<float> sx;$/;"	m	class:AnimationKeys
sx	.\openb3d\src\entity.h	/^	float sx,sy,sz;$/;"	m	class:Entity
sy	.\openb3d\src\animation_keys.h	/^	vector<float> sy;$/;"	m	class:AnimationKeys
sy	.\openb3d\src\entity.h	/^	float sx,sy,sz;$/;"	m	class:Entity
sz	.\openb3d\src\animation_keys.h	/^	vector<float> sz;$/;"	m	class:AnimationKeys
sz	.\openb3d\src\entity.h	/^	float sx,sy,sz;$/;"	m	class:Entity
t_intersect	.\openb3d\src\geom.h	/^	float t_intersect( const Line &q )const{$/;"	f	class:Plane
ta	.\openb3d\src\shadow.h	/^	int ta, tb, tc;$/;"	m	class:ShadowTriangle
tandeg	.\openb3d\src\maths_helper.cpp	/^double tandeg(double degrees)$/;"	f
target	.\openb3d\src\actions.h	/^	Entity* target;		\/\/Optional, target entity for some actions$/;"	m	class:Action
tb	.\openb3d\src\shadow.h	/^	int ta, tb, tc;$/;"	m	class:ShadowTriangle
tbuffer	.\openb3d\src\voxterrain.h	/^	float ***tbuffer;$/;"	m	class:VoxelTerrain
tc	.\openb3d\src\shadow.h	/^	int ta, tb, tc;$/;"	m	class:ShadowTriangle
td	.\openb3d\src\collision.h	/^	float td;$/;"	m	struct:CollisionInfo
td_xz	.\openb3d\src\collision.h	/^	float td_xz;$/;"	m	struct:CollisionInfo
terrain_list	.\openb3d\src\terrain.cpp	/^list<Terrain*> Terrain::terrain_list;$/;"	m	class:Terrain	file:
terrain_list	.\openb3d\src\terrain.h	/^	static list<Terrain*> terrain_list;$/;"	m	class:Terrain
tex	.\openb3d\src\brush.h	/^	Texture* tex[8];$/;"	m	class:Brush
texCount	.\openb3d\src\shadermat.h	/^	int texCount;$/;"	m	class:Shader
tex_filter_list	.\openb3d\src\texture_filter.cpp	/^list<TextureFilter*> TextureFilter::tex_filter_list;$/;"	m	class:TextureFilter	file:
tex_filter_list	.\openb3d\src\texture_filter.h	/^	static list<TextureFilter*> tex_filter_list;$/;"	m	class:TextureFilter
tex_list	.\openb3d\src\texture.cpp	/^list<Texture*> Texture::tex_list;$/;"	m	class:Texture	file:
tex_list	.\openb3d\src\texture.h	/^	static list<Texture*> tex_list;$/;"	m	class:Texture
text_match	.\openb3d\src\texture_filter.h	/^	string text_match;$/;"	m	class:TextureFilter
texture	.\openb3d\src\3ds.cpp	/^Texture*       texture;$/;"	m	namespace:load3ds	file:
texture	.\openb3d\src\shadermat.h	/^	Texture* texture;$/;"	m	class:Sampler
texture	.\openb3d\src\sprite_batch.h	/^	Texture* texture;$/;"	m	class:SpriteBatch
texture	.\openb3d\src\texture.h	/^	unsigned int texture;$/;"	m	class:Texture
tf_v1x	.\openb3d\src\shadow.h	/^	float tf_v1x, tf_v1y, tf_v1z;$/;"	m	class:ShadowTriangle
tf_v1y	.\openb3d\src\shadow.h	/^	float tf_v1x, tf_v1y, tf_v1z;$/;"	m	class:ShadowTriangle
tf_v1z	.\openb3d\src\shadow.h	/^	float tf_v1x, tf_v1y, tf_v1z;$/;"	m	class:ShadowTriangle
tf_v2x	.\openb3d\src\shadow.h	/^	float tf_v2x, tf_v2y, tf_v2z;$/;"	m	class:ShadowTriangle
tf_v2y	.\openb3d\src\shadow.h	/^	float tf_v2x, tf_v2y, tf_v2z;$/;"	m	class:ShadowTriangle
tf_v2z	.\openb3d\src\shadow.h	/^	float tf_v2x, tf_v2y, tf_v2z;$/;"	m	class:ShadowTriangle
tf_v3x	.\openb3d\src\shadow.h	/^	float tf_v3x, tf_v3y, tf_v3z;$/;"	m	class:ShadowTriangle
tf_v3y	.\openb3d\src\shadow.h	/^	float tf_v3x, tf_v3y, tf_v3z;$/;"	m	class:ShadowTriangle
tf_v3z	.\openb3d\src\shadow.h	/^	float tf_v3x, tf_v3y, tf_v3z;$/;"	m	class:ShadowTriangle
tform_mat	.\openb3d\src\bone.h	/^	Matrix tform_mat;$/;"	m	class:Bone
tformed_x	.\openb3d\src\entity.cpp	/^float Entity::tformed_x=0.0;$/;"	m	class:Entity	file:
tformed_x	.\openb3d\src\entity.h	/^	static float tformed_x;$/;"	m	class:Entity
tformed_y	.\openb3d\src\entity.cpp	/^float Entity::tformed_y=0.0;$/;"	m	class:Entity	file:
tformed_y	.\openb3d\src\entity.h	/^	static float tformed_y;$/;"	m	class:Entity
tformed_z	.\openb3d\src\entity.cpp	/^float Entity::tformed_z=0.0;$/;"	m	class:Entity	file:
tformed_z	.\openb3d\src\entity.h	/^	static float tformed_z;$/;"	m	class:Entity
tga_info	.\openb3d\src\stb_image.c	/^static int tga_info(stbi *s, int *x, int *y, int *comp)$/;"	f	file:
tga_load	.\openb3d\src\stb_image.c	/^static stbi_uc *tga_load(stbi *s, int *x, int *y, int *comp, int req_comp)$/;"	f	file:
tga_test	.\openb3d\src\stb_image.c	/^static int tga_test(stbi *s)$/;"	f	file:
threshold	.\openb3d\src\isosurface.h	/^	float threshold;$/;"	m	class:Fluid
time	.\openb3d\src\collision.h	/^	float time;$/;"	m	struct:Collision
time	.\openb3d\src\collision2.h	/^	float time;$/;"	m	class:CollisionImpact
tmps	.\openb3d\src\geom.cpp	/^MMatrix MMatrix::tmps[64];$/;"	m	class:MMatrix	file:
tmps	.\openb3d\src\geom.cpp	/^Transform Transform::tmps[64];$/;"	m	class:Transform	file:
tmps	.\openb3d\src\geom.h	/^	static MMatrix tmps[64];$/;"	m	class:MMatrix
tmps	.\openb3d\src\geom.h	/^	static Transform tmps[64];$/;"	m	class:Transform
todo	.\openb3d\src\stb_image.c	/^   int restart_interval, todo;$/;"	m	struct:__anon12	file:
top_caps	.\openb3d\src\shadow.cpp	/^char ShadowObject::top_caps=true;$/;"	m	class:ShadowObject	file:
top_caps	.\openb3d\src\shadow.h	/^	static char top_caps;$/;"	m	class:ShadowObject
total_verts	.\openb3d\src\octree.cpp	/^static int total_verts;$/;"	v	file:
touch_list	.\openb3d\src\touch.cpp	/^vector<Touch*> Touch::touch_list;$/;"	m	class:Touch	file:
touch_list	.\openb3d\src\touch.h	/^	static vector<Touch*> touch_list; \/\/ includes active touches only$/;"	m	class:Touch
tpicked	.\openb3d\src\csg.cpp	/^float npicked[3], tpicked[3];$/;"	m	namespace:CSG	file:
tq	.\openb3d\src\stb_image.c	/^      int tq;$/;"	m	struct:__anon12::__anon13	file:
trail	.\openb3d\src\particle.h	/^	int trail;$/;"	m	class:ParticleBatch
transformRadius	.\openb3d\src\geom.h	/^inline float transformRadius( float r,const MMatrix &t ){$/;"	f
transform_point	.\openb3d\src\project.cpp	/^transform_point(GLfloat out[4], const GLfloat m[16], const GLfloat in[4])$/;"	f	file:
transparent	.\openb3d\src\stb_image.c	/^   int flags, bgindex, ratio, transparent, eflags;$/;"	m	struct:stbi_gif_struct	file:
tree	.\openb3d\src\tree.h	/^	Node *tree;$/;"	m	class:MeshCollider
tri	.\openb3d\src\collision2.h	/^	int tri;$/;"	m	class:CollisionImpact
triTable	.\openb3d\src\isosurface.cpp	/^extern const int triTable[256][16] =$/;"	v
triTest	.\openb3d\src\tree.cpp	/^static bool triTest( const Vector a[3],const Vector b[3] ){$/;"	f	file:
tri_array_size	.\openb3d\src\surface.h	/^	int tri_array_size;$/;"	m	class:Surface
tri_centres	.\openb3d\src\tree.cpp	/^static vector<Vector> tri_centres;$/;"	v	file:
tri_list	.\openb3d\src\tree.h	/^	vector<MeshCollider::Triangle> tri_list;$/;"	m	class:MeshInfo
tri_tri_intersect	.\openb3d\src\collidetri.c	/^int tri_tri_intersect(float V0[3],float V1[3],float V2[3],$/;"	f
triangleCollide	.\openb3d\src\collision.cpp	/^bool Collision::triangleCollide( const Line &line,float radius,const Vector &v0,const Vector &v1,const Vector &v2 ){$/;"	f	class:Collision
triangleindex	.\openb3d\src\terrain.cpp	/^int Terrain::triangleindex;$/;"	m	class:Terrain	file:
triangleindex	.\openb3d\src\terrain.h	/^	static int triangleindex;$/;"	m	class:Terrain
triangles	.\openb3d\src\tree.h	/^		vector<int> triangles;$/;"	m	struct:MeshCollider::Node
triangles	.\openb3d\src\tree.h	/^	vector<Triangle> triangles;$/;"	m	class:MeshCollider
tris	.\openb3d\src\shadow.h	/^	int tris;$/;"	m	class:ShadowTriangle
tris	.\openb3d\src\surface.h	/^	vector<unsigned short> tris;$/;"	m	class:Surface
trisIntersect	.\openb3d\src\tree.cpp	/^static bool trisIntersect( const Vector a[3],const Vector b[3] ){$/;"	f	file:
type	.\openb3d\src\shadermat.h	/^	int type;$/;"	m	class:ShaderData
type	.\openb3d\src\stb_image.c	/^   stbi__uint32 type;$/;"	m	struct:__anon17	file:
type	.\openb3d\src\stb_image.c	/^   stbi_uc size,type,channel;$/;"	m	struct:__anon20	file:
type	.\openb3d\src\touch.h	/^	int type;$/;"	m	class:Touch
u0	.\openb3d\src\csg.h	/^	float x0,y0,z0,u0,v0;$/;"	m	class:CSGTriangle
u1	.\openb3d\src\csg.h	/^	float x1,y1,z1,u1,v1;$/;"	m	class:CSGTriangle
u2	.\openb3d\src\csg.h	/^	float x2,y2,z2,u2,v2;$/;"	m	class:CSGTriangle
u_pos	.\openb3d\src\texture.h	/^	float u_scale,v_scale,u_pos,v_pos,angle;$/;"	m	class:Texture
u_scale	.\openb3d\src\texture.h	/^	float u_scale,v_scale,u_pos,v_pos,angle;$/;"	m	class:Texture
update	.\openb3d\src\collision.cpp	/^bool Collision::update( const Line &line,float t,const Vector &n ){$/;"	f	class:Collision
update	.\openb3d\src\geom.h	/^	void update( const Box &q ){$/;"	f	class:Box
update	.\openb3d\src\geom.h	/^	void update( const Vector &q ){$/;"	f	class:Box
v	.\openb3d\src\geom.h	/^	Vector v;$/;"	m	class:Transform
v	.\openb3d\src\geom.h	/^	Vector v;$/;"	m	struct:Quat
v	.\openb3d\src\stb_image.c	/^      int h,v;$/;"	m	struct:__anon12::__anon13	file:
v0	.\openb3d\src\csg.h	/^	float x0,y0,z0,u0,v0;$/;"	m	class:CSGTriangle
v1	.\openb3d\src\csg.h	/^	float x1,y1,z1,u1,v1;$/;"	m	class:CSGTriangle
v1x	.\openb3d\src\shadow.h	/^	float v1x, v1y, v1z;$/;"	m	class:ShadowTriangle
v1y	.\openb3d\src\shadow.h	/^	float v1x, v1y, v1z;$/;"	m	class:ShadowTriangle
v1z	.\openb3d\src\shadow.h	/^	float v1x, v1y, v1z;$/;"	m	class:ShadowTriangle
v2	.\openb3d\src\csg.h	/^	float x2,y2,z2,u2,v2;$/;"	m	class:CSGTriangle
v2x	.\openb3d\src\shadow.h	/^	float v2x, v2y, v2z;$/;"	m	class:ShadowTriangle
v2y	.\openb3d\src\shadow.h	/^	float v2x, v2y, v2z;$/;"	m	class:ShadowTriangle
v2z	.\openb3d\src\shadow.h	/^	float v2x, v2y, v2z;$/;"	m	class:ShadowTriangle
v3x	.\openb3d\src\shadow.h	/^	float v3x, v3y, v3z;$/;"	m	class:ShadowTriangle
v3y	.\openb3d\src\shadow.h	/^	float v3x, v3y, v3z;$/;"	m	class:ShadowTriangle
v3z	.\openb3d\src\shadow.h	/^	float v3x, v3y, v3z;$/;"	m	class:ShadowTriangle
vList	.\openb3d\src\shaderobject.h	/^	list<ShaderObject*> vList;	\/\/ Vertex shader list. A List of what Vert shaders are attached to this ProgramObject$/;"	m	class:ProgramObject
v_pos	.\openb3d\src\texture.h	/^	float u_scale,v_scale,u_pos,v_pos,angle;$/;"	m	class:Texture
v_scale	.\openb3d\src\texture.h	/^	float u_scale,v_scale,u_pos,v_pos,angle;$/;"	m	class:Texture
validate_uint32	.\openb3d\src\stb_image.c	/^typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];$/;"	t	file:
value	.\openb3d\src\stb_image.c	/^   stbi__uint16 value[288]; $/;"	m	struct:__anon15	file:
values	.\openb3d\src\stb_image.c	/^   stbi__uint8  values[256];$/;"	m	struct:__anon11	file:
variance	.\openb3d\src\particle.h	/^	float variance;$/;"	m	class:ParticleEmitter
vbo	.\openb3d\src\shadermat.h	/^			int vbo;$/;"	m	struct:ShaderData::__anon5::__anon6
vbo_enabled	.\openb3d\src\global.cpp	/^int Global::vbo_enabled=true,Global::vbo_min_tris=0;$/;"	m	class:Global	file:
vbo_enabled	.\openb3d\src\global.h	/^	static int vbo_enabled;$/;"	m	class:Global
vbo_enabled	.\openb3d\src\surface.h	/^	int vbo_enabled;$/;"	m	class:Surface
vbo_id	.\openb3d\src\surface.h	/^	unsigned int vbo_id[7];$/;"	m	class:Surface
vbo_min_tris	.\openb3d\src\global.cpp	/^int Global::vbo_enabled=true,Global::vbo_min_tris=0;$/;"	m	class:Global	file:
vbo_min_tris	.\openb3d\src\global.h	/^	static int vbo_min_tris;$/;"	m	class:Global
vertShaderCount	.\openb3d\src\shaderobject.h	/^	int vertShaderCount;$/;"	m	class:ProgramObject
vert_array_size	.\openb3d\src\surface.h	/^	int vert_array_size;$/;"	m	class:Surface
vert_bone1_no	.\openb3d\src\surface.h	/^	vector<int> vert_bone1_no; \/\/ stores bone no - bone no used to reference bones[] array belonging to TMesh$/;"	m	class:Surface
vert_bone2_no	.\openb3d\src\surface.h	/^	vector<int> vert_bone2_no;$/;"	m	class:Surface
vert_bone3_no	.\openb3d\src\surface.h	/^	vector<int> vert_bone3_no;$/;"	m	class:Surface
vert_bone4_no	.\openb3d\src\surface.h	/^	vector<int> vert_bone4_no;$/;"	m	class:Surface
vert_col	.\openb3d\src\surface.h	/^	vector<float> vert_col;$/;"	m	class:Surface
vert_coords	.\openb3d\src\surface.h	/^	vector<float> vert_coords;$/;"	m	class:Surface
vert_list	.\openb3d\src\tree.h	/^	vector<MeshCollider::Vertex> vert_list;$/;"	m	class:MeshInfo
vert_norm	.\openb3d\src\surface.h	/^	vector<float> vert_norm;$/;"	m	class:Surface
vert_tex_coords0	.\openb3d\src\surface.h	/^	vector<float> vert_tex_coords0;$/;"	m	class:Surface
vert_tex_coords1	.\openb3d\src\surface.h	/^	vector<float> vert_tex_coords1;$/;"	m	class:Surface
vert_weight1	.\openb3d\src\surface.h	/^	vector<float> vert_weight1;$/;"	m	class:Surface
vert_weight2	.\openb3d\src\surface.h	/^	vector<float> vert_weight2;$/;"	m	class:Surface
vert_weight3	.\openb3d\src\surface.h	/^	vector<float> vert_weight3;$/;"	m	class:Surface
vert_weight4	.\openb3d\src\surface.h	/^	vector<float> vert_weight4;$/;"	m	class:Surface
vertices	.\openb3d\src\geosphere.cpp	/^static vector<float> vertices;$/;"	v	file:
vertices	.\openb3d\src\terrain.cpp	/^static vector<float> vertices;$/;"	v	file:
vertices	.\openb3d\src\tree.h	/^	vector<Vertex> vertices;$/;"	m	class:MeshCollider
vertices	.\openb3d\src\voxterrain.cpp	/^static vector<float> vertices;$/;"	v	file:
verts	.\openb3d\src\tree.h	/^		int verts[3],index;$/;"	m	struct:MeshCollider::Triangle
vheight	.\openb3d\src\camera.h	/^	int vx,vy,vwidth,vheight;$/;"	m	class:Camera
view_mode	.\openb3d\src\sprite.h	/^	int view_mode;$/;"	m	class:Sprite
viewport	.\openb3d\src\camera.h	/^	int viewport[4];$/;"	m	class:Camera
vmax	.\openb3d\src\surface.h	/^	int vmax; \/\/ used for trimming verts from b3d files$/;"	m	class:Surface
vmin	.\openb3d\src\surface.h	/^	int vmin; \/\/ used for trimming verts from b3d files$/;"	m	class:Surface
vs	.\openb3d\src\stb_image.c	/^   int hs,vs;   \/\/ expansion factor in each axis$/;"	m	struct:__anon14	file:
vsize	.\openb3d\src\terrain.h	/^	float vsize; 				\/\/terrainheight$/;"	m	class:Terrain
vwidth	.\openb3d\src\camera.h	/^	int vx,vy,vwidth,vheight;$/;"	m	class:Camera
vx	.\openb3d\src\camera.h	/^	int vx,vy,vwidth,vheight;$/;"	m	class:Camera
vx	.\openb3d\src\particle.h	/^		float vx,vy,vz;$/;"	m	struct:ParticleEmitter::ParticleData
vy	.\openb3d\src\camera.h	/^	int vx,vy,vwidth,vheight;$/;"	m	class:Camera
vy	.\openb3d\src\particle.h	/^		float vx,vy,vz;$/;"	m	struct:ParticleEmitter::ParticleData
vz	.\openb3d\src\particle.h	/^		float vx,vy,vz;$/;"	m	struct:ParticleEmitter::ParticleData
w	.\openb3d\src\geom.h	/^	float w;$/;"	m	struct:Quat
w	.\openb3d\src\quaternion.h	/^float x,y,z,w;$/;"	m	class:Quaternion
w	.\openb3d\src\stb_image.c	/^   int w,h;$/;"	m	struct:stbi_gif_struct	file:
w2	.\openb3d\src\stb_image.c	/^      int x,y,w2,h2;$/;"	m	struct:__anon12::__anon13	file:
w_lores	.\openb3d\src\stb_image.c	/^   int w_lores; \/\/ horizontal pixels pre-expansion $/;"	m	struct:__anon14	file:
width	.\openb3d\src\geom.h	/^	float width()const{$/;"	f	class:Box
width	.\openb3d\src\global.cpp	/^int Global::width=640,Global::height=480;$/;"	m	class:Global	file:
width	.\openb3d\src\global.h	/^	static int width,height,mode,depth,rate;$/;"	m	class:Global
width	.\openb3d\src\isosurface.h	/^	int width, height, depth;$/;"	m	class:FieldArray
width	.\openb3d\src\octree.h	/^	float x,y,z, width, height, depth;$/;"	m	class:OcTreeChild
width	.\openb3d\src\texture.h	/^	int width,height; \/\/ returned by Name\/Width\/Height commands$/;"	m	class:Texture
x	.\openb3d\src\collision2.h	/^	float x,y,z;$/;"	m	class:CollisionImpact
x	.\openb3d\src\geom.h	/^	float x,y,z;$/;"	m	class:Vector
x	.\openb3d\src\octree.h	/^	float x,y,z, width, height, depth;$/;"	m	class:OcTreeChild
x	.\openb3d\src\quaternion.h	/^float x,y,z,w;$/;"	m	class:Quaternion
x	.\openb3d\src\stb_image.c	/^      int x,y,w2,h2;$/;"	m	struct:__anon12::__anon13	file:
x	.\openb3d\src\tilt.cpp	/^float Tilt::x=0.0;$/;"	m	class:Tilt	file:
x	.\openb3d\src\tilt.h	/^	static float x,y,z;$/;"	m	class:Tilt
x	.\openb3d\src\touch.h	/^	float x,y;$/;"	m	class:Touch
x0	.\openb3d\src\csg.h	/^	float x0,y0,z0,u0,v0;$/;"	m	class:CSGTriangle
x1	.\openb3d\src\csg.h	/^	float x1,y1,z1,u1,v1;$/;"	m	class:CSGTriangle
x2	.\openb3d\src\csg.h	/^	float x2,y2,z2,u2,v2;$/;"	m	class:CSGTriangle
xReadAll	.\openb3d\src\x.cpp	/^string xReadAll(File* file){$/;"	f	namespace:loadX
xReadString	.\openb3d\src\x.cpp	/^string xReadString(File* file, int lenght){$/;"	f	namespace:loadX
xcf	.\openb3d\src\geosphere.h	/^	float xcf,ycf,zcf; 			\/\/used to store camera position$/;"	m	class:Geosphere
xcf	.\openb3d\src\terrain.h	/^	float xcf,ycf,zcf; 			\/\/used to store camera position$/;"	m	class:Terrain
xybuffer	.\openb3d\src\isosurface.h	/^	float ***xybuffer;$/;"	m	class:Fluid
xzbuffer	.\openb3d\src\isosurface.h	/^	float ***xzbuffer;$/;"	m	class:Fluid
y	.\openb3d\src\collision2.h	/^	float x,y,z;$/;"	m	class:CollisionImpact
y	.\openb3d\src\geom.h	/^	float x,y,z;$/;"	m	class:Vector
y	.\openb3d\src\octree.h	/^	float x,y,z, width, height, depth;$/;"	m	class:OcTreeChild
y	.\openb3d\src\quaternion.h	/^float x,y,z,w;$/;"	m	class:Quaternion
y	.\openb3d\src\stb_image.c	/^      int x,y,w2,h2;$/;"	m	struct:__anon12::__anon13	file:
y	.\openb3d\src\tilt.cpp	/^float Tilt::y=0.0;$/;"	m	class:Tilt	file:
y	.\openb3d\src\tilt.h	/^	static float x,y,z;$/;"	m	class:Tilt
y	.\openb3d\src\touch.h	/^	float x,y;$/;"	m	class:Touch
y0	.\openb3d\src\csg.h	/^	float x0,y0,z0,u0,v0;$/;"	m	class:CSGTriangle
y1	.\openb3d\src\csg.h	/^	float x1,y1,z1,u1,v1;$/;"	m	class:CSGTriangle
y2	.\openb3d\src\csg.h	/^	float x2,y2,z2,u2,v2;$/;"	m	class:CSGTriangle
y_scale	.\openb3d\src\collision.h	/^	float y_scale;$/;"	m	struct:CollisionInfo
y_tform	.\openb3d\src\collision.h	/^	Transform y_tform;$/;"	m	struct:CollisionInfo
yaw	.\openb3d\src\geom.h	/^	float yaw()const{$/;"	f	class:Vector
yawMMatrix	.\openb3d\src\geom.h	/^inline MMatrix yawMMatrix( float q ){$/;"	f
yawQuat	.\openb3d\src\geom.h	/^inline Quat yawQuat( float y ){$/;"	f
ycf	.\openb3d\src\geosphere.h	/^	float xcf,ycf,zcf; 			\/\/used to store camera position$/;"	m	class:Geosphere
ycf	.\openb3d\src\terrain.h	/^	float xcf,ycf,zcf; 			\/\/used to store camera position$/;"	m	class:Terrain
ypos	.\openb3d\src\stb_image.c	/^   int ypos;    \/\/ which pre-expansion row we're on$/;"	m	struct:__anon14	file:
ystep	.\openb3d\src\stb_image.c	/^   int ystep;   \/\/ how far through vertical expansion we are$/;"	m	struct:__anon14	file:
yzbuffer	.\openb3d\src\isosurface.h	/^	float ***yzbuffer;$/;"	m	class:Fluid
z	.\openb3d\src\collision2.h	/^	float x,y,z;$/;"	m	class:CollisionImpact
z	.\openb3d\src\geom.h	/^	float x,y,z;$/;"	m	class:Vector
z	.\openb3d\src\octree.h	/^	float x,y,z, width, height, depth;$/;"	m	class:OcTreeChild
z	.\openb3d\src\quaternion.h	/^float x,y,z,w;$/;"	m	class:Quaternion
z	.\openb3d\src\tilt.cpp	/^float Tilt::z=0.0;$/;"	m	class:Tilt	file:
z	.\openb3d\src\tilt.h	/^	static float x,y,z;$/;"	m	class:Tilt
z0	.\openb3d\src\csg.h	/^	float x0,y0,z0,u0,v0;$/;"	m	class:CSGTriangle
z1	.\openb3d\src\csg.h	/^	float x1,y1,z1,u1,v1;$/;"	m	class:CSGTriangle
z2	.\openb3d\src\csg.h	/^	float x2,y2,z2,u2,v2;$/;"	m	class:CSGTriangle
z_distance	.\openb3d\src\stb_image.c	/^   zhuffman z_length, z_distance;$/;"	m	struct:__anon16	file:
z_expandable	.\openb3d\src\stb_image.c	/^   int   z_expandable;$/;"	m	struct:__anon16	file:
z_length	.\openb3d\src\stb_image.c	/^   zhuffman z_length, z_distance;$/;"	m	struct:__anon16	file:
zbuf	.\openb3d\src\stb_image.c	/^} zbuf;$/;"	t	typeref:struct:__anon16	file:
zbuffer	.\openb3d\src\stb_image.c	/^   stbi__uint8 *zbuffer, *zbuffer_end;$/;"	m	struct:__anon16	file:
zbuffer_end	.\openb3d\src\stb_image.c	/^   stbi__uint8 *zbuffer, *zbuffer_end;$/;"	m	struct:__anon16	file:
zbuild_huffman	.\openb3d\src\stb_image.c	/^static int zbuild_huffman(zhuffman *z, stbi__uint8 *sizelist, int num)$/;"	f	file:
zcf	.\openb3d\src\geosphere.h	/^	float xcf,ycf,zcf; 			\/\/used to store camera position$/;"	m	class:Geosphere
zcf	.\openb3d\src\terrain.h	/^	float xcf,ycf,zcf; 			\/\/used to store camera position$/;"	m	class:Terrain
zget8	.\openb3d\src\stb_image.c	/^stbi_inline static int zget8(zbuf *z)$/;"	f	file:
zhuffman	.\openb3d\src\stb_image.c	/^} zhuffman;$/;"	t	typeref:struct:__anon15	file:
zhuffman_decode	.\openb3d\src\stb_image.c	/^stbi_inline static int zhuffman_decode(zbuf *a, zhuffman *z)$/;"	f	file:
zoom	.\openb3d\src\camera.h	/^	float zoom;$/;"	m	class:Camera
zout	.\openb3d\src\stb_image.c	/^   char *zout;$/;"	m	struct:__anon16	file:
zout_end	.\openb3d\src\stb_image.c	/^   char *zout_end;$/;"	m	struct:__anon16	file:
zout_start	.\openb3d\src\stb_image.c	/^   char *zout_start;$/;"	m	struct:__anon16	file:
zreceive	.\openb3d\src\stb_image.c	/^stbi_inline static unsigned int zreceive(zbuf *z, int n)$/;"	f	file:
~File	.\openb3d\src\file.h	/^	~File(){$/;"	f	class:File
~MeshCollider	.\openb3d\src\tree.cpp	/^MeshCollider::~MeshCollider(){$/;"	f	class:MeshCollider
~Node	.\openb3d\src\tree.h	/^		~Node(){ delete left;delete right; }$/;"	f	struct:MeshCollider::Node
~Surface	.\openb3d\src\surface.cpp	/^Surface::~Surface(){$/;"	f	class:Surface
